<!DOCTYPE html>
<html lang="vi">

<!-- Mirrored from visualgo.net/vi/maxflow by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 26 Nov 2020 06:40:27 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="description" content="Maximum (Max) Flow is one of the problems in the family of problems involving flow in networks.In Max Flow problem, we aim to find the maximum flow from a particular source vertex s to a particular sink vertex t in a weighted directed graph G.There are several algorithms for finding the maximum flow including Ford Fulkerson&#39;s method, Edmonds Karp&#39;s algorithm, and Dinic&#39;s algorithm (there are others, but not included in this visualization yet).The dual problem of Max Flow is Min Cut, i.e. by finding the max s-t flow of G, we also simultaneously find the min s-t cut of G, i.e. the set of edges with minimum weight that have to be removed from G so that there is no path from s to t in G.">
<meta name="keywords" content="Maximum Flow Network Flow MF Minimum Cut Ford Fulkerson Edmonds Karp Dinic Dinitz">
 
<meta name="csrf-token" content="iVivZ7KRPe6XK7pbuGtOoEjljE1xyBVNhLKNFuF8">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/maxflow.png">
<title>VisuAlgo - Network Flow (Max Flow, Min Cut)</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common.css">
<link rel="stylesheet" href="../css/viz-1.0.1.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
      }
      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }
      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
    </style>
<style>
.execAction { padding: 5px 8px; }
.err { padding: 5px 0px; }
#actions-extras input {
  width: 35px;
  padding: 5px 8px 7px;
}

#rookattack-input input {
  width: 20px;
  padding: 8px;
  margin-right: 2px;
  float:left;
}
#rookattack-input p { padding: 5px 8px; float : left;}
#rookattack-go p { 
  padding: 8px 8px 7px; 
  float:right;
}
#rookattack-board {
  height: 470px;
  width: 600px;
  margin-left: -300px;
  margin-top: -235px;
}

#baseball-input input {
  width: 25px;
  padding: 8px;
  margin-right: 2px;
  float:left;
}
#baseball-input p { padding: 5px 8px; float : left;}
#baseball-go p { 
  padding: 8px 8px 7px; 
  float:right;
}
#baseball-board {
  height: 470px;
  width: 600px;
  margin-left: -300px;
  margin-top: -235px;
}
#baseball-board input {
  width: 25px;
  padding: 8px;
  margin-right: 2px;
}

#bipartite0, #bipartite1, #bipartite2, #bipartite3 {
  float: left;
  padding: 2px;
}

/*  .modeling-actions {
    bottom: 200px;
    left: 200px;
    float:left;
  }
  .modeling-actions p { padding: 5px 10px; cursor: pointer; }
  .modeling-actions p:hover { background: black; color: white;}
  .modeling-actions p:first-of-type { padding-top: 10px; }
  .modeling-actions p:last-of-type { padding-bottom: 10px; }
  .modeling-actions-hide {
    bottom: 60px;
    left: 0px;
    padding-left: 14px;
    padding-right: 15px;
  }
*/

.modeling { bottom: 119px; }
.examples { bottom: 92px; }
.countmaxflow { bottom: 65px; }

#countmaxflow-fordfulkerson, #countmaxflow-edmondskarp, #countmaxflow-dinic { float: left; }
</style>
<script>
      function changeURL() {
        var URL = window.location.href.split('https://visualgo.net/');
        var val = document.getElementById("Language").value;
        URL[3] = val;
        window.location.assign(URL.join('https://visualgo.net/'));
      }
    </script>
</head>
<body>
<div id="top-bar">
<a href="http://www.comp.nus.edu.sg/~stevenha"><span class="colour" style="border: 1px solid green; border-radius: 25px;">7</span></a>&nbsp;&nbsp;&nbsp;
<a id="home" href="https://visualgo.net/">Visu<span class="colour">Algo</span><span style="font-size: 40%">.net</span></a>
/
<select id="Language" onchange="changeURL()">
<option value="en">en</option>
<option value="zh">zh</option>
<option value="es">es</option>
<option value="pt">pt</option>
<option value="ru">ru</option>
<option value="id">id</option>
<option value="de">de</option>
<option value="bn">bn</option>
<option value="ja">ja</option>
<option value="ko">ko</option>
<option value="vi" selected>vi</option>
</select>
/maxflow
<span class="right-links" id="useraccount">Login</span>
<span id="title">
<a id='title-maxflow' class='selected-viz'>Max Flow/Min Cut</a>
</span>
<div id="mode-menu">
<div id='mode-button' title='exploration'>Chế độ thăm dò &#9663;</div>
<div id='other-modes'>
<a title='e-Lecture'>Chế độ Bài giảng trực tuyến</a>
</div>
</div>
</div>
<div id="dark-overlay"></div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id='speed-control'>Chậm<div id='speed-input'></div>Nhanh<br></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick=goToBeginning()><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick=stepBackward()><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick=pause()><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick=play()><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick=stepForward()><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick=goToEnd()><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id='viz'></div>
<div id='current-action' class='panel'></div>
<div id='e-lecture' class='panel'></div>
<div id="overlay" hidden></div>
<div id="dropdown-temp-holder" hidden></div>
<div id="electure-1" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>Maximum (Max) Flow is one of the problems in the family of problems involving flow in networks.</p><br><p>In Max Flow problem, we aim to find the maximum flow from a particular source vertex <b>s</b> to a particular sink vertex <b>t</b> in a weighted directed graph <b>G</b>.</p><br><p>There are several algorithms for finding the maximum flow including Ford Fulkerson&#39;s method, Edmonds Karp&#39;s algorithm, and Dinic&#39;s algorithm (there are others, but not included in this visualization yet).</p><br><p>The dual problem of Max Flow is Min Cut, i.e. by finding the max <b>s-t</b> flow of <b>G</b>, we also simultaneously find the min <b>s-t</b> cut of <b>G</b>, i.e. the set of edges with minimum weight that have to be removed from <b>G</b> so that there is no path from <b>s</b> to <b>t</b> in <b>G</b>.</p>
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
Please <a href="https://visualgo.net/login"><u>login</u></a> if you are a repeated visitor or <a href="https://visualgo.net/login"><u>register</u></a> for an (optional) free account first.</p>
<div id='electure-dropdown'>
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. Maximum (Max) Flow</option>
<option value="2">2. Visualization </option>
<option value="2-1">&nbsp;&nbsp;&nbsp;2-1. Residual Graph</option>
<option value="3">3. Input</option>
<option value="4">4. Max Flow Algorithms</option>
<option value="4-1">&nbsp;&nbsp;&nbsp;4-1. Similar But Not The Same</option>
<option value="5">5. Implementation</option>
<option value="99">99. Status Panel</option>
<option value="99-1">&nbsp;&nbsp;&nbsp;99-1. Codetrace Panel</option>
<option value="99-2">&nbsp;&nbsp;&nbsp;99-2. Media Control</option>
<option value="99-3">&nbsp;&nbsp;&nbsp;99-3. Return to &#39;Exploration Mode&#39;</option>
</select>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-next' data-nextid="2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>This visualization page will show the execution of a chosen Max Flow algorithm running on a flow (residual) graph.</p><br><p>The input for a Max Flow algorithm is a flow graph (a <b>directed</b> graph <b>G</b> = <b>(V, E)</b> where edge weight represent the (unit) capacity of flow that can go through that edge) with two distinguished vertices: The source vertex <b>s</b> and the sink/target/destination vertex <b>t</b>.</p><br><p>To make the visualization of these flow graphs consistent, we enforce a graph drawing rule for this page whereby the source vertex <b>s</b>/sink vertex <b>t</b> is always vertex 0/<b>V</b>-1 and is always drawn on the leftmost/rightmost side of the visualization, respectively.</p><br><p>Another constraint is that the edge capacities are integers between [1..99].</p>
<hr>
<p>Pro-tip: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b> to advance to the next slide, <b>[PageUp]</b> to go back to the previous slide, <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2-1" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>At the start of the three Max Flow algorithms discussed in this visualization (Ford Fulkerson&#39;s method, Edmonds Karp&#39;s algorithm, and Dinic&#39;s algorithm), the initial flow graph is converted into residual graph.</p><br><p>The edges in the residual graph store the <i>remaining</i> capacities of those edges that can be used by future flow(s). At the beginning, these remaining capacities equal to the original capacities as specified in the input flow graph.</p><br><p>A Max Flow algorithm will send flows to use some (or all) of these available capacities, iteratively.</p><br><p>Once the remaining capacity of an edge reaches 0, that edge can no longer admit any more flow.</p>
<hr>
<p>Another pro-tip: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2017). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>There are three different sources for specifying an input graph:</p><ol><li><b>Draw Graph</b>: You can draw <b>any</b> directed weighted graph as the input graph with vertex 0 as the default source vertex (left side of the screen) and vertex <b>V</b>-1 as the default sink vertex (right side of the screen),</li><li><b>Modeling</b>: Several graph problems can be reduced into a max flow problem. In this visualization, we have the modeling examples for the famous Maximum Cardinality Bipartite Matching (MCBM) problem, Rook Attack problem (currently disabled), and Baseball Elimination problem (currently disabled),</li><li><b>Example Graphs</b>: You can select from the list of our selected example flow graphs to get you started.</li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>There are three different max flow algorithms in this visualization:</p><ol><li>The slow O(<b>mf * E</b>) <b>Ford Fulkerson&#39;s</b> method,</li><li>The O(<b>V * E^2</b>) <b>Edmonds Karp&#39;s</b> algorithm, or</li><li>The O(<b>V^2 * E</b>) <b>Dinic&#39;s</b> algorithm.</li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-1" class="electure-dialog" style="bottom:60px;left:50%;margin-left:-250px;width:500px;">
<p>For the three Max Flow algorithms discussed in this visualization, successive flows are sent from the source vertex <b>s</b> to the sink vertex <b>t</b> via available <b>augmenting paths</b>.</p><br><p>The three Max Flow algorithms in this visualization have different behavior on how they find augmenting paths.</p><br><p>However, all three Max Flow algorithms in this visualization stop when there is no more augmenting path possible and report the max flow value (and the assignment of flow on each edge in the flow graph).</p><br><p>Later we will discuss that this max flow value is also the min cut value of the flow graph.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>You are allowed to use/modify our implementation code for Max Flow Algorithms (Edmonds-Karp/Dinic&#39;s):<br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch8/maxflow.cpp" target="_blank"><u>maxflow.cpp</u></a><br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch8/maxflow.java" target="_blank"><u>maxflow.java</u></a><br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch8/maxflow.py" target="_blank"><u>maxflow.py</u></a><br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch8/maxflow.ml" target="_blank"><u>maxflow.ml</u></a><br></p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99" class="electure-dialog" style="right:150px;bottom:335px;width:500px;">
<p>As the action is being carried out, each step will be described in the status panel.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-1" class="electure-dialog" style="right:170px;bottom:275px;width:180px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-2" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-120px;width:260px;">
<p>Control the animation with the player controls! Keyboard shortcuts are:<br></p><div style="margin-top: 8px;"><strong>Spacebar:</strong> play/pause/replay</div><strong>Left/right arrows:</strong> step backward/step forward<br><strong>-/+:</strong> decrease/increase speed<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-3" class="electure-dialog" style="top:70px;right:60px;width:300px;">
<p>Return to &#39;Exploration Mode&#39; to start exploring!</p><br><p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99-2">Trước đó <u>PgUp</u></div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="actions" class="panel">
<p id="draw" onclick="drawGraph()">Vẽ đồ thị</p>
<p id="modeling">Modeling</p>
<p id="examples">Đồ thị ví dụ</p>
<p id="countmaxflow">Tình luồng cực đại</p>
</div>
<div id="actions-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide actions panel" /></div>
<div id="actions-extras">
<div class="modeling action-menu-pullout">

<div id="bipartite" class="execAction new-menu-option coloured-menu-option" onclick=modelingOpen("bipartite")>
<p>Bipartite Matching</p>
<div id="bipartite-input" class="new-menu-option">
<div id="bipartite0" class="execAction new-menu-option coloured-menu-option" onclick="bipartiteRandom(0)"><p>ngẫu nhiên</p></div>
<div id="bipartite1" class="execAction new-menu-option coloured-menu-option" onclick="bipartiteRandom(1)"><p>trái 1</p></div>
<div id="bipartite2" class="execAction new-menu-option coloured-menu-option" onclick="bipartiteRandom(2)"><p>phải 1</p></div>
<div id="bipartite3" class="execAction new-menu-option coloured-menu-option" onclick="bipartiteRandom(3)"><p>tất cả 1</p></div>
</div>
</div>
<div id="modeling-err" class="err"></div>
</div>
<div class="examples action-menu-pullout">
<div id="example0" class="execAction new-menu-option coloured-menu-option" onclick="example(CP3_4_24)"><p>CP3 4.24*</p></div>
<div id="example1" class="execAction new-menu-option coloured-menu-option" onclick="example(CP3_4_26_1)"><p>CP3 4.26.1 (s-lim)</p></div>
<div id="example2" class="execAction new-menu-option coloured-menu-option" onclick="example(CP3_4_26_2)"><p>CP3 4.26.2 (t-lim)</p></div>
<div id="example3" class="execAction new-menu-option coloured-menu-option" onclick="example(CP3_4_26_3)"><p>CP3 4.26.3</p></div>
<div id="example4" class="execAction new-menu-option coloured-menu-option" onclick="example(FORDFULKERSON_KILLER)"><p>Ford Fulkerson Killer</p></div>
<div id="example5" class="execAction new-menu-option coloured-menu-option" onclick="example(DINIC_SHOWCASE)"><p>Dinic Showcase</p></div>
</div>
<div class="countmaxflow action-menu-pullout">
<div class="new-menu-option">s = <input type="number" id="sourcevertex" title="Enter the source vertex" autocomplete="off" min=0 max=99 value=0>, t = <input type="number" id="sinkvertex" title="Enter the sink vertex" autocomplete="off" min=0 max=0 value=3></div>
<div id="countmaxflow-go" class="execAction coloured-menu-option" onclick="countmaxflow('GO')" title="Run Maximum Flow"><p>Go</p></div>
<div id="countmaxflow-algorithm">
<div id="countmaxflow-fordfulkerson" class="execAction coloured-menu-option" onclick=countmaxflow('fordfulkerson') title="Use Ford Fulkerson algorithm"><p>Ford Fulkerson</p></div>
<div id="countmaxflow-edmondskarp" class="execAction coloured-menu-option" onclick=countmaxflow('edmondskarp') title="Use Edmonds Karp algorithm"><p>Edmonds Karp</p></div>
<div id="countmaxflow-dinic" class="execAction coloured-menu-option" onclick=countmaxflow('dinic') title="Use Dinic algorithm"><p>Dinic</p></div>
</div>
<div id="countmaxflow-err" class="err"></div>
</div>
</div>
<div id="drawgraph" class="overlays"></div>
<div id="rookattack-board" class="overlays"></div>
<div id="baseball-board" class="overlays"></div>
<div id="bottom-bar">
<a id="trigger-about">Về</a>
<a id="trigger-team">Nhóm</a>
<a id="trigger-terms">Điều khoản sử dụng</a>
</div>
<div id="about" class="overlays">
<h4>Về</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
VisuAlgo được lên ý tưởng vào năm 2011 bởi tiến sĩ Steven Halim như là một công cụ để giúp những sinh viên của ông ấy có thể hiểu rõ hơn về các cấu trúc dữ liệu và thuật toán, bằng cách cho phép họ tự học những nội dung cơ bản nhất với tiến độ phù hợp với riêng họ.<br>VisuAlgo chứa rất nhiều thuật toán nâng cao đã được thảo luận trong cuốn sách của Tiến sĩ Steven Halim (&#39;Competitive Programming&#39;, đồng tác giả với anh trai của ông ấy, tiến sĩ Felix Halim) và hơn thế nữa. Hiện tại, một số mô phỏng/hiệu ứng hoạt hình của các thuật toán nâng cao này chỉ có thể tìm thấy ở VisuAlgo.<div>Mặc dù được thiết kế đặc biệt cho những sinh viên đại học quốc gia Singapore (phải học rất nhiều môn học về cấu trúc dữ liệu và thuật toán - ví dụ: CS1010, CS1020, CS2010, CS2020, CS3230, and CS3230), như những người ủng hộ việc học trực tuyến, chúng tôi hi vọng rằng những người quan tâm tới cấu trúc dữ liệu và thuật toán trên toàn thế giới cũng có thể thấy những mô tả này là hữu dụng.<br>Ngay từ đầu, VisuAlgo không được thiết kế để làm việc tốt trên những màn hình cảm ứng nhỏ (ví dụ như smartphones) do việc mô phỏng các thuật toán phức tạp cần rất nhiều điểm ảnh và cử chỉ nhấp và kéo để tương tác. Độ phân giải màn ảnh nhỏ nhất cho trải nghiệm người dùng chấp nhận được là 1024x768 và chỉ có duy nhất trang đích là tương đối thân thiện với bản di động.</div><div>VisuAlgo là một dự án liên tục và nhiều mô phỏng phức tạp vẫn đang được phát triển.<br>Cải tiến thú vị nhất là tạo và duyệt câu hỏi tự động (hệ thống câu hỏi trực tuyến) cho phép sinh viên kiểm tra kiến thức cơ bản về các cấu trúc dữ liệu và thuật toán. Các câu hỏi được tạo ngẫu nhiên thông qua những quy luật và câu trả lời của sinh viên sẽ được chấm điểm tự động và ngay lập tức dựa trên việc nộp bài tới server chấm điểm của chúng tôi. Hệ thống câu hỏi trực tuyến này, khi mà nó được chấp nhận bởi nhiều giảng viên CS trên toàn thế giới, sẽ xóa bỏ mặt kĩ thuật các câu hỏi về cấu trúc dữ liệu và thuật toán cơ bản khỏi các kỳ thi khoa học máy tính điển hình tại rất nhiều trường đại học. Bằng cách đặt một tiêu chí chấm điểm nhỏ (nhưng khác 0) vào việc vượt qua các câu hỏi trực tuyến, giảng viên CS có thể làm tăng (một cách đáng kể) sự thành thạo của những sinh viên trên những câu hỏi cơ bản này khi họ một lượng vô số các câu hỏi thực tế cho sự luyện tập cái mà có thể được kiểm chứng ngay lập tức trước khi họ làm câu hỏi trực tuyến. Hiện tại, chế độ hướng dẫn bao gồm các câu hỏi cho 12 module mô phỏng. Chúng tôi sẽ sớm thêm vào 8 module mô phỏng còn lại để cho tất cả các module mô phỏng ở VisuAlgo đều có phần câu hỏi trực tuyến.<br>Một cải tiến hấp dẫn khác là việc quốc tế hóa các dự án nhánh của VisuAlgo. Chúng tôi muốn chuẩn bị cơ sở dữ liệu các thuật ngữ CS cho các văn bản tiếng Anh đã từng xuất hiện trên hệ thống VisuAlgo. Đây là một nhiệm vụ lớn và cần điện toán đám đông. Một khi hệ thống đã sẵn sàng, chúng tôi sẽ mời người dùng VisuAlgo đóng góp, đặc biệt là khi bạn không phải là người nói tiếng Anh bản ngữ. Hiện tại, chúng tôi cũng đang viết những ghi chú về VisuAlgo bằng những ngôn ngữ khác nhau.<br></div>
<a href="https://weibo.com/p/230418436e9ee80102v4rk" target='_blank'><u>zh</u></a>, <a href='https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689' target='_blank'><u>id</u></a>, <a href="https://blog.naver.com/visualgo_nus" target='_blank'><u>kr</u></a>, <a href='https://www.facebook.com/groups/163215593699283/permalink/824003417620494/' target='_blank'><u>vn</u></a>, <a href='http://pantip.com/topic/32736343' target='_blank'><u>th</u></a>.</p>
</div>
</div>
<div id="team" class="overlays">
<h4>Nhóm</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
<p>
<strong><span style='line-height: 150%;'>Trưởng dự án và cố vấn (từ tháng 7/2011 đến nay)</span></strong><br>
<a href='http://www.comp.nus.edu.sg/~stevenha/' target='_blank'>Dr Steven Halim</a>, Senior Lecturer, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href='http://felix-halim.net/' target='_blank'>Dr Felix Halim</a>, Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style='line-height: 150%;'>Những nhà nghiên cứu sinh viên 1 (Jul 2011-Apr 2012)</span></strong><br>
Koh Zi Chun, <a href='http://roticv.rantx.com/' target='_blank'>Victor Loh Bo Huai</a>
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 1 (Jul 2012-Dec 2013)</span></strong><br>
Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 2 (Jun 2013-Apr 2014)</span></strong><br>
<a href='http://www.rosemarietan.com/' target='_blank'>Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style='line-height: 150%;'>Những nhà nghiên cứu sinh viên 2 (May 2014-Jul 2014)</span></strong><br>
Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 3 (Jun 2014-Apr 2015)</span></strong><br>
Erin Teo Yi Ling, Wang Zi
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 4 (Jun 2016-Dec 2017)</span></strong><br>
Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir
</p>
<p>
List of translators who have contributed &ge;100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style='line-height: 150%;'>Lời cảm ơn</span></strong><br>
This project is made possible by the generous <a href="http://www.cdtl.nus.edu.sg/teg/" target="_blank">Teaching Enhancement Grant</a> from NUS Centre for Development of Teaching and Learning (CDTL).
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Điều khoản sử dụng</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
VisuAlgo miễn phí đối với cộng đồng Khoa học Máy tính trên toàn thế giới. Nếu bạn yêu thích VisuAlgo, khoản chi phí duy nhất mà chúng tôi muốn bạn chi trả chính là hãy nói cho những <b>sinh viên/ giảng viên ngành khoa học máy tính</b> mà bạn biết<b> về sự tồn tại của VisuAlgo</b> =) thông qua Facebook, Twitter, trang web về khóa học, blog review, email , v.v &amp; v.v. Nếu bạn là một<b> sinh viên/ giảng viên</b> ngành cấu trúc dữ liệu và thuật toán, bạn được phép sử dụng website này một cách trực tiếp trong các lớp học của bạn. Nếu bạn lấy những ảnh chụp màn hình (videos) từ website này, bạn có thể sử dụng chúng ở bất kỳ đâu, miễn là có dẫn nguồn URL của website này (http://visualgo.net) và/hoặc liệt kê các công bố ở dưới như là tài liệu tham khảo. Tuy nhiên, bạn <b>KHÔNG</b> được phép tải xuống các tập tin VisuAlgo (phía máy trạm) và lưu trữ nó ở website riêng của bạn vì nó được coi là <b>đạo ý tưởng</b> .Hiện tại, chúng tôi <b>KHÔNG</b> cho phép những người khác chia nhỏ dự án này và tạo ra những phiên bản khác của VisuAlgo. Việc sử dụng bản sao ngoại tuyến của VisuAlgo (phía máy trạm) cho mục đích cá nhân của bạn thì có thể chấp nhận được.<br>Lưu ý rằng hệ thống câu hỏi trực tuyến của VisuAlgo có phần dữ liệu phía máy chủ rất lớn và không dễ dàng để lưu lại mã kịch bản phía máy chủ và cơ sở dữ liệu một cách cục bộ. Hiện tại, mọi người chỉ có thể sử dụng "chế độ đào tạo" để truy cập hệ thống câu hỏi trực tuyến này. Chế độ kiểm tra hiện là môi trường có kiểm soát hơn cho việc sử dụng những câu hỏi được tạo ngẫu nhiên này và tự động kiểm duyệt cho kỳ thi <b>thật sự</b> tại Đại học Quốc gia Singapore<span style="white-space: normal;">.</span> Những giảng viên quan tâm tới khoa học máy tính có thể liên hệ với Steven nếu muốn trải nghiệm "chế độ kiểm tra"<br><b>Danh sách phát hành</b><br>Dự án này đươc trình bày một cách vắn tắt ở Hội thảo CLI tại ACM ICPC World Finals 2012 (Warsaw, Ba Lan) và tại Hội nghị IOI 2012 (Sirmione-Montichiari, Italy). Bạn có thể nhấn vào link này để đọc bài viết năm 2012 của chúng tôi về hệ thống này (nó không được gọi là VisuAlgo vào năm 2012)<br>Dự án này được hoàn thiện hầu hết bởi những cựu sinh viên của tôi. Báo cáo cuối cùng gần đây nhất là của: <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/erin-report.pdf" target="_blank">Erin</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/wangzi-report.pdf" target="_blank">Wang Zi</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/rose-report.pdf" target="_blank">Rose</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/ivan-report.pdf" target="_blank">Ivan</a>.<br><b>Báo cáo lỗi hoặc đề xuất tính năng mới</b><br>VisuAlgo là một dự án chưa hoàn thiện. Tiến sĩ Steven Halim vẫn đang tiếp tục phát triển VisuAlgo một cách tích cực/ Nếu bạn đang sử dụng VisuAlgo và phát hiện ra lỗi ở bất kỳ trang mô phỏng/ công cụ câu hỏi trực tuyến nào của chúng tôi hoặc nếu bạn muốn đề xuất những tính năng mới, hãy liên lạc với Tiến sĩ Steven Halim. Địa chỉ liên lạc của ông ấy là stevenhalim@gmail.com<br>
</div>
</div>

<script src="../js/jquery-3.3.1.min.js"></script>
<script>
      var PHP_DOMAIN = "";

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        //setTimeout(function() {
          if (retval) { // mode == "exploration" && // now not only for exploration mode, but check if this opens other problems
            $('#current-action').show();
            $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
            $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
            triggerRightPanels();
            isPlaying = true;
          }
        //}, 500);
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; i++) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.right-links').css('background', surpriseColour);
        $('#login-go').css('background', surpriseColour);

        $('.colour').css("color", surpriseColour); // name
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
          // temporary quick fix for Google Chrome Aug 2016 issue...
          setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 100); // force resize/redraw...
          setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        });

        // overlays stuffs
        $('#trigger-about').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#about').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('#trigger-team').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#team').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('#trigger-terms').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#termsofuse').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('.close-overlay').click(function() {
          $('.overlays').fadeOut(function() {
            $('#dark-overlay').fadeOut();
          });
        });

        $('#dark-overlay').click(function() {
          $('.overlays').fadeOut();
          $('#dark-overlay').fadeOut();
        });

        $.get('/isloggedin', function(data) {
          var isLoggedIn = data['isloggedin'] == '1';
          var element;
          if (isLoggedIn) {
            // element = '<a onclick="verifyLogout()">Đăng Xuất<div><br></div></a>';
            element = '<a href="https://visualgo.net/profile">Profile</a>'; 
          }
          else {
            element = '<a href="https://visualgo.net/login">Đăng nhập</a>'
          }
          $('#useraccount').html(element);
        });
      });

      function verifyLogout() {
        // Steven's remarks: use a better 'confirm' than the default :(
        var doesLogout = confirm('Are you sure to logout?');
        if (doesLogout == true) {
          window.location = "https://visualgo.net/logout";
        }
      }

      function checkLogin() {
        $.get('/checklogin', function(data) {
          var url = data['url'];
          window.location.href = '/' + url;
        });
      }

      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','../../www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-1566631-4', 'auto');
      ga('send', 'pageview');
    </script>

<script src="../js/jquery-ui.min.js"></script>

<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.3.js"></script>
<script src="../js/visualgo_print.js"></script>
<script src="../js/graph_library.js"></script>
<script>
      function runSlide(slide) {
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 9 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 18 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-1') {
          $("#e-lecture").html("slide " + slide + " (" + 27 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 36 + "%)");
          $("#draw").addClass("menu-highlighted");
$("#modeling").addClass("menu-highlighted");
$("#random").addClass("menu-highlighted");
$("#examples").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 45 + "%)");
          $("#countmaxflow").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-1') {
          $("#e-lecture").html("slide " + slide + " (" + 54 + "%)");
          $("#countmaxflow").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5') {
          $("#e-lecture").html("slide " + slide + " (" + 63 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99') {
          $("#e-lecture").html("slide " + slide + " (" + 72 + "%)");
          
          hideEntireActionsPanel();
 
          showStatusPanel();
          showCodetracePanel();
      
        }
        if (slide == '99-1') {
          $("#e-lecture").html("slide " + slide + " (" + 81 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99-2') {
          $("#e-lecture").html("slide " + slide + " (" + 90 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99-3') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };

      function pushState(slideValue) {
        var url = '/vi/maxflow';
        if (typeof slideValue != 'undefined' && slideValue != null) url += '?slide=' + slideValue;
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5); 
        $('#overlay').show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      $(function() {
        var slide = getUrlParameter('slide');
        
        $.get('/hasvisited' + '/maxflow', function(data) {
          var hasVisited = data['hasvisited'] == '1';
          if (!hasVisited) {
            var postData = {
              '_token': 'iVivZ7KRPe6XK7pbuGtOoEjljE1xyBVNhLKNFuF8',
              'page': '/maxflow'.substring(1),
            };

            $.post("/visitpage", postData, function(data) {
              // non critical request...
            });

            if (typeof slide != undefined && slide != null) {
              cur_slide = slide;
            }

            $("#mode-menu a").trigger("click");
          }
          else {
            if (typeof slide != undefined && slide != null) {
              cur_slide = slide;
              $('#mode-menu a').click();
            }    
          }
        }).fail(function() {
          if (typeof slide != undefined && slide != null) {
            cur_slide = slide;
            $('#mode-menu a').click();
          }
        });

        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
      
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
      
        $('#electure-2-1 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
      
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
      
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
      
        $('#electure-4-1 .electure-next').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-4-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
      
        $('#electure-5 .electure-next').click(function() {
          hidePopup();
          runSlide('99');
          pushState('99');
        });
        $('#electure-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
      
        $('#electure-99 .electure-next').click(function() {
          hidePopup();
          runSlide('99-1');
          pushState('99-1');
        });
        $('#electure-99 .electure-prev').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
      
        $('#electure-99-1 .electure-next').click(function() {
          hidePopup();
          runSlide('99-2');
          pushState('99-2');
        });
        $('#electure-99-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('99');
          pushState('99');
        });
      
        $('#electure-99-2 .electure-next').click(function() {
          hidePopup();
          runSlide('99-3');
          pushState('99-3');
        });
        $('#electure-99-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('99-1');
          pushState('99-1');
        });
      
        $('#electure-99-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('99-2');
          pushState('99-2');
        });
      
 

        // temporary quick fix for Google Chrome Aug 2016 issue..., put at last part so that everything else has been loaded
        // setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 500);
        // setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        // I turn it off on 14 June 2018, seems 'ok'?
      });


      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();  
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url.html) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}
    </script>
<script type="text/javascript">
// MaxFlow Widget
// original author: Jonathan Irvin Gunawan, then maintained by Steven Halim

// Maximum Flow Example Constants
var noOfExamples = 6;
var INF = 1000000000;

var MaxFlow = function() {
  var gw = new GraphWidget();

  var iVL = {};
  var iEL = {};
  var amountVertex = 0;
  var amountEdge = 0;
  var stateList = [];

  this.getGraphWidget = function() { return gw; }

  fixJSON = function() {
    amountVertex = 0;
    amountEdge = 0;
    for (var key in iVL) ++amountVertex;
    for (var key in iEL) ++amountEdge;

    for (var key in iEL) iEL[key]["w"] = +iEL[key]["w"]; // make it intege weight

    // for (var key in iEL) {
    //   iEL[key]["type"] = EDGE_TYPE_UDE;
    //   iEL[key]["displayWeight"] = true;
    // }
    // for (var key in iVL)
    //   iVL[key]["text"] = key;
    // for (var key in iEL) {
    //   iVL[iEL[key]["vertexA"]][iEL[key]["vertexB"]] = +key;
    //   iVL[iEL[key]["vertexB"]][iEL[key]["vertexA"]] = +key;
    //   iEL[key]["weight"] = +iEL[key]["weight"];
    // }
  }

  takeJSON = function(graph) {
    if (graph == null) return;
    graph = JSON.parse(graph);
    iVL = graph["vl"];
    iEL = graph["el"];
    fixJSON();
  }

  statusChecking = function() {
    if (amountVertex == 0) $("#draw-status p").html("Graph is empty.<br>Please draw a <b>weighted flow</b> graph");
    else                   $("#draw-status p").html("Please draw a <b>weighted flow</b> graph that connects <b>source vertex #0 to sink vertex #{lastVertex}</b> (last vertex). Note: edge weight represents the capacity of the edge".replace("{lastVertex}", amountVertex-1));
    $("#sinkvertex").val(amountVertex-1);
  }

  warnChecking = function() {
    var warn = "";
    if (amountVertex >= 10) warn += "Quá nhiều đỉnh hiện trên màn hình, hãy vẽ 1 đồ thị nhỏ hơn.";

    if (warn == "") $("#draw-warn p").html("No Warning");
    else $("#draw-warn p").html(warn);
  }

  errorChecking = function() {
    var error = "";
    if (amountVertex == 0) {
      $("#draw-err p").html("Đồ thị không thể rỗng.");
      return;
    }
    
    var visited = [];
    var stack = [];
    stack.push(0);
    visited[0] = true;
    while (stack.length > 0) {
      var now = stack.pop();
      for (var key2 in iEL) if(iEL[key2]["u"] == now) {
        if (!visited[iEL[key2]["v"]]) {
          visited[iEL[key2]["v"]] = true;
          stack.push(+iEL[key2]["v"]);
        }
      }
    }
    if (!visited[amountVertex-1]) 
      error = error + "Đỉnh phát và đỉnh thu không được nối với nhau."
    var leftmost = INF, rightmost = -INF;
    for (var key in iVL) {
      leftmost = Math.min(leftmost,iVL[key]["x"]);
      rightmost = Math.max(rightmost,iVL[key]["x"]);
    }
    if (leftmost < iVL[0]["x"])
      error = error + "Đỉnh phát không phải là đỉnh nằm ở tận cùng bên trái."
    if (rightmost > iVL[amountVertex-1]["x"])
      error = error + "Đỉnh thu không phỉa là đỉnh nằm ở tận cùng bên phải."

    if (error == "") $("#draw-err p").html("Không có lỗi.");
    else $("#draw-err p").html(error);
  }

  var intervalID;

  this.startLoop = function() {
    intervalID = setInterval(function() {
      takeJSON(JSONresult);
      warnChecking();
      errorChecking();
      statusChecking();
    }, 100);
  }

  this.stopLoop = function() { clearInterval(intervalID); }
  
  this.draw = function() {
    if ($("#draw-err p").html() != "Không có lỗi.") return false;
    if ($("#submit").is(':checked'))
      this.submit(JSONresult);
    if ($("#copy").is(':checked'))
      window.prompt("Copy to clipboard:",JSONresult);
    graph = createState(iVL, iEL);
    gw.updateGraph(graph, 500);
    return true;
  }

  this.submit = function(graph) {
    $.ajax({
      url: PHP_DOMAIN + "/php/Graph.php?mode=" + MODE_SUBMIT_GRAPH + "&sessionID=" + $.cookie("sessionID"),
      type: "POST",
      data: {canvasWidth: 1000, canvasHeight: 500, graphTopics: 'Max Flow', graphState: graph},
      error: function(xhr, errorType, exception) { //Triggered if an error communicating with server  
          var errorMessage = exception || xhr.statusText; //If exception null, then default to xhr.statusText  

          alert("Lỗi khi nhập đồ thị." + errorMessage);
      }
    }).done(function(data) {
      console.log(data);
    });
  }

  this.importjson = function(text) {
    //var text = $("#samplejson-input").val();
    takeJSON(text);
    statusChecking();
    graph = createState(iVL,iEL);
    gw.updateGraph(graph, 500);
  }
    
  this.initRandom = function(graph) {
    iVL = graph.iVL;
    iEL = graph.iEL;
    amountVertex = iVL.length;
    amountEdge = iEL.length;
    fixJSON();
    statusChecking();
    var newState = createState(iVL, iEL);

    gw.updateGraph(newState, 500);
  }

  //returns index of edge in iEL that connects vertexA to vertexB, eh this can be put in helper object...
  var findEdgeIndex = function(vertexA, vertexB) {
    for (i in iEL)
      if (iEL[i]["u"] == vertexA && iEL[i]["v"] == vertexB)
        return i;
    return -1;
  }

  this.fordfulkerson = function(sourceVertex, sinkVertex) {
    var existAugmentingPath = true;
    var MaxFlow = 0;
    var numberOfAugmentingPaths = 0;

    while (existAugmentingPath) {
      numberOfAugmentingPaths++;
      existAugmentingPath = false;
      var edgeYellow = {};
      var edgeRed = {};
      var edgeBlue = {};
      var vertexTraversed = {};
      var vertexHighlighted = {};
      var parent = new Array(amountVertex);
      var visited = new Array(amountVertex);
      for (i in iVL) {
        parent[i] = -1;
        visited[i] = false;
      }

      var DFSStack = [];
      DFSStack.push([sourceVertex,INF]);
      while (DFSStack.length > 0) {
        var now = DFSStack.pop(); // last most item
        var nowVertex = now[0];
        var nowCapacity = +now[1];
        if (visited[nowVertex]) continue;
        visited[nowVertex] = true;
        if (nowVertex == sinkVertex) {
          var path = [];
          while (nowVertex != sourceVertex) {
            path.push(nowVertex);
            nowVertex = parent[nowVertex];
          }
          path.push(sourceVertex);
          var bottleneck = [-1,-1]; //[forward edge,back edge]

          for (var i = path.length-1; i >= 1; --i) {
            var backEdge = findEdgeIndex(path[i-1],path[i]);
            var forwardEdge = findEdgeIndex(path[i],path[i-1]);
            if (bottleneck[0] == -1 || iEL[forwardEdge]["w"] < iEL[bottleneck[0]]["w"]) {
              if (bottleneck[0] != -1) {
                delete edgeRed[bottleneck[0]];
                delete edgeRed[bottleneck[1]];
                edgeYellow[bottleneck[0]] = true;
                edgeYellow[bottleneck[1]] = true;
              }
              edgeRed[backEdge] = true;
              edgeRed[forwardEdge] = true;
              bottleneck = [forwardEdge, backEdge];
            }
            else {
              edgeYellow[backEdge] = true;
              edgeYellow[forwardEdge] = true;
            }
            cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow);
            cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                              .replace("{sourceVertex}", sourceVertex)
                              .replace("{sinkVertex}", sinkVertex)
                              .replace("{MaxFlow}", MaxFlow);
            cs["status"] += "<br>Find an augmenting path. Bottleneck is {bottleneck} (red edge)</br>".replace("{bottleneck}", iEL[bottleneck[0]]["w"]);
            cs["lineNo"] = [3];
            stateList.push(cs);
          }

          cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
          cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                            .replace("{sourceVertex}", sourceVertex)
                            .replace("{sinkVertex}", sinkVertex)
                            .replace("{MaxFlow}", MaxFlow);
          cs["status"] += "<br>Got an augmenting path by DFS. Bottleneck is {bottleneck} (red edge)</br>".replace("{bottleneck}", nowCapacity);
          cs["lineNo"] = [3];
          stateList.push(cs);

          nowVertex = sinkVertex;
          while (nowVertex != sourceVertex) {            
            var backEdge = findEdgeIndex(nowVertex,parent[nowVertex]);
            var forwardEdge = findEdgeIndex(parent[nowVertex],nowVertex);

            iEL[forwardEdge]["w"] -= nowCapacity;
            iEL[backEdge]["w"] += nowCapacity;

            var bottleneck = false;

            if (edgeRed.hasOwnProperty(backEdge)) bottleneck = true;

            if (bottleneck) {
              delete edgeRed[forwardEdge];
              delete edgeRed[backEdge];
            }
            else {
              delete edgeYellow[forwardEdge];
              delete edgeYellow[backEdge];
            }

            edgeBlue[forwardEdge] = true;
            edgeBlue[backEdge] = true;

            cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
            cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                              .replace("{sourceVertex}", sourceVertex)
                              .replace("{sinkVertex}", sinkVertex)
                              .replace("{MaxFlow}", MaxFlow);
            cs["status"] += "<br>Bottleneck is {bottleneck} (red edge). Updating edge from {parent} to {nowVertex} (blue edge)</br>"
                              .replace("{bottleneck}", nowCapacity)
                              .replace("{parent}", parent[nowVertex])
                              .replace("{nowVertex}", nowVertex);
            cs["lineNo"] = [4, 5, 6];

            nowVertex = parent[nowVertex];
            stateList.push(cs);

            delete edgeBlue[forwardEdge];
            delete edgeBlue[backEdge];

            if (bottleneck) {
              edgeRed[forwardEdge] = true;
              edgeRed[backEdge] = true;
            }
            else {
              edgeYellow[forwardEdge] = true;
              edgeYellow[backEdge] = true;
            }

          }
          existAugmentingPath = true;
          MaxFlow += nowCapacity;
          cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
          cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                            .replace("{sourceVertex}", sourceVertex)
                            .replace("{sinkVertex}", sinkVertex)
                            .replace("{MaxFlow}", MaxFlow);
          cs["status"] += "<br>Luồng cực đại tăng thêm đến {nowCapacity}<br>".replace("{nowCapacity}", nowCapacity);
          cs["lineNo"] = [7];
          stateList.push(cs);
          break;
        }
        var DFStempStack = [];
        for (i in iEL) {
          var vertexA = iEL[i]["u"];
          var vertexB = iEL[i]["v"];
          var capacity = iEL[i]["w"];
          if (nowVertex == vertexA && !visited[vertexB] && capacity > 0) {
            parent[vertexB] = vertexA;
            if (numberOfAugmentingPaths % 2 == 0 && nowVertex == 0) {
              if (capacity < nowCapacity)
                DFStempStack.push([vertexB,capacity]);
              else DFStempStack.push([vertexB,nowCapacity]);
            }
            else {
              if (capacity < nowCapacity)
                DFSStack.push([vertexB,capacity]);
              else DFSStack.push([vertexB,nowCapacity]);
            }
          }
        }
        while (DFStempStack.length > 0)
          DFSStack.push(DFStempStack.pop());
      }
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
    cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is {MaxFlow}.<br>No more augmenting path."
                      .replace("{sourceVertex}", sourceVertex)
                      .replace("{sinkVertex}", sinkVertex)
                      .replace("{MaxFlow}", MaxFlow);
    cs["lineNo"] = [];
    stateList.push(cs);
    populatePseudocode(1);

    return MaxFlow;
  }

  this.edmondskarp = function(sourceVertex, sinkVertex) {
    var existAugmentingPath = true;
    var MaxFlow = 0;

    while (existAugmentingPath) {
      existAugmentingPath = false;
      var edgeYellow = {};
      var edgeRed = {};
      var edgeBlue = {};
      var vertexTraversed = {};
      var vertexHighlighted = {};
      var parent = new Array(amountVertex);
      var visited = new Array(amountVertex);
      for (i in iVL) {
        parent[i] = -1;
        visited[i] = false;
      }

      var BFSQueue = [];
      BFSQueue.push([sourceVertex,INF]);
      visited[sourceVertex] = true;
      while (BFSQueue.length > 0)  {
        var now = BFSQueue.shift(); // pop front item
        var nowVertex = now[0];
        var nowCapacity = +now[1];
        if (nowVertex == sinkVertex) {
          var path = [];
          while (nowVertex != sourceVertex) {
            path.push(nowVertex);
            nowVertex = parent[nowVertex];
          }
          path.push(sourceVertex);
          var bottleneck = [-1, -1]; //[forward edge,back edge]

          for (var i = path.length-1; i >= 1; i--) {
            var backEdge = findEdgeIndex(path[i-1],path[i]);
            var forwardEdge = findEdgeIndex(path[i],path[i-1]);
            //if capacity < bottleneck
            if (bottleneck[0] == -1 || iEL[forwardEdge]["w"] < iEL[bottleneck[0]]["w"]) {
              // update bottleneck
              if (bottleneck[0] != -1) {
                delete edgeRed[bottleneck[0]];
                delete edgeRed[bottleneck[1]];
                edgeYellow[bottleneck[0]] = true;
                edgeYellow[bottleneck[1]] = true;
              }
              edgeRed[backEdge] = true;
              edgeRed[forwardEdge] = true;
              bottleneck = [forwardEdge,backEdge];
            }
            else {
              edgeYellow[backEdge] = true;
              edgeYellow[forwardEdge] = true;
            }
            cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow);
             cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                              .replace("{sourceVertex}", sourceVertex)
                              .replace("{sinkVertex}", sinkVertex)
                              .replace("{MaxFlow}", MaxFlow);
            cs["status"] += "<br>Find an augmenting path. Bottleneck is {bottleneck} (red edge)</br>".replace("{bottleneck}", iEL[bottleneck[0]]["w"]);
            cs["lineNo"] = [3];
            //stateList.push(cs); // SH7: quick visual bug fix (EK's BFS looks like DFS) by not saving this state in the stateList
          }

          cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow);
          cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                            .replace("{sourceVertex}", sourceVertex)
                            .replace("{sinkVertex}", sinkVertex)
                            .replace("{MaxFlow}", MaxFlow);
          cs["status"] += "<br>Got an augmenting path by DFS. Bottleneck is {bottleneck} (red edge)</br>".replace("{bottleneck}", nowCapacity);
          cs["lineNo"] = [3];
          stateList.push(cs);

          nowVertex = sinkVertex;

          while (nowVertex != sourceVertex) {
            var backEdge = findEdgeIndex(nowVertex,parent[nowVertex]);
            var forwardEdge = findEdgeIndex(parent[nowVertex],nowVertex);

            iEL[forwardEdge]["w"] -= nowCapacity;
            iEL[backEdge]["w"] += nowCapacity;

            var bottleneck = false;

            if (edgeRed.hasOwnProperty(backEdge)) bottleneck = true;

            if (bottleneck) {
              delete edgeRed[forwardEdge];
              delete edgeRed[backEdge];
            }
            else {
              delete edgeYellow[forwardEdge];
              delete edgeYellow[backEdge];
            }

            edgeBlue[forwardEdge] = true;
            edgeBlue[backEdge] = true;

            cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
            cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                              .replace("{sourceVertex}", sourceVertex)
                              .replace("{sinkVertex}", sinkVertex)
                              .replace("{MaxFlow}", MaxFlow);
            cs["status"] += "<br>Bottleneck is {bottleneck} (red edge). Updating edge from {parent} to {nowVertex} (blue edge)</br>"
                              .replace("{bottleneck}", nowCapacity)
                              .replace("{parent}", parent[nowVertex])
                              .replace("{nowVertex}", nowVertex);
            cs["lineNo"] = [4, 5, 6];

            nowVertex = parent[nowVertex];
            stateList.push(cs);

            delete edgeBlue[forwardEdge];
            delete edgeBlue[backEdge];

            if (bottleneck) {
              edgeRed[forwardEdge] = true;
              edgeRed[backEdge] = true;
            }
            else {
              edgeYellow[forwardEdge] = true;
              edgeYellow[backEdge] = true;
            }
          }

          existAugmentingPath = true;
          MaxFlow += nowCapacity;
          cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
          cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                            .replace("{sourceVertex}", sourceVertex)
                            .replace("{sinkVertex}", sinkVertex)
                            .replace("{MaxFlow}", MaxFlow);
          cs["status"] += "<br>Luồng cực đại tăng thêm đến {nowCapacity}<br>".replace("{nowCapacity}", nowCapacity);
          cs["lineNo"] = [7];
          stateList.push(cs);
          break;
        }
        for (i in iEL) {
          var vertexA = iEL[i]["u"];
          var vertexB = iEL[i]["v"];
          var capacity = iEL[i]["w"];
          if (nowVertex == vertexA && !visited[vertexB] && capacity > 0) {
            visited[vertexB] = true;
            parent[vertexB] = vertexA;
            if (capacity < nowCapacity)
              BFSQueue.push([vertexB,capacity]);
            else BFSQueue.push([vertexB,nowCapacity]);
          }
        }
      }
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
    cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is {MaxFlow}.<br>No more augmenting path."
                      .replace("{sourceVertex}", sourceVertex)
                      .replace("{sinkVertex}", sinkVertex)
                      .replace("{MaxFlow}", MaxFlow);
    cs["lineNo"] = [];
    stateList.push(cs);
    populatePseudocode(0);

    return MaxFlow;
  }

  this.dinic = function(sourceVertex, sinkVertex) {
    var existBlockingFlow = true;
    var MaxFlow = 0;

    while (existBlockingFlow) {
      existBlockingFlow = false;
      var edgeBlue = {};
      var vertexTraversed = {};
      var vertexHighlighted = {};
      var visited = new Array(amountVertex);
      var distance = new Array(amountVertex);
      for (i in iVL) {
        visited[i] = false;
        distance[i] = INF;
      }

      var BFSQueue = [];
      BFSQueue.push(sourceVertex);
      distance[sourceVertex] = 0;
      while (BFSQueue.length > 0) {
        var nowVertex = BFSQueue.shift();
        for (i in iEL) {
          var vertexA = iEL[i]["u"];
          var vertexB = iEL[i]["v"];
          var capacity = iEL[i]["w"];
          if (nowVertex == vertexA && distance[vertexB] == INF && capacity > 0) {
            distance[vertexB] = distance[vertexA] + 1;
            BFSQueue.push(vertexB);
          }
        }
      }
      for (i in iEL) {
        var vertexA = iEL[i]["u"];
        var vertexB = iEL[i]["v"];
        var capacity = iEL[i]["w"];
        if (capacity > 0 && distance[vertexB] == distance[vertexA]+1 && distance[vertexB] <= distance[sinkVertex]) {
          edgeBlue[i] = true;
          edgeBlue[findEdgeIndex(vertexB,vertexA)] = true;
        }
      }

      if (distance[sinkVertex] == INF) break;
      
      cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
      cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is {MaxFlow}.<br>Got the level graph (blue edges). Sink is level {distance}."
                      .replace("{sourceVertex}", sourceVertex)
                      .replace("{sinkVertex}", sinkVertex)
                      .replace("{MaxFlow}", MaxFlow)
                      .replace("{distance}", distance[sinkVertex]);
      cs["lineNo"] = [3];
      stateList.push(cs);

      var edgeBlueTemp = edgeBlue;
      var existAugmentingPath = true;
      while (existAugmentingPath) {
        existAugmentingPath = false;
        edgeBlue = edgeBlueTemp;
        var edgeYellow = {};
        var edgeRed = {};
        var parent = new Array(amountVertex);

        var DFSStack = [];
        DFSStack.push([sourceVertex,INF]);
        while (DFSStack.length > 0) {
          var now = DFSStack.pop(); //last most item
          var nowVertex = now[0];
          var nowCapacity = +now[1];
          if (nowVertex == sinkVertex) {
            while (nowVertex != sourceVertex) { 
              var backEdge = findEdgeIndex(nowVertex,parent[nowVertex]);
              var forwardEdge = findEdgeIndex(parent[nowVertex],nowVertex);

              delete edgeBlue[backEdge]; 
              delete edgeBlue[forwardEdge];

              if (iEL[forwardEdge]["w"] != nowCapacity) {
                edgeYellow[backEdge] = true;
                edgeYellow[forwardEdge] = true;
              }
              else {
                edgeRed[backEdge] = true;
                edgeRed[forwardEdge] = true;
              }

              nowVertex = parent[nowVertex];
            }
            cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
            cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                            .replace("{sourceVertex}", sourceVertex)
                            .replace("{sinkVertex}", sinkVertex)
                            .replace("{MaxFlow}", MaxFlow);
            cs["status"] += "<br>Found a blocking flow. Bottleneck is {bottleneck} (red edge)<br>".replace("{bottleneck}", nowCapacity);
            cs["lineNo"] = [4];
            stateList.push(cs);

            nowVertex = sinkVertex;
            while (nowVertex != sourceVertex) {            
              var backEdge = findEdgeIndex(nowVertex, parent[nowVertex]);
              var forwardEdge = findEdgeIndex(parent[nowVertex], nowVertex);

              iEL[forwardEdge]["w"] -= nowCapacity;
              iEL[backEdge]["w"] += nowCapacity;

              var bottleneck = false;

              if (edgeRed.hasOwnProperty(backEdge)) bottleneck = true;

              cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
              cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                            .replace("{sourceVertex}", sourceVertex)
                            .replace("{sinkVertex}", sinkVertex)
                            .replace("{MaxFlow}", MaxFlow);
              cs["status"] += "<br>Bottleneck is {bottleneck} (red edge). Updating edge from {parent} to {nowVertex} (blue edge)</br>"
                              .replace("{bottleneck}", nowCapacity)
                              .replace("{parent}", parent[nowVertex])
                              .replace("{nowVertex}", nowVertex);
              cs["lineNo"] = [5];

              nowVertex = parent[nowVertex];
              stateList.push(cs);
            }

            existAugmentingPath = true;
            existBlockingFlow = true;
            MaxFlow += nowCapacity;
            cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
            cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                            .replace("{sourceVertex}", sourceVertex)
                            .replace("{sinkVertex}", sinkVertex)
                            .replace("{MaxFlow}", MaxFlow);
            cs["status"] += "<br>Luồng cực đại tăng thêm đến {nowCapacity}<br>".replace("{nowCapacity}", nowCapacity);
            cs["lineNo"] = [6];
            stateList.push(cs);
            break;
          }
          for (i in iEL) {
            var vertexA = iEL[i]["u"];
            var vertexB = iEL[i]["v"];
            var capacity = iEL[i]["w"];
            if (nowVertex == vertexA && capacity > 0 && distance[vertexA]+1 == distance[vertexB]) {
              parent[vertexB] = vertexA;
              if (capacity < nowCapacity)
                DFSStack.push([vertexB,capacity]);
              else DFSStack.push([vertexB,nowCapacity]);
            }
          }
        }
      }
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue);
    cs["status"] = "Luồng cực đại từ {sourceVertex} đến {sinkVertex} là {MaxFlow}.<br>Không có thêm luồng nào từ đỉnh phát đến đỉnh thu."
                    .replace("{sourceVertex}", sourceVertex)
                    .replace("{sinkVertex}", sinkVertex)
                    .replace("{MaxFlow}", MaxFlow);
    cs["lineNo"] = [];
    stateList.push(cs);
    populatePseudocode(2);

    return MaxFlow;
  }

  this.countmincut = function(sourceVertex, sinkVertex, originalCap, mf) {
    var edgeRed = {};
    var vertexTraversed = {};
    var vertexHighlighted = {};
    var visited = new Array(amountVertex);
    var distance = new Array(amountVertex);
    for (i in iVL) {
      visited[i] = false;
      distance[i] = INF;
    }

    var BFSQueue = [];
    BFSQueue.push(sourceVertex);
    distance[sourceVertex] = 0;
    while (BFSQueue.length > 0) {
      var nowVertex = BFSQueue.shift();
      vertexTraversed[nowVertex] = true;
      if (nowVertex != sourceVertex)
        iVL[nowVertex]["extratext"] = "S";
      for (i in iEL) {
        var vertexA = iEL[i]["u"];
        var vertexB = iEL[i]["v"];
        var capacity = iEL[i]["w"];
        if (nowVertex == vertexA && distance[vertexB] == INF && capacity > 0) {
          distance[vertexB] = distance[vertexA] + 1;
          BFSQueue.push(vertexB);
        }
      }
    }

    for (i in iVL)
      if (!vertexTraversed[i]) { // in T-component
        vertexHighlighted[i] = true;
        if (i != sinkVertex)
          iVL[i]["extratext"] = "T";
      }

    for (j in iEL) {
      var vertexA = iEL[j]["u"];
      var vertexB = iEL[j]["v"];
      var capacity = iEL[j]["w"];
      if (vertexTraversed[vertexA] && vertexHighlighted[vertexB]) { // highlight edges that crosses S-component to T-component
        edgeRed[j] = true;
        edgeRed[findEdgeIndex(vertexB,vertexA)] = true;
      }
      // this part still confusing, take more time to think... use the uni-directional flow strategy, if both f(u, v) > 0 and f(v, u) > 0, they will cancel out eah other
      // if (originalCap[j] != 0) // not a new back flow
      //   iEL[j]["w"] = (originalCap[j]-iEL[j]["w"]) + "/" + originalCap[j]; // show the actual flow on this edge w.r.t original capacity of this edge
      // else
      //   iEL[j]["w"] = "N/A";
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeRed, vertexTraversed, {}, {});
    cs["status"] = "Maximum flow = Minimum Cut from {sourceVertex} to {sinkVertex} is {mf}.<br>Edge(s) that cross(es) the ST-cut is/are highlighted."
                    .replace("{sourceVertex}", sourceVertex)
                    .replace("{sinkVertex}", sinkVertex)
                    .replace("{mf}", mf);
    cs["lineNo"] = [];
    stateList.push(cs);
  }

  this.countmaxflow = function(algorithm, sourceVertex, sinkVertex) {
    stateList = [];

    // error checks
    if (amountVertex == 0) { // no graph
      $('#countmaxflow-err').html("Không có đồ thị nào cả. Trước tiên hãy chọn 1 đồ thị ví dụ.");
      return false;
    }

    if (sourceVertex >= amountVertex || sourceVertex < 0) { // source vertex not in range
      $('#countmaxflow-err').html("Đồ thì không có đỉnh phát.");
      return false;
    }

    if (sinkVertex >= amountVertex || sinkVertex < 0) { // sink vertex not in range
      $('#countmaxflow-err').html("Đồ thị không có đỉnh thu.");
      return false;
    }

    if (sourceVertex == sinkVertex) {
      $('#countmaxflow-err').html("Đỉnh phát và đỉnh thu trùng nhau.");
      return false;
    }

    for (i in iVL) {
      if (i >= amountVertex) delete iVL[i];
      iVL[i]["extratext"] = "";
    }

    iVL[sourceVertex]["extratext"] = "source";
    iVL[sinkVertex]["extratext"] = "sink";
    var cs = createState(iVL, iEL);
    cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                    .replace("{sourceVertex}", sourceVertex)
                    .replace("{sinkVertex}", sinkVertex)
                    .replace("{MaxFlow}", 0);
    cs["status"] += "<br>The original flow graph.";
    cs["lineNo"] = [1];
    stateList.push(cs);

    //creating residual graph (backedges for every edge)
    for (i in iEL) {
      var backEdge = new Object();
      backEdge["u"] = iEL[i]["v"];
      backEdge["v"] = iEL[i]["u"];
      backEdge["w"] = 0;
      // if backEdge is not on the iEL yet
      if (findEdgeIndex(backEdge["u"], backEdge["v"]) == -1) { // insert backEdge to iEL
        iEL[amountEdge] = (backEdge);
        amountEdge++;
      }
    }

    var originalCap = {};
    for (i in iEL) {
      if (i >= amountEdge) delete iEL[i];
      originalCap[i] = +iEL[i]["w"];
    }

    var cs = createState(iVL, iEL);
    cs["status"] = "Maximum flow from {sourceVertex} to {sinkVertex} is currently {MaxFlow}."
                    .replace("{sourceVertex}", sourceVertex)
                    .replace("{sinkVertex}", sinkVertex)
                    .replace("{MaxFlow}", 0);
    cs["status"] += "<br>Preparing residual graph.";
    cs["lineNo"] = [1];
    stateList.push(cs);

    // run the maxflow algorithm
    var mf = 0;
         if (algorithm == "fordfulkerson") mf = this.fordfulkerson(sourceVertex,sinkVertex);
    else if (algorithm == "edmondskarp")   mf = this.edmondskarp(sourceVertex,sinkVertex);
    else if (algorithm == "dinic")         mf = this.dinic(sourceVertex,sinkVertex);

    this.countmincut(sourceVertex, sinkVertex, originalCap, mf);

    gw.startAnimation(stateList);
    return true;
  }

  this.rookattack = function() {
    var numOfRows = parseInt($('#rows').val());
    var numOfColumns = parseInt($('#columns').val());
    var blocked = new Array(numOfRows);

    for (var i = 0; i < numOfRows; i++) {
      blocked[i] = new Array(numOfColumns);
      for (var j = 0; j < numOfColumns; j++)
        blocked[i][j] = false;
    }

    if (numOfRows < 1 || numOfColumns < 1 || numOfRows > 6 || numOfColumns > 6) { // no graph
      $('#modeling-err').html("Kích thước không thỏa mãn. Số hàng và số cột phải nằm trong khoảng từ 1 đến 6.");
      return false;
    }

    this.changeState = function(rowIndex,columnIndex) {
      var temp = '#cell' + rowIndex + columnIndex;
      if (blocked[rowIndex][columnIndex]) {
        $(temp).attr("bgcolor","white");
        blocked[rowIndex][columnIndex] = false;
      }
      else {
        $(temp).attr("bgcolor","black");
        blocked[rowIndex][columnIndex] = true;
      }
    }

    this.createBipartiteGraph = function() {
      iVL = {};
      iEL = {};
      vertexHighlighted = {};
      edgeRed = {};
      stateList = [];
      var cs;
      amountEdge = 0;
      amountVertex = 2 + numOfRows + numOfColumns;

      iVL[0] = {
        "x": 25,
        "y": 175,
      }

      iVL[amountVertex-1] = {
        "x": 625,
        "y": 175,
      }

      vertexHighlighted[0] = vertexHighlighted[amountVertex-1] = true;
      cs = createState(iVL, iEL,vertexHighlighted);
      cs["status"] = "Khởi tạo đỉnh phát và đỉnh thu.";
      cs["lineNo"] = [1];
      stateList.push(cs);
      delete vertexHighlighted[0]; delete vertexHighlighted[amountVertex-1];

      for (var i = 1; i <= numOfRows; i++) {
        iVL[i] = {
          "x": 225,
          "y": (175 + (i - (numOfRows+1)/2) * (numOfRows == 1 ? 0 : 300/(numOfRows-1))),
          "text": "R"+i
        }
        iEL[amountEdge] = {
          "u": 0,
          "v": i,
          "w": 1
        }
        amountEdge++;
        vertexHighlighted[i] = true;
      }

      cs = createState(iVL, iEL,vertexHighlighted);
      cs["status"] = "Tạo 1 đỉnh ứng với mỗi hàng và nối đỉnh phát với đỉnh đó với sức chứa 1.";
      cs["lineNo"] = [2];
      stateList.push(cs);
      for (var i = 1; i <= numOfRows; ++i)
        delete vertexHighlighted[i];

      for (var i = 1; i <= numOfColumns; ++i) {
        iVL[i+numOfRows] = {
          "x": 425,
          "y": (175 + (i-(numOfColumns+1)/2) * (numOfColumns == 1 ? 0 : 300/(numOfColumns-1))),
          "text": "C"+i
        }
        iEL[amountEdge] = {
          "u": i+numOfRows,
          "v": amountVertex-1,
          "w": 1
        }
        amountEdge++;
        vertexHighlighted[i+numOfRows] = true;
      }
      cs = createState(iVL, iEL,vertexHighlighted);
      cs["status"] = "Tạo 1 đỉnh ứng với mỗi cột và nối đỉnh đó với đỉnh thu với sức chứa 1.";
      cs["lineNo"] = [3];
      stateList.push(cs);
      for (var i = 1; i <= numOfColumns; i++)
        delete vertexHighlighted[i+numOfRows];

      for (var i = 0; i < numOfRows; i++) {
        for (var j = 0; j < numOfColumns; j++) {
          var existEdge = 1-blocked[i][j];
          if (existEdge == 1) {
            iEL[amountEdge] = {
              "u": i+1,
              "v": j+1+numOfRows,
              "w": 9
            }
            amountEdge++;
            edgeRed[amountEdge-1] = true;
            cs = createState(iVL, iEL,vertexHighlighted, edgeRed);
            cs["status"] = "Thêm cạnh từ R{row} đến C{column}."
                            .replace("{row}", i+1)
                            .replace("{column}", j+1);
            cs["lineNo"] = [4,5];
            stateList.push(cs);
            delete edgeRed[amountEdge-1];
          }
        }
      }

      amountVertex = 0;
      amountEdge = 0;
      for (var i in iVL) amountVertex++;
      for (var i in iEL) amountEdge++;

      $('#sourcevertex').val(0);
      $('#sinkvertex').val(amountVertex-1);

      cs = createState(iVL, iEL);
      cs["status"] = "Chạy bất kì 1 thuật toán tìm luồng cực đại nào từ đỉnh 0 đến đỉnh<span style="white-space: normal;">&nbsp;{lastVertex}</span><br>để tìm số quân xe lớn nhất có thể đặt được.".replace("{lastVertex}", amountVertex-1);
      cs["lineNo"] = [6];
      stateList.push(cs);
      gw.startAnimation(stateList);
      return true;
    }

    this.inputFinished = function() {
      $('.overlays').hide("slow");
      $('#dark-overlay').hide("slow");
      $('#rookattack-board').hide("slow");
      mfw.createBipartiteGraph();
      $('#current-action').show();
      $('#current-action p').html("Modeling()");
      $('#progress-bar').slider( "option", "max", gw.getTotalIteration()-1);
      triggerRightPanels();
      populatePseudocode(3);
      isPlaying = true;
      return true;
    }

    this.cancel = function() {
      $('.overlays').hide("slow");
      $('#dark-overlay').hide("slow");
      $('#rookattack-board').hide("slow");
      $('#progress-bar').slider( "option", "max", gw.getTotalIteration()-1);
      return true;
    }

    this.inputRandomized = function() {
      for (var i = 0; i < numOfRows; i++)
        for (var j = 0; j < numOfColumns; j++)
          if (Math.random() < 0.5) this.changeState(i,j);
    }

    $('#dark-overlay').show("slow");
    var toWrite = '<html>\n';
    toWrite += "<p>Click vào 1 ô bất kì để đổi màu đen/trắng</p>\n";
    toWrite += "<p>Các quân xe không thể đặt vào các ô đen.</p>\n";
    toWrite += '<table border="1" id="board">'
    for (var j = 0; j < numOfColumns; j++)
      toWrite += '<col width="50">';
    for (var i = 0; i < numOfRows; i++) {
      toWrite += '<tr>';
      for (var j = 0; j < numOfColumns; j++)
        toWrite += '<td height="50" bgcolor="white" id="cell' + i + j + '" onclick=mfw.changeState('+i+','+j+')></td>';
      toWrite += '</tr>';
    }

    toWrite += '</table>\n';
    toWrite += '<div class="modeling-actions">';
    toWrite += '<p onclick=mfw.inputRandomized()>Randomized</p>';
    toWrite += '<p onclick=mfw.inputFinished()>Done</p>';
    toWrite += '<p onclick=mfw.cancel()>Cancel</p>';
    toWrite += '</div>\n'
    toWrite += '</html>\n';
    $('#rookattack-board').html(toWrite);
    $('#rookattack-board').show("slow");
  }

  // this.baseball = function() {
  //   var numOfTeams = parseInt($('#teams').val());
  //   var numOfGames = new Array(numOfTeams);
  //   var initialPoints = new Array(numOfTeams);
  
  //   for (var i = 0; i < numOfTeams; ++i)
  //     numOfGames[i] = new Array(numOfTeams);

  //   if (numOfTeams < 1 || numOfTeams > 6) { // no graph
  //     $('#modeling-err').html("Invalid number of teams. Number of teams must be between 1 and 6 inclusive.");
  //     return false;
  //   }

  //   setInterval(function()
  //   {
  //     for (var i = 0; i < numOfTeams; ++i)
  //     {
  //       numOfGames[i][i] = 0;
  //       $("#game" + i + i).val(0);
  //       for (var j = 0; j < i; ++j)
  //       {
  //         $("#game" + i + j).val($("#game" + j + i).val());
  //       }
  //     }
  //   },100);

  //   this.inputRandomized = function()
  //   {
  //     for (var i = 0; i < numOfTeams; ++i)
  //     {
  //       initialPoints[i] = Math.floor(Math.random() * 10); //0 - 9
  //       $("#point" + i).val(initialPoints[i]);
  //       for (var j = 0; j < numOfTeams; ++j)
  //       {
  //         numOfGames[i][j] = Math.floor(Math.random() * 10); //0 - 9
  //         $("#game" + i + j).val(numOfGames[i][j]);
  //       }
  //     }
  //   }

  //   this.createGraph = function(checkTeamIndex)
  //   {
  //     iVL = {};
  //     iEL = {};
  //     vertexHighlighted = {};
  //     edgeRed = {};
  //     stateList = [];
  //     var cs;
  //     var numOfMatches = ((numOfTeams - 1) * (numOfTeams - 2)) / 2;
  //     var totalMaxFlow = 0;
  //     amountEdge = 0;
  //     amountVertex = 2 + numOfMatches + (numOfTeams - 1);
  //     var totalNumberOfGames = new Array(numOfTeams);
  //     var vertexIndex = new Array(numOfTeams);
  //     for (var i = 0; i < numOfTeams; ++i)
  //     {
  //       totalNumberOfGames[i] = 0;
  //       vertexIndex[i] = new Array(numOfTeams);
  //       initialPoints[i] = (+$("#point" + i).val());
  //       for (var j = 0; j < numOfTeams; ++j)
  //       {
  //         numOfGames[i][j] = +($("#game" + i + j).val());
  //         totalNumberOfGames[i] += (numOfGames[i][j]);
  //         console.log(i + " " + j + " " + numOfGames[i][j]);
  //       }
  //     }

  //     cs = createState(iVL, iEL,vertexHighlighted);
  //     cs["status"] = 'Assume Team ' + checkTeamIndex + ' wins all remaining games';
  //     cs["status"] += '<br>Team ' + checkTeamIndex + ' will win ' + initialPoints[checkTeamIndex] + ' + ' + totalNumberOfGames[checkTeamIndex];
  //     cs["status"] += ' = ' + (initialPoints[checkTeamIndex] + totalNumberOfGames[checkTeamIndex]) + ' games</br>';
  //     cs["lineNo"] = [1];
  //     stateList.push(cs);

  //     for (var i = 0; i < numOfTeams; ++i) if (i != checkTeamIndex)
  //     {
  //       cs = createState(iVL, iEL,vertexHighlighted);
  //       cs["status"] = 'Assume T' + i + ' loses all remaining games. ';
  //       cs["status"] += 'T' + i + ' will win ' + initialPoints[i] + ' games';
  //       if (initialPoints[i] <= initialPoints[checkTeamIndex] + totalNumberOfGames[checkTeamIndex])
  //       {
  //         cs["status"] += '<br>Because ' + initialPoints[i] + '<=' + (initialPoints[checkTeamIndex] + totalNumberOfGames[checkTeamIndex]) + ', team ' + checkTeamIndex + ' can still win the league</br>';
  //         cs["lineNo"] = [1];
  //         stateList.push(cs);     
  //       } else
  //       {
  //         cs["status"] += '<br>Because ' + initialPoints[i] + '>' + (initialPoints[checkTeamIndex] + totalNumberOfGames[checkTeamIndex]) + ', team ' + checkTeamIndex + ' is obviously eliminated</br>';
  //         cs["lineNo"] = [1];
  //         stateList.push(cs);
  //         gw.startAnimation(stateList);
  //         return true;
  //       }   
  //     }


  //     iVL[0] = {"cx": 25, "cy": 175, "text": 0}

  //     iVL[amountVertex - 1] = { "cx": 625, "cy": 175, "text": amountVertex - 1 }

  //     vertexHighlighted[0] = vertexHighlighted[amountVertex-1] = true;
  //     cs = createState(iVL, iEL,vertexHighlighted);
  //     cs["status"] = 'Create source and sink vertex';
  //     cs["lineNo"] = [];
  //     stateList.push(cs);
  //     delete vertexHighlighted[0]; delete vertexHighlighted[amountVertex-1];

  //     amountVertex = 1;


  //     //create left set of vertices
  //     for (var i = 0; i < numOfTeams; ++i) if(i != checkTeamIndex)
  //     {
  //       for (var j = i + 1; j < numOfTeams; ++j) if(j != checkTeamIndex)
  //       {
  //         totalMaxFlow += numOfGames[i][j];
  //         iVL[amountVertex] = 
  //         {
  //           "cx": 225,
  //           "cy": (175 + (amountVertex - (numOfMatches + 1) / 2) * (numOfMatches == 1 ? 0 : 300 / (numOfMatches - 1))),
  //           "text": i + "v" + j
  //         }
  //         iEL[amountEdge] = 
  //         {
  //           "vertexA": 0,
  //           "vertexB": amountVertex,
  //           "weight": numOfGames[i][j]
  //         }
  //         vertexHighlighted[amountVertex] = true;
  //         edgeRed[amountEdge] = true;
  //         cs = createState(iVL, iEL,vertexHighlighted, edgeRed);
  //         cs["status"] = 'Create a node for a match between T' + i + ' and T' + j + '. There are ' + numOfGames[i][j] + ' matches remaining';
  //         cs["status"] += '. Connect source vertex to that node with capacity ' + numOfGames[i][j];
  //         cs["lineNo"] = [2,3];
  //         stateList.push(cs);
  //         delete vertexHighlighted[amountVertex];
  //         delete edgeRed[amountEdge];

  //         vertexIndex[i][j] = amountVertex;
  //         ++amountVertex;
  //         ++amountEdge;
  //       }
  //     }

      

  //     //create right set of vertices
  //     for (var i = 0; i < numOfTeams; ++i) if (i != checkTeamIndex)
  //     {
  //       iVL[amountVertex] = 
  //       {
  //         "cx": 425,
  //         "cy": (175 + ((i+(i<checkTeamIndex?1:0)) - (numOfTeams) / 2) * (numOfTeams == 2 ? 0 : 300 / (numOfTeams - 2))),
  //         "text": "T" + i
  //       }
  //       var weight = (+initialPoints[checkTeamIndex]) + (+totalNumberOfGames[checkTeamIndex]) - (+initialPoints[i]);
  //       iEL[amountEdge] = 
  //       {
  //         "vertexA": amountVertex,
  //         "vertexB": 1 + numOfMatches + (numOfTeams - 1),
  //         "weight": weight
  //       }
  //       vertexHighlighted[amountVertex] = true;
  //       edgeRed[amountEdge] = true;
  //       cs = createState(iVL, iEL,vertexHighlighted, edgeRed);
  //       cs["status"] = 'Create a node for a Team ' + i + '. Team ' + i + ' may win ';
  //       cs["status"] += (initialPoints[checkTeamIndex] + totalNumberOfGames[checkTeamIndex]) + '-' + initialPoints[i] + ' = ' + weight + ' matches more';
  //       cs["status"] += '. Connect that node to sink vertex with capacity ' + weight;
  //       cs["lineNo"] = [4,5];
  //       stateList.push(cs);
  //       delete vertexHighlighted[amountVertex];
  //       delete edgeRed[amountEdge];

  //       ++amountVertex;
  //       ++amountEdge;
  //     }



  //     //create middle edges
  //     for (var i = 0; i < numOfTeams; ++i) if (i != checkTeamIndex)
  //     {
  //       for (var j = i + 1; j < numOfTeams; ++j) if (j != checkTeamIndex)
  //       {
  //         iEL[amountEdge] = 
  //         {
  //           "vertexA": vertexIndex[i][j],
  //           "vertexB": amountVertex - numOfTeams + i + (i < checkTeamIndex ? 1 : 0),
  //           "weight": 9
  //         }
  //         edgeRed[amountEdge] = true;
  //         ++amountEdge;

  //         iEL[amountEdge] = 
  //         {
  //           "vertexA": vertexIndex[i][j],
  //           "vertexB": amountVertex - numOfTeams + j + (j < checkTeamIndex ? 1 : 0),
  //           "weight": 9
  //         }
  //         edgeRed[amountEdge] = true;
  //         ++amountEdge;

  //         cs = createState(iVL, iEL,vertexHighlighted, edgeRed);
  //         cs["status"] = 'Adding edge from R' + i + ' to C' + j + ' with capacity INF';
  //         cs["lineNo"] = [6];
  //         //cs["status"] += '<br>Adding edge from R' + i + ' to C' + j + '</br>';
  //         stateList.push(cs);
  //         delete edgeRed[amountEdge-1];
  //         delete edgeRed[amountEdge-2];
  //       }
  //     }

  //     amountVertex = 0;
  //     amountEdge = 0;
  //     for (var i in iVL) ++amountVertex;
  //     for (var i in iEL) ++amountEdge;

  //     $('#sourcevertex').val(0);
  //     $('#sinkvertex').val(amountVertex-1);

  //     cs = createState(iVL, iEL);
  //     cs["status"] = 'Run any maximum flow algorithm from 0 to ' + (amountVertex - 1);
  //     cs["status"] += '. Iff all source edges are saturated (maxflow = ' + totalMaxFlow + '), '
  //     cs["status"] += 'then Team ' + checkTeamIndex + ' is not eliminated';
  //     cs["lineNo"] = [7];
  //     stateList.push(cs);
  //     gw.startAnimation(stateList);
  //     return true;
  //   }

  //   this.inputFinished = function(checkTeamIndex)
  //   {
  //     $('.overlays').hide("slow");
  //     $('#dark-overlay').hide("slow");
  //     $('#baseball-board').hide("slow");
  //     mfw.createGraph(checkTeamIndex);
  //     $('#current-action').show();
  //     $('#current-action p').html("Modeling()");
  //     $('#progress-bar').slider( "option", "max", gw.getTotalIteration()-1);
  //     triggerRightPanels();
  //     populatePseudocode(4);
  //     isPlaying = true;
  //     return true;
  //   }

  //   this.cancel = function()
  //   {
  //     $('.overlays').hide("slow");
  //     $('#dark-overlay').hide("slow");
  //     $('#rookattack-board').hide("slow");
  //     $('#progress-bar').slider( "option", "max", gw.getTotalIteration()-1);
  //     return true;
  //   }

  //   $('#dark-overlay').show("slow");
  //   var toWrite = '<html>\n';
  //   toWrite += '<p>Fill in the table below.\n';
  //   toWrite += ' Don\'t modify the black cells, they will be updated automatically</p>\n';
  //   toWrite += '<p>Click on any team to check whether the team is eliminated or not</p>\n';
  //   toWrite += '<table border="1" id="board">\n';
  //   for (var j = 0; j < numOfTeams + 2; ++j)
  //   {
  //     toWrite += '<col width="50">';
  //   }

  //   toWrite += '<tr>';
  //   toWrite += '<td rowspan="2">Team Index</td><td rowspan="2">Initial Points</td>';
  //   toWrite += '<td colspan="5" align="center">Remaining Games</td>';
  //   toWrite += '</tr>';
  //   toWrite += '<tr>';
  //   for (var i = 0; i < numOfTeams; ++i)
  //   {
  //     toWrite += '<td>Team ' + i + '</td>';
  //   }
  //   toWrite += '</tr>';

  //   for (var i = 0; i < numOfTeams; ++i)
  //   {
  //     toWrite += '<tr>';
  //     toWrite += '<td><div class="modeling-actions">';
  //     toWrite += '<p onclick=mfw.inputFinished('+i+')>Team ' + i + '</p>';
  //     toWrite += '</div></td>';
  //     toWrite += '<td height="50" bgcolor="white"><input id="point' + i + '" value=0 /></td>';
  //     for (var j = 0; j < numOfTeams; ++j) 
  //     {
  //       if (j > i)
  //       {
  //         toWrite += '<td height="50" bgcolor="white"><input id="game' + i + j + '" value=0 /></td>';
  //       }
  //       else 
  //       {
  //         toWrite += '<td height="50" bgcolor="black"><input style="background-color:black;color:white;" id="game' + i + j + '" value=0 /></td>';
  //       }
  //     }
  //     toWrite += '</tr>';
  //   }

  //   toWrite += '</table>\n';
  //   toWrite += '<div class="modeling-actions">';
  //   toWrite += '<p onclick=mfw.inputRandomized()>Randomized</p>';
  //   toWrite += '<p onclick=mfw.cancel()>Cancel</p>';
  //   toWrite += '</div>';
  //   toWrite += '</html>\n';
  //   $('#baseball-board').html(toWrite);
  //   $('#baseball-board').show("slow");
  // }

  this.modeling = function(modelingType) {
    iVL = {};
    iEL = {};
    if (modelingType == "rookattack") this.rookattack();
    if (modelingType == "baseball") this.baseball();
    return true;
  }

  this.examples = function(id) {
    iVL = getExampleGraph(id, VL);
    iEL = getExampleGraph(id, EL);
    amountVertex = 0;
    amountEdge = 0;
    for (var key in iVL) amountVertex++;
    for (var key in iEL) amountEdge++;

    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
    $('#sourcevertex').val(0);
    $('#sinkvertex').val(amountVertex-1);
    return true;
  }

  this.completelyRandom = function() {
    var templateNo = Math.floor(Math.random()*noOfExamples); //0-4
    iVL = $.extend(true, {}, TEMPLATES[templateNo][0]);
    iEL = $.extend(true, {}, TEMPLATES[templateNo][1]);
    amountVertex = TEMPLATES[templateNo][2];
    amountEdge = TEMPLATES[templateNo][3];

    //change edge weights
    var keys = Object.keys(iEL);
    var nVertices = Object.keys(iVL).length/2;
    var nEdges = keys.length/2;
    for(var i=0; i<nEdges; i++) {
      //var newWeight = Math.floor(Math.random()*100)-50; //-50-49
      var newWeight = Math.floor(Math.random()*10); //0 - 9
      iEL[keys[i]]["w"] = newWeight;
    }

    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
    return true;
  }

  this.bipartiteRandom = function(randomType) { 
    // 0: random
    // 1: left 1
    // 2: right 1
    // 3: all 1
    amountVertex = Math.floor(Math.random()*9) + 4; // 4 to 12
    var numL = Math.floor(Math.random()*(amountVertex-3)) + 1; // 1 to N-3
    if (numL > 6) numL = 6;
    var numR = amountVertex-2-numL;
    
    iVL = {};
    iEL = {};
    amountEdge = 0;

    iVL[0] = {
      "x": 50,
      "y": 175,
    }

    iVL[amountVertex-1] = {
      "x": 650,
      "y": 175,
    }

    for (var i = 1; i <= numL; i++) {
      iVL[i] = {
        "x": 250,
        "y": (175 + (i - (numL+1)/2) * (numL == 1 ? 0 : 300/(numL-1))),
      }
      iEL[amountEdge] = {
        "u": 0,
        "v": i,
        "w": 1
      }
      if (randomType == 0 || randomType == 2)
        iEL[amountEdge]["w"] = 1+Math.floor(Math.random()*9);
      amountEdge++;
    }

    for (var i = 1; i <= numR; i++) {
      iVL[i+numL] = {
        "x": 450,
        "y": (175 + (i - (numR+1)/2) * (numR == 1 ? 0 : 300/(numR-1))),
      }
      iEL[amountEdge] = {
        "u": i+numL,
        "v": amountVertex-1,
        "w": 1
      }
      if (randomType == 0 || randomType == 1)
        iEL[amountEdge]["w"] = 1+Math.floor(Math.random()*9);
      amountEdge++;
    }

    for (var i = 1; i <= numL; i++) {
      for (var j = 1; j <= numR; j++) {
        var existEdge = Math.floor(Math.random()*2);
        if (existEdge == 1) {
          iEL[amountEdge] = {
            "u": i,
            "v": j+numL,
            "w": 9
          }
          amountEdge++;
        }
      }
    }

    amountVertex = 0;
    amountEdge = 0;
    for (var i in iVL) amountVertex++;
    for (var i in iEL) amountEdge++;
    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);

    $('#sourcevertex').val(0);
    $('#sinkvertex').val(amountVertex-1);
    return true;
  }

  function createState(iVLObject, iELObject, vertexHighlighted, edgeRed, vertexTraversed, edgeYellow, edgeBlue, edgeGrey) {
    if (vertexHighlighted == null) vertexHighlighted = {};
    if (edgeRed == null) edgeRed = {};
    if (vertexTraversed == null) vertexTraversed = {};
    if (edgeYellow == null) edgeYellow = {};
    if (edgeBlue == null) edgeBlue = {};
    if (edgeGrey == null) edgeGrey = {};

    var key;
    var state = {
      "vl":{},
      "el":{}
    };

    for (key in iVLObject) {
      state["vl"][key] = {};
      state["vl"][key]["cx"] = iVLObject[key]["x"];
      state["vl"][key]["cy"] = iVLObject[key]["y"];
      if (iVLObject[key]["text"] == null)
        state["vl"][key]["text"] = +key;
      else
        state["vl"][key]["text"] = iVLObject[key]["text"];
      if (iVLObject[key]["state"] == OBJ_HIDDEN)
        state["vl"][key]["state"] = OBJ_HIDDEN;
      else
        state["vl"][key]["state"] = VERTEX_DEFAULT;
      state["vl"][key]["extratext"] = iVLObject[key]["extratext"];
    }

    for (key in iELObject) {
      state["el"][key] = {};
      state["el"][key]["vertexA"] = iELObject[key]["u"];
      state["el"][key]["vertexB"] = iELObject[key]["v"];
      state["el"][key]["type"] = EDGE_TYPE_DE;
      state["el"][key]["weight"] = iELObject[key]["w"];
      if (iELObject[key]["state"] == OBJ_HIDDEN)
        state["el"][key]["state"] = OBJ_HIDDEN;
      else
        state["el"][key]["state"] = EDGE_DEFAULT;
      state["el"][key]["displayWeight"] = true;
      state["el"][key]["animateHighlighted"] = false;
    }

    for (key in vertexHighlighted)
      state["vl"][key]["state"] = VERTEX_HIGHLIGHTED;

    for (key in edgeRed)
      state["el"][key]["state"] = EDGE_RED;

    for (key in vertexTraversed)
      state["vl"][key]["state"] = VERTEX_TRAVERSED;

    for (key in edgeYellow)
      state["el"][key]["state"] = EDGE_TRAVERSED;

    for (key in edgeBlue)
      state["el"][key]["state"] = EDGE_BLUE;

    for (key in edgeGrey)
      state["el"][key]["state"] = EDGE_GREY;

    return state;
  }
  
  function populatePseudocode(act) {
    switch (act) {
      case 0: // Edmonds Karp
        // $('#code1').html('initMaxFlow');
        // $('#code2').html('while there is an augmenting path');
        // $('#code3').html('&nbsp;&nbsp;find an augmenting path using BFS');
        // $('#code4').html('&nbsp;&nbsp;for each edge u->v in the path');
        // $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;decrease capacity u->v by bottleneck');
        // $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;increase capacity v->u by bottleneck');
        // $('#code7').html('&nbsp;&nbsp;increase maxflow by bottleneck');
        $('#code1').html('initMaxFlow');
        $('#code2').html('while there is an augmenting path');
        $('#code3').html('&nbsp;&nbsp;find an augmenting path using BFS');
        $('#code4').html('&nbsp;&nbsp;for each edge u-&gt;v in the path');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;decrease capacity u-&gt;v by bottleneck');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;increase capacity v-&gt;u by bottleneck');
        $('#code7').html('&nbsp;&nbsp;increase maxflow by bottleneck');
        break;
      case 1: // Ford Fulkerson
        // $('#code1').html('initMaxFlow');
        // $('#code2').html('while there is an augmenting path');
        // $('#code3').html('&nbsp;&nbsp;find an augmenting path using DFS');
        // $('#code4').html('&nbsp;&nbsp;for each edge u->v in the path');
        // $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;decrease capacity u->v by bottleneck');
        // $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;increase capacity v->u by bottleneck');
        // $('#code7').html('&nbsp;&nbsp;increase maxflow by bottleneck');
        $('#code1').html('initMaxFlow');
        $('#code2').html('while there is an augmenting path');
        $('#code3').html('&nbsp;&nbsp;find an augmenting path using DFS');
        $('#code4').html('&nbsp;&nbsp;for each edge u-&gt;v in the path');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;decrease capacity u-&gt;v by bottleneck');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;increase capacity v-&gt;u by bottleneck');
        $('#code7').html('&nbsp;&nbsp;increase maxflow by bottleneck');
        break;
      case 2: // Dinic
        // $('#code1').html('initMaxFlow');
        // $('#code2').html('while t is reachable from s in the residual graph');
        // $('#code3').html('&nbsp;&nbsp;find the level graph (BFS)');
        // $('#code4').html('&nbsp;&nbsp;for each blocking flow in the level graph (DFS)');
        // $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;update the capacity in the blocking flow');
        // $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;increase maxflow by bottleneck');
        // $('#code7').html('');
        $('#code1').html('initMaxFlow');
        $('#code2').html('while t is reachable from s in the residual graph');
        $('#code3').html('&nbsp;&nbsp;find the level graph (BFS)');
        $('#code4').html('&nbsp;&nbsp;for each blocking flow in the level graph (DFS)');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;update the capacity in the blocking flow');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;increase maxflow by bottleneck');
        $('#code7').html('');
        break;
      case 3: // Rook Attack Modeling
        // $('#code1').html('Create source and sink vertex');
        // $('#code2').html('Create one vertex Ri for each row i');
        // $('#code3').html('Create one vertex Cj for each column j');
        // $('#code4').html('For each rook-placable cell (i,j)');
        // $('#code5').html('&nbsp;&nbsp;Add an edge from Ri to Cj with capacity INF');
        // $('#code6').html('Run any maxflow algorithm');
        $('#code1').html('Create source and sink vertex');
        $('#code2').html('Create one vertex Ri for each row i');
        $('#code3').html('Create one vertex Cj for each column j');
        $('#code4').html('For each rook-placable cell (i,j)');
        $('#code5').html('&nbsp;&nbsp;Add an edge from Ri to Cj with capacity INF');
        $('#code6').html('Run any maxflow algorithm');
        $('#code7').html('');
        break;
      case 4: // Baseball Elimination Modeling
        // $('#code1').html('Checking for obvious cases');
        // $('#code2').html('For every team X,Y');
        // $('#code3').html('&nbsp;&nbsp;Create XvY vertex. Connect source to the vertex');
        // $('#code4').html('For every team X');
        // $('#code5').html('&nbsp;&nbsp;Create TX vertex. Connect the vertex to sink');
        // $('#code6').html('Connect XvY vertex to TX and TY with capacity INF');
        // $('#code7').html('Run any maxflow algorithm');
        $('#code1').html('Checking for obvious cases');
        $('#code2').html('For every team X,Y');
        $('#code3').html('&nbsp;&nbsp;Create XvY vertex. Connect source to the vertex');
        $('#code4').html('For every team X');
        $('#code5').html('&nbsp;&nbsp;Create TX vertex. Connect the vertex to sink');
        $('#code6').html('Connect XvY vertex to TX and TY with capacity INF');
        $('#code7').html('Run any maxflow algorithm');
        break;
    }
  }
}



// MaxFlow_action.js
var actionsWidth = 150;
var statusCodetraceWidth = 410;

var isModelingOpen = false, isExamplesOpen = false, isCountMaximumFlowOpen = false;

function openModeling() {
  //$(".modeling").css("bottom","150px");
  $('#rookattack-input').hide();
  $('#baseball-input').hide();
  $('#bipartite-input').hide();
  if (!isModelingOpen) {
    $('.modeling').fadeIn('fast');
    isModelingOpen = true;
  }
}

function closeModeling() {
  if (isModelingOpen) {
    $('.modeling').fadeOut('fast');
    $('#modeling-err').html("");
    isModelingOpen = false;
  }
}

function openExamples() {
  if (!isExamplesOpen) {
    $('.examples').fadeIn('fast');
    isExamplesOpen = true;
  }
}

function closeExamples() {
  if (isExamplesOpen) {
    $('.examples').fadeOut('fast');
    isExamplesOpen = false;
  }
}

function openCountMaximumFlow() {
  if (!isCountMaximumFlowOpen) {
    $('.countmaxflow').fadeIn('fast');
    $('#countmaxflow-go').show();
    $('#countmaxflow-algorithm').hide();
    isCountMaximumFlowOpen = true;
  }
}

function closeCountMaximumFlow() {
  if (isCountMaximumFlowOpen) {
    $('.countmaxflow').fadeOut('fast');
    $('#countmaxflow-err').html("");
    isCountMaximumFlowOpen = false;
  }
}

function hideEntireActionsPanel() {
  closeModeling();
  closeExamples();
  closeCountMaximumFlow();
  hideActionsPanel();
}



// local
var mfw, gw, randomGraphID = -1;

$(function() {
  write(false, false);
  $('#play').hide();
  mfw = new MaxFlow();
  gw = mfw.getGraphWidget();
  var options = [CP3_4_24, CP3_4_26_1, CP3_4_26_2, CP3_4_26_3, FORDFULKERSON_KILLER, DINIC_SHOWCASE];
  mfw.examples(options[Math.floor(Math.random()*6)]);
  randomGraphID = -1;

  var graphJSON = getQueryVariable("create");
  if (graphJSON.length > 0) {
    importjson(graphJSON);
    window.history.pushState("object or string", "Title", window.location.href.split('?')[0]);
  }

  $('#modeling').click(function() {
    openModeling();
    closeExamples();
    closeCountMaximumFlow();
  });

  $('#examples').click(function() {
    closeModeling();
    openExamples();
    closeCountMaximumFlow();
  });

  $('#countmaxflow').click(function() {
    closeModeling();
    closeExamples();
    openCountMaximumFlow();
  });
});

function importjson(text) {
  if (isPlaying) stop();
  if (mode == "exploration") {
    mfw.importjson(text);
    closeExamples();
    isPlaying = false;
  }
}

function drawGraph() {
  if (isPlaying) stop();
  if (mode == "exploration") {
    $('#dark-overlay').fadeIn(function() {
      $('#drawgraph').fadeIn();
    });
    mfw.startLoop();
    isPlaying = false;
  }
}
  
function drawDone() {
  if (!mfw.draw()) return false;
  mfw.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

function drawCancel() {
  mfw.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

function bipartiteRandom(randomType) {
  mfw.bipartiteRandom(randomType);
}

function createRandom() {
  if (isPlaying) stop();
  if (mode == "exploration") {
    var n = Math.floor(5 + Math.random()*6);
    $.ajax({
      url: PHP_DOMAIN + "/php/Graph.php?mode=" + MODE_GET_RANDOM_SUBMITTED_GRAPH + "&directed=" + 1 + "&connected=" + 1
    }).done(function(data){
      data = JSON.parse(data);
      var graph = extractQnGraph(data.graph);
      if (data.graphID == randomGraphID) // make sure it is different, make sure #graph > 1
        createRandom();
      randomGraphID = data.graphID;
      mfw.initRandom(graph);
      $('#rate-sample-graph').show();
    })
    $('#progress-bar').slider( "option", "max", 0);
    closeExamples();
    isPlaying = false;
  }
}

function modelingOpen(modelingType) {
  //$(".modeling").css("bottom","117px");
  if (modelingType != "rookattack") $('#rookattack-input').fadeOut('fast');
  if (modelingType != "baseball")   $('#baseball-input').fadeOut('fast');
  if (modelingType != "bipartite")  $('#bipartite-input').fadeOut('fast');
  $('#' + modelingType + '-input').fadeIn('fast');
}

function modeling(modelingType) {
  if (isPlaying) stop();
  setTimeout(function() {
    if (mode != "exploration") return;
    if (!mfw.modeling(modelingType)) return;
  }, 500);
}

function example(id) {
  if (isPlaying) stop();
  setTimeout(function() {
    if ((mode == "exploration") && mfw.examples(id)) {
      $('#progress-bar').slider( "option", "max", 0);
      closeExamples();
      closeCountMaximumFlow();
      isPlaying = false;
    }
  }, 500);
}

function countmaxflow(algorithm) {
  if (algorithm == 'GO') {
    $('#countmaxflow-go').hide();
    $('#countmaxflow-algorithm').fadeIn('fast');
    return;
  }
  if (isPlaying) stop();
  var source = parseInt($('#sourcevertex').val());
  var sink = parseInt($('#sinkvertex').val());
  setTimeout( function()  {
    if (mode != "exploration") return;
    if (!mfw.countmaxflow(algorithm,source,sink)) return;
    $('#current-action').show();
    if (algorithm == "edmondskarp")
      $('#current-action p').html("Edmonds Karp(" + source + "," + sink + ")");
    if (algorithm == "fordfulkerson")
      $('#current-action p').html("Ford Fulkerson(" + source + "," + sink + ")");
    if (algorithm == "dinic")
      $('#current-action p').html("Dinic(" + source + "," + sink + ")");
    $('#progress-bar').slider( "option", "max", gw.getTotalIteration()-1);
    triggerRightPanels();
    isPlaying = true;
  }, 500);
}
</script>
</body>

<!-- Mirrored from visualgo.net/vi/maxflow by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 26 Nov 2020 06:40:27 GMT -->
</html>
