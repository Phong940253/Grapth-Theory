<!DOCTYPE html>
<html lang="vi">

<!-- Mirrored from visualgo.net/vi/matching by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 26 Nov 2020 06:40:17 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="description" content="A Matching in a graph G = (V, E) is a subset M of E edges in G such that no two of which meet at a common vertex.Maximum Cardinality Matching (MCM) problem is a Graph Matching problem where we seek a matching M that contains the largest possible number of edges. A possible variant is Perfect Matching where all V vertices are matched, i.e. the cardinality of M is V/2.A Bipartite Graph is a graph whose vertices can be partitioned into two disjoint sets X and Y such that every edge can only connect a vertex in X to a vertex in Y.Maximum Cardinality Bipartite Matching (MCBM) problem is the MCM problem in a Bipartite Graph, which is a lot easier than MCM problem in a General Graph.">
<meta name="keywords" content="Graph Matching Bipartite MCBM Augment Path Hopcroft Karp Randomized Greedy Preprocessing">
 
<meta name="csrf-token" content="iVivZ7KRPe6XK7pbuGtOoEjljE1xyBVNhLKNFuF8">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/matching.png">
<title>VisuAlgo - Graph Matching (Maximum Cardinality Bipartite Matching/MCBM)</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common.css">
<link rel="stylesheet" href="../css/viz-1.0.1.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
      }
      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }
      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
    </style>
<style>
.execAction { padding: 5px 8px; }
.err { padding: 5px 0px; }
#actions-extras input {
  width: 35px;
  padding: 5px 8px 7px;
}

.draw { bottom: 146px; }
.modeling { bottom: 119px; }
.examples { bottom: 92px; }
.augpath { bottom: 65px; }

/*#rookattack-input input {
  width: 20px;
  padding: 8px;
  margin-right: 2px;
  float:left;
}
#rookattack-input p { padding: 5px 8px; float : left;}
#rookattack-go p { 
  padding: 8px 8px 7px; 
  float:right;
}*/
#rookattack-board {
  height: 500px;
  width: 600px;
  margin-left: -300px;
  margin-top: -200px;
}

/*#bipartite0, #bipartite1, #bipartite2, #bipartite3 {
  float: left;
  padding: 2px;
}

.modeling-actions {
  bottom: 300px;
  left: 200px;
  float: left;
}
  .modeling-actions p { padding: 5px 10px; cursor: pointer; }
  .modeling-actions p:hover { background: black; color: white;}
  .modeling-actions p:first-of-type { padding-top: 10px; }
  .modeling-actions p:last-of-type { padding-bottom: 10px; }
  .modeling-actions-hide {
    bottom: 60px;
    left: 0px;
    padding-left: 14px;
    padding-right: 15px;
  }
*/
  /*.greedyaug { bottom: 173px; }
    #greedyaug-err { padding: 8px 0px 7px }
  */

  /*.hopcroftkarp { bottom: 65px; }
    #hopcroftkarp-err { padding: 5px 8px; }
  */
</style>
<script>
      function changeURL() {
        var URL = window.location.href.split('https://visualgo.net/');
        var val = document.getElementById("Language").value;
        URL[3] = val;
        window.location.assign(URL.join('https://visualgo.net/'));
      }
    </script>
</head>
<body>
<div id="top-bar">
<a href="http://www.comp.nus.edu.sg/~stevenha"><span class="colour" style="border: 1px solid green; border-radius: 25px;">7</span></a>&nbsp;&nbsp;&nbsp;
<a id="home" href="https://visualgo.net/">Visu<span class="colour">Algo</span><span style="font-size: 40%">.net</span></a>
/
<select id="Language" onchange="changeURL()">
<option value="en">en</option>
<option value="zh">zh</option>
<option value="es">es</option>
<option value="pt">pt</option>
<option value="ru">ru</option>
<option value="id">id</option>
<option value="de">de</option>
<option value="bn">bn</option>
<option value="ja">ja</option>
<option value="ko">ko</option>
<option value="vi" selected>vi</option>
</select>
/matching
<span class="right-links" id="useraccount">Login</span>
<span id="title">
<a id='menu-unweighted-bipartite' class='selected-viz'>(Unweighted Bipartite) Graph Matching</a>
<a id='menu-unweighted-general'>(Unweighted General) Graph Matching</a>
</span>
<div id="mode-menu">
<div id='mode-button' title='exploration'>Chế độ thăm dò &#9663;</div>
<div id='other-modes'>
<a title='e-Lecture'>Chế độ Bài giảng trực tuyến</a>
</div>
</div>
</div>
<div id="dark-overlay"></div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id='speed-control'>Chậm<div id='speed-input'></div>Nhanh<br></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick=goToBeginning()><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick=stepBackward()><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick=pause()><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick=play()><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick=stepForward()><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick=goToEnd()><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id='viz'></div>
<div id='current-action' class='panel'></div>
<div id='e-lecture' class='panel'></div>
<div id="overlay" hidden></div>
<div id="dropdown-temp-holder" hidden></div>
<div id="electure-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>A <b>Matching</b> in a graph <b>G = (V, E)</b> is a subset <b>M</b> of <b>E</b> edges in <b>G</b> such that no two of which meet at a common vertex.</p><br><p><b>Maximum Cardinality Matching (MCM)</b> problem is a Graph Matching problem where we seek a matching <b>M</b> that contains the largest possible number of edges. A possible variant is <b>Perfect Matching</b> where all <b>V</b> vertices are matched, i.e. the cardinality of <b>M</b> is <b>V/2</b>.</p><br><p>A <b>Bipartite Graph</b> is a graph whose vertices can be partitioned into two disjoint sets <b>X</b> and <b>Y</b> such that every edge can only connect a vertex in <b>X</b> to a vertex in <b>Y</b>.</p><br><p><b>Maximum Cardinality Bipartite Matching (MCBM)</b> problem is the <b>MCM</b> problem in a Bipartite Graph, which is a lot easier than <b>MCM</b> problem in a General Graph.</p>
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
Please <a href="https://visualgo.net/login"><u>login</u></a> if you are a repeated visitor or <a href="https://visualgo.net/login"><u>register</u></a> for an (optional) free account first.</p>
<div id='electure-dropdown'>
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. Graph Matching</option>
<option value="1-1">&nbsp;&nbsp;&nbsp;1-1. Current Limitation: Unweighted Graphs</option>
<option value="1-2">&nbsp;&nbsp;&nbsp;1-2. Switching Modes</option>
<option value="2">2. Visualisation </option>
<option value="3">3. Input Graph</option>
<option value="4">4. MCBM Algorithms</option>
<option value="4-1">&nbsp;&nbsp;&nbsp;4-1. O(VE) Augmenting Path Algorithm</option>
<option value="4-2">&nbsp;&nbsp;&nbsp;4-2. Example C++ Code - Part 1</option>
<option value="4-3">&nbsp;&nbsp;&nbsp;4-3. Example C++ Code - Part 2</option>
<option value="4-4">&nbsp;&nbsp;&nbsp;4-4. O(&Sqrt;(V)E) Dinic&#39;s Max Flow Algorithm</option>
<option value="4-5">&nbsp;&nbsp;&nbsp;4-5. An Extreme Test Case</option>
<option value="4-6">&nbsp;&nbsp;&nbsp;4-6. O(&Sqrt;(V)E) Hopcroft Karp&#39;s Algorithm</option>
<option value="4-7">&nbsp;&nbsp;&nbsp;4-7. O(kE) Augmenting Path Algorithm++</option>
<option value="4-8">&nbsp;&nbsp;&nbsp;4-8. Another Hard Test Case</option>
<option value="5">5. MCM Algorithms</option>
<option value="5-1">&nbsp;&nbsp;&nbsp;5-1. O(V^3) Edmonds&#39;s Matching Algorithm</option>
<option value="5-2">&nbsp;&nbsp;&nbsp;5-2. O(V^3) Edmonds&#39;s Matching Algorithm++</option>
<option value="6">6. Extras</option>
<option value="6-1">&nbsp;&nbsp;&nbsp;6-1. Implementation</option>
<option value="99">99. Status Panel</option>
<option value="99-1">&nbsp;&nbsp;&nbsp;99-1. Codetrace Panel</option>
<option value="99-2">&nbsp;&nbsp;&nbsp;99-2. Media Control</option>
<option value="99-3">&nbsp;&nbsp;&nbsp;99-3. Return to &#39;Exploration Mode&#39;</option>
</select>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-next' data-nextid="1-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-1-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>This visualization is currently limited to unweighted graphs only. Thus, we currently do not support Graph Matching problem variants involving weighted graphs...</p>
<hr>
<p>Pro-tip: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b> to advance to the next slide, <b>[PageUp]</b> to go back to the previous slide, <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="1-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-1-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>To switch between the unweighted <b>MCBM</b> (default, as it is much more popular) and unweighted <b>MCM</b> mode, click the respective header.</p><br><p>Here is an example of <b>MCM</b> mode. In <b>MCM</b> mode, one can draw a <b>General</b>, not necessarily <b>Bipartite</b> graphs. However, the graphs are unweighted (all edges have uniform weight 1).</p><br><p>The available algorithms are different in the two modes.</p>
<hr>
<p>Another pro-tip: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2017). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="1-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2" class="electure-dialog" style="bottom:230px;left:50%;margin-left:-250px;width:500px;">
<p>You can view the visualisation here!</p><br><p>For <b>Bipartite Graph</b> visualization, we will re-layout the vertices of the graph so that the two disjoint sets are clearly visible as Left and Right sets. For <b>General Graph</b>, we do not relayout the vertices.</p><br><p>Initially, edges have <span style="color: grey;">grey</span> color. Matched edges will have <span style="background-color: white; color: black;">black</span> color. Free/Matched edges along an augmenting path will have <span style="color: orange;">Orange</span>/<span style="color: lightblue;">Light Blue</span> colors, respectively.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="1-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>There are three different sources for specifying an input graph:</p><ol><li><b>Draw Graph</b>: You can draw <strong>any</strong> undirected unweighted graph as the input graph (note that in <b>MCBM</b> mode, the drawn input graph will be relayout into a nice <b>Bipartite</b> graph layout during algorithm animation),</li><li><b>Modeling</b>: A lot of graph problems can be reduced into an <b>MCBM</b> problem. In this visualization, we have the modeling examples for the famous Rook Attack problem (currently disabled) and standard <b>MCBM</b> problem (also valid in <b>MCM</b> mode).</li><li><b>Examples</b>: You can select from the list of our example graphs to get you started. The list of examples are slightly different in the two <b>MCBM</b> vs <b>MCM</b> modes.</li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>There are several Max Cardinality Bipartite Matching (MCBM) algorithms in this visualization, plus one more in Max Flow visualization:</p><ol><li>O(<b>VE</b>) <b>Augmenting Path Algorithm</b> (without greedy pre-processing),</li><li>O(<b>&Sqrt;(V)E</b>) <b>Dinic&#39;s Max Flow Algorithm</b>, see <a href="maxflow.html" target="_blank"><u>Max Flow</u></a> visualization, select Modeling &rightarrow; Bipartite Matching &rightarrow; All 1, then use Dinic&#39;s algorithm.</li><li>O(<b>&Sqrt;(V)E</b>) <b>Hopcroft Karp&#39;s Algorithm</b>,</li><li>O(<b>kE</b>) <b>Augmenting Path Algorithm++</b> (with randomized greedy pre-processing),</li></ol><p>PS: Although possible, we will likely not use O(<b>V<sup>3</sup></b>) <b>Edmonds&#39;s Matching Algorithm</b> if the input is guaranteed to be a <b>Bipartite Graph</b>.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-1" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p><b>Augmenting Path</b> is a path that starts from a free (unmatched) vertex <b>u</b> in graph <b>G</b>, alternates through unmatched, match, ..., unmatched edges in <b>G</b>, until it ends at another free vertex <b>v</b>. If we flip the edge status along that augmenting path, we will increase the number of edges in the matching set <b>M</b> by 1 and eliminates this augmenting path.</p><br><p>In 1957, Claude Berge proposes the following <a href="https://en.wikipedia.org/wiki/Berge%27s_lemma" target="_blank"><u>lemma</u></a>: <i>A matching <b>M</b> in graph <b>G</b> is maximum iff there is no more augmenting path in G</i>.</p><br><p>The <b>Augmenting Path Algorithm</b> is a simple O(<b>V*(V+E)</b>) = O(<b>V<sup>2</sup> + VE</b>) = O(<b>VE</b>) implementation of that lemma (on Bipartite Graph): Find and then eliminate augmenting paths in Bipartite Graph <b>G</b>. Click <span class="slide-actions" onclick="doButtonAction110()">Augmenting Path Algorithm Demo</span> to visualize this algorithm on the currently displayed random Bipartite Graph.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-2" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<pre>vi match, vis; // global variables<br><br>int Aug(int L) { // return 1 if &exist; an augmenting path from L<br>  if (vis[L]) return 0; // return 0 otherwise<br>  vis[L] = 1;<br>  for (auto &v : AL[L]) {<br>    int R = v.first;<br>    if (match[R] == -1 || Aug(match[R])) {<br>      match[R] = L;<br>      return 1; // found 1 matching<br>  } }<br>  return 0; // no matching<br>}</pre>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-3" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<pre>// in int main(), build the bipartite graph<br>// use directed edges from left set (of size VLeft) to right set<br>  int MCBM = 0;<br>  match.assign(V, -1);<br>  for (int L = 0; L < VLeft; L++) {<br>    vis.assign(VLeft, 0);<br>    MCBM += Aug(L); // find augmenting path starting from L<br>  }<br>  printf("Found %d matchings&bsol;n", MCBM);</pre><p>You can also download ch4_09_mcbm.cpp/java from <a href="https://cpbook.net/code/ch4.zip" target="_blank"><u>Competitive Programming 3</u></a> companion website.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-4" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>The <b>MCBM</b> problem can be modeled as a Max Flow problem. Go to <a href="maxflow.html" target="_blank"><u>Max Flow</u></a> visualization page and see the flow graph modeling of MCBM problem (select Modeling &rightarrow; Bipartite Matching &rightarrow; all 1).</p><br><p>If we use one of the fastest Max Flow algorithm, i.e. Dinic&#39;s algorithm on this flow graph, we can find Max Flow = MCBM in O(<b>&Sqrt;(V)E</b>) time &mdash; analysis omitted for now. This allows us to solve MCBM problem with <b>V</b> &in; [1&thinsp;000..1&thinsp;500].</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-5" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>If we are given a <b>Complete</b> Bipartite Graph <b>K<sub>N/2,N/2</sub></b>, i.e.<br><b>V = N/2+N/2 = N</b> and <b>E = N/2&times;N/2 = N<sup>2</sup>/4 &approx; N<sup>2</sup></b>, then<br>the Augmenting Path Algorithm discussed earlier will run in O(<b>VE</b>) = O(<b>N&times;N<sup>2</sup></b>) = O(<b>N<sup>3</sup></b>).</p><br><p>This is only OK for <b>V</b> &in; [400..500].</p><br><p>Try executing the <b>standard</b> Augmenting Path Algorithm on this <span class="slide-actions" onclick="doButtonAction111()">Extreme Test Case</span>, which is an almost complete <b>K<sub>5,5</sub></b> Bipartite Graph.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-6">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-6" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>The key idea of Hopcroft Karp&#39;s (HK) Algorithm (invented in 1973) is identical to <a href="maxflow.html" target="_blank"><u>Dinic&#39;s Max Flow Algorithm</u></a> discussed earlier, i.e. prioritize shortest augmenting paths (in terms of number of edges used) first. That&#39;s it, augmenting paths with 1 edge are processed first before longer augmenting paths with 3 edges, 5 edges, 7 edges, etc (the length always increase by 2 due to the nature of augmenting path in a Bipartite Graph).</p><br><p>Hopcroft Karp&#39;s Algorithm has time complexity of O(<b>&Sqrt;(V)E</b>) &mdash; analysis omitted for now. This allows us to solve MCBM problem with <b>V</b> &in; [1&thinsp;000..1&thinsp;500].</p><br><p>Try HK Algorithm on the same <span class="slide-actions" onclick="doButtonAction112()">Extreme Test Case</span> earlier. You will notice that HK Algorithm can find the MCBM in a much faster time than the previous standard O(<b>VE</b>) Augmenting Path Algorithm.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-7">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-7" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>However, we can actually make the easy-to-code <b>Augmenting Path Algorithm</b> discussed earlier to avoid its worst case O(<b>VE</b>) behavior by doing O(<b>V+E</b>) randomized (to avoid adversary test case) greedy pre-processing <i>before</i> running the actual algorithm.</p><br><p>This O(<b>V+E</b>) additional pre-processing step is simple: For every vertex on the left set, match it with a randomly chosen unmatched neighbouring vertex on the right set. This way, we eliminates many trivial (one-edge) Augmenting Paths that consist of a free vertex <b>u</b>, an unmatched edge <b>(u, v)</b>, and a free vertex <b>v</b>.</p><br><p>Try Augmenting Path Algorithm++ on the same <span class="slide-actions" onclick="doButtonAction113()">Extreme Test Case</span> earlier. Notice that the pre-processing step already eliminates many trivial 1-edge augmenting paths, making the actual Augmenting Path Algorithm only need to do little amount of additional work.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-6">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-8">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-8" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>Quite often, on <b>randomly generated</b> Bipartite Graph, the randomized greedy pre-processing step has cleared most of the matchings.</p><br><p>However, we can construct test case like: <b>Examples: Randomized Greedy Processing Killer</b> to make randomization as ineffective as possible. For every group of 4 vertices, there are 2 matchings. Random greedy processing has 50% chance of making mistake per group. Try this <span class="slide-actions" onclick="doButtonAction114()">Hard Test Case</span> case to see for yourself.</p><br><p>The worst case time complexity is no longer O(<b>VE</b>) but now O(<b>kE</b>) where <b>k</b> is a small integer, much smaller than <b>V</b>, <b>k</b> can be as small as 0 and is at most <b>V/2</b>. In our <i>experiments</i>, we estimate <b>k</b> to be "about √(<b>V</b>)" too. This version of Augmenting Path Algorithm++ allows us to solve MCBM problem with <b>V</b> &in; [1&thinsp;000..1&thinsp;500] too.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-7">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>There are two Max Cardinality Matching (MCM) algorithms in this visualization:</p><ol><li>O(<b>V^3</b>) <b>Edmonds&#39;s Matching</b> algorithm (without greedy pre-processing),</li><li>O(<b>V^3</b>) <b>Edmonds&#39;s Matching</b> algorithm (with greedy pre-processing),</li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-8">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-1" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>In General Graph, we may have Odd-Length cycle. Augmenting Path is not well defined in such graph, hence we cannot directly implement Claude Berge&#39;s lemma like what we did with Bipartite Graph.</p><br><p>Jack Edmonds call a path that starts from a free vertex <b>u</b>, alternates between free, matched, ..., free edges, and returns to the <b>same</b> free vertex <b>u</b> as <b>Blossom</b>. This situation is only possible if we have Odd-Length cycle, i.e. non-Bipartite Graph. Edmonds then proposed Blossom shrinking/contraction and expansion algorithm to solve this issue, details verbally.</p><br><p>This algorithm can be implemented in O(<b>V^3</b>).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-2" class="electure-dialog" style="bottom:190px;left:60px;width:500px;">
<p>As with the <b>Augmenting Path Algorithm++</b> for the MCBM problem, we can also do randomized greedy pre-processing step to eliminate as many &#39;trivial matchings&#39; as possible upfront. This reduces the amount of work of <b>Edmonds&#39;s Matching Algorithm</b>, thus resulting in a faster time complexity &mdash; analysis TBA.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="6">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-6" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>We have not added visualizations for weighted variant of <b>MCBM</b> and <b>MCM</b> problems (future work).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="6-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-6-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>You are allowed to use/modify our implementation code for Augmenting Path Algorithm++:<br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mcbm.cpp" target="_blank"><u>mcbm.cpp</u></a><br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mcbm.java" target="_blank"><u>mcbm.java</u></a><br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mcbm.py" target="_blank"><u>mcbm.py</u></a><br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/mcbm.ml" target="_blank"><u>mcbm.ml</u></a><br></p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99" class="electure-dialog" style="right:150px;bottom:335px;width:500px;">
<p>As the action is being carried out, each step will be described in the status panel.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-1" class="electure-dialog" style="right:170px;bottom:275px;width:180px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-2" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-120px;width:260px;">
<p>Control the animation with the player controls! Keyboard shortcuts are:<br></p><div style="margin-top: 8px;"><strong>Spacebar:</strong> play/pause/replay</div><strong>Left/right arrows:</strong> step backward/step forward<br><strong>-/+:</strong> decrease/increase speed<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-3" class="electure-dialog" style="top:70px;right:60px;width:300px;">
<p>Return to &#39;Exploration Mode&#39; to start exploring!</p><br><p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99-2">Trước đó <u>PgUp</u></div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="actions" class="panel">
<p id="draw" onclick=drawGraph()>Vẽ đồ thị</p>
<p id="modeling">Modeling</p>
<p id="examples">Examples</p>
<p id="augpath" class="execAction">Augmenting Path</p>

</div>
<div id="actions-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide actions panel"></div>
<div id="actions-extras">
<div class="modeling action-menu-pullout">
<div id="rookattack" class="execAction new-menu-option coloured-menu-option" onclick="modelingOpen('rookattack')"><p>Rook Attack</p>
<div id="rookattack-input" class="new-menu-option">
<input type="text" id="rows" title="Enter the number of rows" autocomplete="off" value=5 />
<input type="text" id="columns" title="Enter the number of column" autocomplete="off" value=5 />
<div id="rookattack-go" class="execAction coloured-menu-option" onclick="modeling('rookattack')" title="Generate the board"><p>GO</p></div>
</div>
</div>
<div id="bipartite" class="execAction new-menu-option coloured-menu-option" onclick="bipartiteRandom(3)"><p>Generate Random Bipartite Graph</p></div>
<div id="modeling-err" class="err"></div>
</div>
<div class="examples action-menu-pullout">

<div id="example5" class="execAction new-menu-option coloured-menu-option unweighted-bipartite unweighted-general" onclick="example(INTERESTING_BIPARTITE)"><p>Undirected Max Flow Killer</p></div>
<div id="example6" class="execAction new-menu-option coloured-menu-option unweighted-general" onclick="example(HOUSE_OF_CARDS)"><p>House of Cards</p></div>
<div id="example7" class="execAction new-menu-option coloured-menu-option unweighted-general" onclick="example(CS4234_TUTORIAL_THREE)"><p>CS4234 Tutorial 3</p></div>
<div id="example8" class="execAction new-menu-option coloured-menu-option unweighted-general" onclick="example(FMOD)"><p>F-mod</p></div>
<div id="example9" class="execAction new-menu-option coloured-menu-option unweighted-bipartite unweighted-general" onclick="example(GREEDY_AUGMENTING_PATH_KILLER)"><p>Randomized Greedy Processing Killer</p></div>
<div id="example10" class="execAction new-menu-option coloured-menu-option unweighted-bipartite unweighted-general" onclick="example(K55)"><p>K5,5</p></div>
<div id="example11" class="execAction new-menu-option coloured-menu-option unweighted-bipartite unweighted-general" onclick="example(K55_ALMOST)"><p>K5,5 (Almost)</p></div>
</div>
<div class="augpath action-menu-pullout">
<div id="augpathnormal" class="execAction new-menu-option coloured-menu-option unweighted-bipartite" onclick="augmentingPath()"><p>Standard</p></div>
<div id="augpathgreedy" class="execAction new-menu-option coloured-menu-option unweighted-bipartite" onclick="greedyAug()"><p>With Randomized Greedy Preprocessing</p></div>
<div id="hopcroftkarp" class="execAction new-menu-option coloured-menu-option unweighted-bipartite" onclick="hopcroftKarp()"><p>Hopcroft Karp</p></div>
<div id="edmondsblossom" class="execAction new-menu-option coloured-menu-option unweighted-general" onclick="edmondsBlossomViz(false)"><p>Edmonds Blossom</p></div>
<div id="edmondsblossomplusgreedy" class="execAction new-menu-option coloured-menu-option unweighted-general" onclick="edmondsBlossomViz(true)"><p>Edmonds Blossom + Greedy</p></div>
<div id="augpath-err" class="err"></div>
</div>
</div>
<div id="drawgraph" class="overlays"></div>
<div id="rookattack-board" class="overlays"></div>
<div id="bottom-bar">
<a id="trigger-about">Về</a>
<a id="trigger-team">Nhóm</a>
<a id="trigger-terms">Điều khoản sử dụng</a>
</div>
<div id="about" class="overlays">
<h4>Về</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
VisuAlgo được lên ý tưởng vào năm 2011 bởi tiến sĩ Steven Halim như là một công cụ để giúp những sinh viên của ông ấy có thể hiểu rõ hơn về các cấu trúc dữ liệu và thuật toán, bằng cách cho phép họ tự học những nội dung cơ bản nhất với tiến độ phù hợp với riêng họ.<br>VisuAlgo chứa rất nhiều thuật toán nâng cao đã được thảo luận trong cuốn sách của Tiến sĩ Steven Halim (&#39;Competitive Programming&#39;, đồng tác giả với anh trai của ông ấy, tiến sĩ Felix Halim) và hơn thế nữa. Hiện tại, một số mô phỏng/hiệu ứng hoạt hình của các thuật toán nâng cao này chỉ có thể tìm thấy ở VisuAlgo.<div>Mặc dù được thiết kế đặc biệt cho những sinh viên đại học quốc gia Singapore (phải học rất nhiều môn học về cấu trúc dữ liệu và thuật toán - ví dụ: CS1010, CS1020, CS2010, CS2020, CS3230, and CS3230), như những người ủng hộ việc học trực tuyến, chúng tôi hi vọng rằng những người quan tâm tới cấu trúc dữ liệu và thuật toán trên toàn thế giới cũng có thể thấy những mô tả này là hữu dụng.<br>Ngay từ đầu, VisuAlgo không được thiết kế để làm việc tốt trên những màn hình cảm ứng nhỏ (ví dụ như smartphones) do việc mô phỏng các thuật toán phức tạp cần rất nhiều điểm ảnh và cử chỉ nhấp và kéo để tương tác. Độ phân giải màn ảnh nhỏ nhất cho trải nghiệm người dùng chấp nhận được là 1024x768 và chỉ có duy nhất trang đích là tương đối thân thiện với bản di động.</div><div>VisuAlgo là một dự án liên tục và nhiều mô phỏng phức tạp vẫn đang được phát triển.<br>Cải tiến thú vị nhất là tạo và duyệt câu hỏi tự động (hệ thống câu hỏi trực tuyến) cho phép sinh viên kiểm tra kiến thức cơ bản về các cấu trúc dữ liệu và thuật toán. Các câu hỏi được tạo ngẫu nhiên thông qua những quy luật và câu trả lời của sinh viên sẽ được chấm điểm tự động và ngay lập tức dựa trên việc nộp bài tới server chấm điểm của chúng tôi. Hệ thống câu hỏi trực tuyến này, khi mà nó được chấp nhận bởi nhiều giảng viên CS trên toàn thế giới, sẽ xóa bỏ mặt kĩ thuật các câu hỏi về cấu trúc dữ liệu và thuật toán cơ bản khỏi các kỳ thi khoa học máy tính điển hình tại rất nhiều trường đại học. Bằng cách đặt một tiêu chí chấm điểm nhỏ (nhưng khác 0) vào việc vượt qua các câu hỏi trực tuyến, giảng viên CS có thể làm tăng (một cách đáng kể) sự thành thạo của những sinh viên trên những câu hỏi cơ bản này khi họ một lượng vô số các câu hỏi thực tế cho sự luyện tập cái mà có thể được kiểm chứng ngay lập tức trước khi họ làm câu hỏi trực tuyến. Hiện tại, chế độ hướng dẫn bao gồm các câu hỏi cho 12 module mô phỏng. Chúng tôi sẽ sớm thêm vào 8 module mô phỏng còn lại để cho tất cả các module mô phỏng ở VisuAlgo đều có phần câu hỏi trực tuyến.<br>Một cải tiến hấp dẫn khác là việc quốc tế hóa các dự án nhánh của VisuAlgo. Chúng tôi muốn chuẩn bị cơ sở dữ liệu các thuật ngữ CS cho các văn bản tiếng Anh đã từng xuất hiện trên hệ thống VisuAlgo. Đây là một nhiệm vụ lớn và cần điện toán đám đông. Một khi hệ thống đã sẵn sàng, chúng tôi sẽ mời người dùng VisuAlgo đóng góp, đặc biệt là khi bạn không phải là người nói tiếng Anh bản ngữ. Hiện tại, chúng tôi cũng đang viết những ghi chú về VisuAlgo bằng những ngôn ngữ khác nhau.<br></div>
<a href="https://weibo.com/p/230418436e9ee80102v4rk" target='_blank'><u>zh</u></a>, <a href='https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689' target='_blank'><u>id</u></a>, <a href="https://blog.naver.com/visualgo_nus" target='_blank'><u>kr</u></a>, <a href='https://www.facebook.com/groups/163215593699283/permalink/824003417620494/' target='_blank'><u>vn</u></a>, <a href='http://pantip.com/topic/32736343' target='_blank'><u>th</u></a>.</p>
</div>
</div>
<div id="team" class="overlays">
<h4>Nhóm</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
<p>
<strong><span style='line-height: 150%;'>Trưởng dự án và cố vấn (từ tháng 7/2011 đến nay)</span></strong><br>
<a href='http://www.comp.nus.edu.sg/~stevenha/' target='_blank'>Dr Steven Halim</a>, Senior Lecturer, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href='http://felix-halim.net/' target='_blank'>Dr Felix Halim</a>, Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style='line-height: 150%;'>Những nhà nghiên cứu sinh viên 1 (Jul 2011-Apr 2012)</span></strong><br>
Koh Zi Chun, <a href='http://roticv.rantx.com/' target='_blank'>Victor Loh Bo Huai</a>
 </p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 1 (Jul 2012-Dec 2013)</span></strong><br>
Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 2 (Jun 2013-Apr 2014)</span></strong><br>
<a href='http://www.rosemarietan.com/' target='_blank'>Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style='line-height: 150%;'>Những nhà nghiên cứu sinh viên 2 (May 2014-Jul 2014)</span></strong><br>
Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 3 (Jun 2014-Apr 2015)</span></strong><br>
Erin Teo Yi Ling, Wang Zi
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 4 (Jun 2016-Dec 2017)</span></strong><br>
Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir
</p>
<p>
List of translators who have contributed &ge;100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style='line-height: 150%;'>Lời cảm ơn</span></strong><br>
This project is made possible by the generous <a href="http://www.cdtl.nus.edu.sg/teg/" target="_blank">Teaching Enhancement Grant</a> from NUS Centre for Development of Teaching and Learning (CDTL).
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Điều khoản sử dụng</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
VisuAlgo miễn phí đối với cộng đồng Khoa học Máy tính trên toàn thế giới. Nếu bạn yêu thích VisuAlgo, khoản chi phí duy nhất mà chúng tôi muốn bạn chi trả chính là hãy nói cho những <b>sinh viên/ giảng viên ngành khoa học máy tính</b> mà bạn biết<b> về sự tồn tại của VisuAlgo</b> =) thông qua Facebook, Twitter, trang web về khóa học, blog review, email , v.v &amp; v.v. Nếu bạn là một<b> sinh viên/ giảng viên</b> ngành cấu trúc dữ liệu và thuật toán, bạn được phép sử dụng website này một cách trực tiếp trong các lớp học của bạn. Nếu bạn lấy những ảnh chụp màn hình (videos) từ website này, bạn có thể sử dụng chúng ở bất kỳ đâu, miễn là có dẫn nguồn URL của website này (http://visualgo.net) và/hoặc liệt kê các công bố ở dưới như là tài liệu tham khảo. Tuy nhiên, bạn <b>KHÔNG</b> được phép tải xuống các tập tin VisuAlgo (phía máy trạm) và lưu trữ nó ở website riêng của bạn vì nó được coi là <b>đạo ý tưởng</b> .Hiện tại, chúng tôi <b>KHÔNG</b> cho phép những người khác chia nhỏ dự án này và tạo ra những phiên bản khác của VisuAlgo. Việc sử dụng bản sao ngoại tuyến của VisuAlgo (phía máy trạm) cho mục đích cá nhân của bạn thì có thể chấp nhận được.<br>Lưu ý rằng hệ thống câu hỏi trực tuyến của VisuAlgo có phần dữ liệu phía máy chủ rất lớn và không dễ dàng để lưu lại mã kịch bản phía máy chủ và cơ sở dữ liệu một cách cục bộ. Hiện tại, mọi người chỉ có thể sử dụng "chế độ đào tạo" để truy cập hệ thống câu hỏi trực tuyến này. Chế độ kiểm tra hiện là môi trường có kiểm soát hơn cho việc sử dụng những câu hỏi được tạo ngẫu nhiên này và tự động kiểm duyệt cho kỳ thi <b>thật sự</b> tại Đại học Quốc gia Singapore<span style="white-space: normal;">.</span> Những giảng viên quan tâm tới khoa học máy tính có thể liên hệ với Steven nếu muốn trải nghiệm "chế độ kiểm tra"<br><b>Danh sách phát hành</b><br>Dự án này đươc trình bày một cách vắn tắt ở Hội thảo CLI tại ACM ICPC World Finals 2012 (Warsaw, Ba Lan) và tại Hội nghị IOI 2012 (Sirmione-Montichiari, Italy). Bạn có thể nhấn vào link này để đọc bài viết năm 2012 của chúng tôi về hệ thống này (nó không được gọi là VisuAlgo vào năm 2012)<br>Dự án này được hoàn thiện hầu hết bởi những cựu sinh viên của tôi. Báo cáo cuối cùng gần đây nhất là của: <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/erin-report.pdf" target="_blank">Erin</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/wangzi-report.pdf" target="_blank">Wang Zi</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/rose-report.pdf" target="_blank">Rose</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/ivan-report.pdf" target="_blank">Ivan</a>.<br><b>Báo cáo lỗi hoặc đề xuất tính năng mới</b><br>VisuAlgo là một dự án chưa hoàn thiện. Tiến sĩ Steven Halim vẫn đang tiếp tục phát triển VisuAlgo một cách tích cực/ Nếu bạn đang sử dụng VisuAlgo và phát hiện ra lỗi ở bất kỳ trang mô phỏng/ công cụ câu hỏi trực tuyến nào của chúng tôi hoặc nếu bạn muốn đề xuất những tính năng mới, hãy liên lạc với Tiến sĩ Steven Halim. Địa chỉ liên lạc của ông ấy là stevenhalim@gmail.com<br>
</div>
</div>

<script src="../js/jquery-3.3.1.min.js"></script>
<script>
      var PHP_DOMAIN = "";

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        //setTimeout(function() {
          if (retval) { // mode == "exploration" && // now not only for exploration mode, but check if this opens other problems
            $('#current-action').show();
            $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
            $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
            triggerRightPanels();
            isPlaying = true;
          }
        //}, 500);
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; i++) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.right-links').css('background', surpriseColour);
        $('#login-go').css('background', surpriseColour);

        $('.colour').css("color", surpriseColour); // name
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
          // temporary quick fix for Google Chrome Aug 2016 issue...
          setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 100); // force resize/redraw...
          setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        });

        // overlays stuffs
        $('#trigger-about').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#about').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('#trigger-team').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#team').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('#trigger-terms').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#termsofuse').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('.close-overlay').click(function() {
          $('.overlays').fadeOut(function() {
            $('#dark-overlay').fadeOut();
          });
        });

        $('#dark-overlay').click(function() {
          $('.overlays').fadeOut();
          $('#dark-overlay').fadeOut();
        });

        $.get('/isloggedin', function(data) {
          var isLoggedIn = data['isloggedin'] == '1';
          var element;
          if (isLoggedIn) {
            // element = '<a onclick="verifyLogout()">Đăng Xuất<div><br></div></a>';
            element = '<a href="https://visualgo.net/profile">Profile</a>'; 
          }
          else {
            element = '<a href="https://visualgo.net/login">Đăng nhập</a>'
          }
          $('#useraccount').html(element);
        });
      });

      function verifyLogout() {
        // Steven's remarks: use a better 'confirm' than the default :(
        var doesLogout = confirm('Are you sure to logout?');
        if (doesLogout == true) {
          window.location = "https://visualgo.net/logout";
        }
      }

      function checkLogin() {
        $.get('/checklogin', function(data) {
          var url = data['url'];
          window.location.href = '/' + url;
        });
      }

      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','../../www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-1566631-4', 'auto');
      ga('send', 'pageview');
    </script>

<script src="../js/jquery-ui.min.js"></script>

<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.3.js"></script>
<script src="../js/visualgo_print.js"></script>
<script src="../js/graph_library.js"></script>
<script>
      function runSlide(slide) {
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 4 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '1-1') {
          $("#e-lecture").html("slide " + slide + " (" + 8 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '1-2') {
          $("#e-lecture").html("slide " + slide + " (" + 13 + "%)");
          $("#menu-unweighted-general").click();
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 17 + "%)");
          $("#menu-unweighted-bipartite").click();
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 21 + "%)");
          $("#modeling").addClass("menu-highlighted");
$("#random").addClass("menu-highlighted");
closeAugPath();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 26 + "%)");
          $("#menu-unweighted-bipartite").click();
$("#augpath").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-1') {
          $("#e-lecture").html("slide " + slide + " (" + 30 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-2') {
          $("#e-lecture").html("slide " + slide + " (" + 34 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-3') {
          $("#e-lecture").html("slide " + slide + " (" + 39 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-4') {
          $("#e-lecture").html("slide " + slide + " (" + 43 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-5') {
          $("#e-lecture").html("slide " + slide + " (" + 47 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example(K55_ALMOST);

          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-6') {
          $("#e-lecture").html("slide " + slide + " (" + 52 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example(K55_ALMOST);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-7') {
          $("#e-lecture").html("slide " + slide + " (" + 56 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
example(K55_ALMOST);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-8') {
          $("#e-lecture").html("slide " + slide + " (" + 60 + "%)");
          $("#menu-unweighted-bipartite").click();
$("#augpath").click().addClass("menu-highlighted");
example(GREEDY_AUGMENTING_PATH_KILLER);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5') {
          $("#e-lecture").html("slide " + slide + " (" + 65 + "%)");
          $("#menu-unweighted-general").click();
$("#augpath").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-1') {
          $("#e-lecture").html("slide " + slide + " (" + 69 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-2') {
          $("#e-lecture").html("slide " + slide + " (" + 73 + "%)");
          $("#augpath").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6') {
          $("#e-lecture").html("slide " + slide + " (" + 78 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6-1') {
          $("#e-lecture").html("slide " + slide + " (" + 82 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99') {
          $("#e-lecture").html("slide " + slide + " (" + 86 + "%)");
          
          hideEntireActionsPanel();
 
          showStatusPanel();
          showCodetracePanel();
      
        }
        if (slide == '99-1') {
          $("#e-lecture").html("slide " + slide + " (" + 91 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99-2') {
          $("#e-lecture").html("slide " + slide + " (" + 95 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99-3') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };

      function pushState(slideValue) {
        var url = '/vi/matching';
        if (typeof slideValue != 'undefined' && slideValue != null) url += '?slide=' + slideValue;
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5); 
        $('#overlay').show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      $(function() {
        var slide = getUrlParameter('slide');
        
        $.get('/hasvisited' + '/matching', function(data) {
          var hasVisited = data['hasvisited'] == '1';
          if (!hasVisited) {
            var postData = {
              '_token': 'iVivZ7KRPe6XK7pbuGtOoEjljE1xyBVNhLKNFuF8',
              'page': '/matching'.substring(1),
            };

            $.post("/visitpage", postData, function(data) {
              // non critical request...
            });

            if (typeof slide != undefined && slide != null) {
              cur_slide = slide;
            }

            $("#mode-menu a").trigger("click");
          }
          else {
            if (typeof slide != undefined && slide != null) {
              cur_slide = slide;
              $('#mode-menu a').click();
            }    
          }
        }).fail(function() {
          if (typeof slide != undefined && slide != null) {
            cur_slide = slide;
            $('#mode-menu a').click();
          }
        });

        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
      
        $('#electure-1-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-2');
          pushState('1-2');
        });
        $('#electure-1-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
      
        $('#electure-1-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-1-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
      
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-2');
          pushState('1-2');
        });
      
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
      
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
      
        $('#electure-4-1 .electure-next').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
      
        $('#electure-4-2 .electure-next').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
        $('#electure-4-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
      
        $('#electure-4-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
        $('#electure-4-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
      
        $('#electure-4-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
        $('#electure-4-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
      
        $('#electure-4-5 .electure-next').click(function() {
          hidePopup();
          runSlide('4-6');
          pushState('4-6');
        });
        $('#electure-4-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
      
        $('#electure-4-6 .electure-next').click(function() {
          hidePopup();
          runSlide('4-7');
          pushState('4-7');
        });
        $('#electure-4-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
      
        $('#electure-4-7 .electure-next').click(function() {
          hidePopup();
          runSlide('4-8');
          pushState('4-8');
        });
        $('#electure-4-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-6');
          pushState('4-6');
        });
      
        $('#electure-4-8 .electure-next').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-4-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-7');
          pushState('4-7');
        });
      
        $('#electure-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
        $('#electure-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-8');
          pushState('4-8');
        });
      
        $('#electure-5-1 .electure-next').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
        $('#electure-5-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
      
        $('#electure-5-2 .electure-next').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-5-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
      
        $('#electure-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
      
        $('#electure-6-1 .electure-next').click(function() {
          hidePopup();
          runSlide('99');
          pushState('99');
        });
        $('#electure-6-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
      
        $('#electure-99 .electure-next').click(function() {
          hidePopup();
          runSlide('99-1');
          pushState('99-1');
        });
        $('#electure-99 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
      
        $('#electure-99-1 .electure-next').click(function() {
          hidePopup();
          runSlide('99-2');
          pushState('99-2');
        });
        $('#electure-99-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('99');
          pushState('99');
        });
      
        $('#electure-99-2 .electure-next').click(function() {
          hidePopup();
          runSlide('99-3');
          pushState('99-3');
        });
        $('#electure-99-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('99-1');
          pushState('99-1');
        });
      
        $('#electure-99-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('99-2');
          pushState('99-2');
        });
      
 

        // temporary quick fix for Google Chrome Aug 2016 issue..., put at last part so that everything else has been loaded
        // setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 500);
        // setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        // I turn it off on 14 June 2018, seems 'ok'?
      });

      function doButtonAction110() {
        CUSTOM_ACTION('augmentingpath');
      }
      function doButtonAction111() {
        example(K55_ALMOST);
CUSTOM_ACTION('augmentingpath');
      }
      function doButtonAction112() {
        example(K55_ALMOST);
CUSTOM_ACTION('hopcroftkarp');
      }
      function doButtonAction113() {
        example(K55_ALMOST);
CUSTOM_ACTION('greedyaug');
      }
      function doButtonAction114() {
        example(GREEDY_AUGMENTING_PATH_KILLER);
CUSTOM_ACTION('greedyaug');
      }

      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();  
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url.html) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}
    </script>
<script src="../js/manifest.js"></script>
<script src="../js/vendor.js"></script>
<script src="../js/matching_algos.js"></script>
<script>
// Matching Widget
// original author (various, but all partials): Peter Phandi, Mohan Jishnu, Jonathan Irvin Gunawan, Steven Halim

var MCBM_EXAMPLE_CP3_4_44 = 0;
var MCBM_EXAMPLE_CP3_4_42 = 1;
var MCBM_EXAMPLE_CP3_4_43 = 2;
var COMPLETE_GRAPH = 3;

var MCBM = function() {
  var gw = new GraphWidget();

  var valueRange = [1,100];

  var iVL = {};
  var iEL = {};
  var amountVertex = 0;
  var amountEdge = 0;
  var amountLeftSet = 0;
  var sourceVertex = 0;  

  this.getGraphWidget = function() { return gw; }

  this.refreshView = function() {
    // fixJSON();
    var newState = createState({iVL: iVL, iEL: iEL});
    gw.updateGraph(newState, 500);
  }

  fixJSON = function() {
    amountVertex = 0;
    amountEdge = 0;
    for (var key in iVL) amountVertex++;
    for (var key in iEL) amountEdge++;
    
    // for (var key in iEL) {
    //   delete iEL[key]["type"];
    //   delete iEL[key]["displayWeight"];
    //   if (iEL[key]["vertexA"] > iEL[key]["vertexB"]) {
    //     var temp = iEL[key]["vertexA"];
    //     iEL[key]["vertexA"] = iEL[key]["vertexB"];
    //     iEL[key]["vertexB"] = temp;
    //   }
    // }

    // for (var key in iVL) {
    //   iVL[key]["text"] = +key;
    //   delete iVL[key]["state"];
    // }
  }
  
  takeJSON = function(graph) {
    if (graph == null) return;
    graph = JSON.parse(graph);
    amountVertex = $.map(graph["vl"], function(n, i) { return i; }).length;
    amountEdge = $.map(graph["el"], function(n, i) { return i; }).length;
    iVL = graph["vl"];
    iEL = graph["el"];
    amountLeftSet = graph.amountLeftSet;
    fixJSON();
  }

  var whichSide = new Array;
  var bipartite;

  bipartiteChecking = function(now) {
    for (var i in iEL) {
      if (iEL[i]["vertexA"] == now) {
        if (whichSide[iEL[i]["vertexB"]] == -1) {
          whichSide[iEL[i]["vertexB"]] = 1 - whichSide[iEL[i]["vertexA"]];
          bipartiteChecking(iEL[i]["vertexB"]);
        }
        else if (whichSide[iEL[i]["vertexB"]] == whichSide[iEL[i]["vertexA"]])
          bipartite = false;
      }
      else if (iEL[i]["vertexB"] == now) {
        if (whichSide[iEL[i]["vertexA"]] == -1) {
          whichSide[iEL[i]["vertexA"]] = 1 - whichSide[iEL[i]["vertexB"]];
          bipartiteChecking(iEL[i]["vertexA"]);
        }
        else if (whichSide[iEL[i]["vertexA"]] == whichSide[iEL[i]["vertexB"]])
          bipartite = false;
      }
    }
  }

  statusChecking = function() {
    if (amountVertex == 0)
      $("#draw-status p").html("Graph is empty");
    else {
      if ($("#draw-err p").html() == "No Error") {
        if ((selectedState & BIPARTITE_MATCHING) > 0) {
          for (var border = 0; border < amountVertex-1; border++) { // check whether left side = [0, border]
            var okay = true;
            for (var i = 0; i <= border; i++)
              for (var j = 0; j <= border; j++)
                for (var k in iEL)
                  if (iEL[k]["u"] == i && iEL[k]["v"] == j)
                    okay = false;

            for (var i = border+1; i < amountVertex; i++)
              for (var j = border+1; j < amountVertex; j++)
                for (var k in iEL)
                  if (iEL[k]["u"] == i && iEL[k]["v"] == j)
                    okay = false;

            if (okay) {
              $("#draw-status p").html(
                "Left side vertices = [0,{left}]. Right side vertices = [{right},{last}]"
                  .replace("{left}", border)
                  .replace("{right}", border+1)
                  .replace("{last}", amountVertex-1)
              );
              amountLeftSet = border + 1;
              return;
            }
          }
        }
      }
      else $("#draw-status p").html("");
    }
  }

  warnChecking = function() {
    var warn = "";
    if (amountVertex >= 10)
      warn += "Too much vertex on screen, consider drawing smaller graph. ";

    if (warn == "") $("#draw-warn p").html("No Warning");
    else $("#draw-warn p").html(warn);
  }

  errorChecking = function() {
    var error = "";
    if (amountVertex < 2) {
      $("#draw-err p").html("There must be at least 2 vertices. ");
      return;
    }
    
    if ((selectedState & BIPARTITE_MATCHING) > 0) {
      for (var i = 0; i < amountVertex; i++) whichSide[i] = -1;
      bipartite = true;
      for (var i = 0; i < amountVertex; i++) {
        if (whichSide[i] == -1) {
          whichSide[i] = i%2;
          bipartiteChecking(i);
        }
      }

      if (!bipartite) 
        error += "Graph is not bipartite. Currently Graph Matching only supports Bipartite Graph. :( ";
      
      var separatable = false;
      for (var border = 0; border < amountVertex-1; border++) { // check whether left side = [0,border]
        var okay = true;
        for (var i = 0; i <= border; i++)
          for (var j = 0; j <= border; j++)
            for (var k in iEL)
              if (iEL[k]["u"] == i && iEL[k]["v"] == j)
                okay = false;

        for (var i = border+1; i < amountVertex; i++)
          for (var j = border+1; j < amountVertex; j++)
            for (var k in iEL)
              if (iEL[k]["u"] == i && iEL[k]["v"] == j)
                okay = false;

        if (okay) 
          separatable = true;
      }

      if (bipartite && !separatable)
        error += "There is no X such that the left vertices are numbered [0,X] and the right vertices are numbered (X,|V|) ";
    }

    if (error == "") $("#draw-err p").html("No Error");
    else $("#draw-err p").html(error);
  }
  
  var intervalID;

  this.startLoop = function() {
    intervalID = setInterval(function() {
      takeJSON(JSONresult);
      warnChecking();
      errorChecking();
      statusChecking();
    }, 100);
  }

  this.stopLoop = function() {
    clearInterval(intervalID);
  }

  relayout = function() {
    var amountRightSet = amountVertex-amountLeftSet;
    for (var i = 1; i <= amountLeftSet; i++) {
      iVL[i-1]["x"] = 200;
      iVL[i-1]["y"] = 250 + (i - (amountLeftSet+1)/2) * (amountLeftSet == 1 ? 0 : 400 / (amountLeftSet-1));
    }

    for (var i = 1; i <= amountRightSet; ++i) {
      iVL[i+amountLeftSet-1]["x"] = 400;
      iVL[i+amountLeftSet-1]["y"] = 250 + (i - (amountRightSet+1)/2) * (amountRightSet == 1 ? 0 : 400 / (amountRightSet-1));
    }
  }

  this.draw = function() {
    if ($("#draw-err p").html() != "No Error") return false;
    if ($("#submit").is(':checked'))
      this.submit(JSONresult);
    if ($("#copy").is(':checked')) {
      window.prompt("Copy to clipboard:", JSONresult);
    }
    if ($("#relayout").is(':checked'))
      relayout();

    graph = createState(iVL,iEL);
    gw.updateGraph(graph, 500);
    return true;
  }

  this.submit = function(graph) {
    $.ajax({
      url: PHP_DOMAIN + "/php/Graph.php?mode=" + MODE_SUBMIT_GRAPH + "&sessionID=" + $.cookie("sessionID"),
      type: "POST",
      data: {canvasWidth: 1000, canvasHeight: 500, graphTopics: 'Graph Matching', graphState: graph},
      error: function(xhr, errorType, exception) { //Triggered if an error communicating with server  
        var errorMessage = exception || xhr.statusText; //If exception null, then default to xhr.statusText  
        alert("There was an error submitting your graph " + errorMessage);
      }
    }).done(function(data) {
      console.log(data);
    });
  }

  this.importjson = function(text) {
    // var text = $("#samplejson-input").val();
    takeJSON(text);
    // statusChecking(); TODO: reenable this later
    graph = createState(iVL,iEL);
    gw.updateGraph(graph, 500);
  }
    
  this.initRandom = function(graph) {
    iVL = graph.iVL;
    iEL = graph.iEL;
    amountVertex = iVL.length;
    amountEdge = iEL.length;
    fixJSON();
    statusChecking();
    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
  }

  this.generateRandom = function() {
    amountVertex = Math.floor(Math.random()*9) + 4; // 4 to 12
    var numL = Math.floor(Math.random() * (amountVertex-3)) + 1; // 1 to N-3
    if (numL > 6) numL = 6;
    var rightVertex = amountVertex-numL;
    iVL = new Object();
    iEL = new Object();
    amountEdge = 0;

    for (var i = 0; i < numL; i++) {
      iVL[i] = {
        "x": 200,
        "y": (250 + (i+1-(numL+1)/2) * (numL == 1 ? 0 : 400/(numL-1)))
      }
    }

    for (var i = 0; i < rightVertex; i++) {
      iVL[i+numL] = {
        "x": 450,
        "y": (250 + (i+1-(rightVertex+1)/2) * (rightVertex == 1 ? 0 : 400/(rightVertex-1)))
      }
    }

    for (var i = 0; i < numL; i++)
      for (var j = 0; j < rightVertex; j++) {
        var existEdge = Math.floor(Math.random()*2);
        if (existEdge == 1) {
          iEL[amountEdge] = {
            "u": i,
            "v": j+numL,
            "w": 1
          }
          amountEdge++;
        }
      }

    amountVertex = 0;
    amountEdge = 0;
    for (var i in iVL) amountVertex++;
    for (var i in iEL) amountEdge++;
    amountLeftSet = numL;
    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
    return true;
  }

  this.augmentingPath = function(isGreedy, callback) {
    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, vertexHighlighted = {}, edgeHighlighted = {}, edgeTraversed2 = {}, vertexTraversed2 = {};
    var cs, key;
    var toSet = [], toUnSet = [];
    var LeftToRightEdge = [], RightToLeftEdge = [];
    var edgeDict = {};

    if (amountVertex == 0) { // no graph
      $('#augpath-err').html("There is no graph to run this on. Please select a sample graph first.");
      return false;
    }

    for (key in iEL) {
      var edgeDictKeyOne = [];
      var edgeDictKeyTwo = [];
      edgeDictKeyOne.push(iEL[key]["u"]);
      edgeDictKeyOne.push(iEL[key]["v"]);
      edgeDictKeyTwo.push(iEL[key]["v"]);
      edgeDictKeyTwo.push(iEL[key]["u"]);
      edgeDict[edgeDictKeyOne] = key;
      edgeDict[edgeDictKeyTwo] = key;
    }

    relayout();

    var match = {}, vis = {};

    for (key in iVL) match[key] = -1;

    if (isGreedy) {
      populatePseudocode(3);
      match = greedyMatch();
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
      cs["status"] = "Random greedy pairing has been picked.";
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else
      populatePseudocode(0);

    cs = createState(iVL, iEL,  vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
    cs["status"] = "For each vertex in the left hand set,<br>look for an augmenting path.";
    cs["lineNo"] = isGreedy ? 4 : 1;
    stateList.push(cs);

    for (var i = 0; i < amountLeftSet; i++) {
      vertexTraversed = {};
      vertexTraversed[i] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
      cs["status"] = "For vertex {i}:".replace("{i}", i);
      cs["lineNo"] = isGreedy ? 4 : 1;
      stateList.push(cs);    
      for (key in iVL) vis[key] = 0;

      LeftToRightEdge = [];
      RightToLeftEdge = [];

      if (match[i] === -1) Aug(i);

      LeftToRightEdge.reverse();
      RightToLeftEdge.reverse();

      for (var x = 0; x < RightToLeftEdge.length; x++) {
        edgeTraversed[LeftToRightEdge[x][0]] = true;
        vertexTraversed[LeftToRightEdge[x][1]] = true;
        vertexTraversed2[LeftToRightEdge[x][2]] = true;
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, vertexTraversed2, edgeTraversed2);
        cs["status"] = "Free edge from {fromEdge} to {toEdge} is added to augmenting path."
                        .replace("{fromEdge}", iVL[LeftToRightEdge[x][1]]["text"])
                        .replace("{toEdge}", iVL[LeftToRightEdge[x][2]]["text"]);
        cs["lineNo"] = isGreedy ? 4 : 2;
        stateList.push(cs);
        toSet.push(LeftToRightEdge[x]);

        edgeTraversed2[RightToLeftEdge[x][0]] = true;
        vertexTraversed2[RightToLeftEdge[x][1]] = true;
        vertexTraversed[RightToLeftEdge[x][2]] = true;
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, vertexTraversed2, edgeTraversed2);
        cs["status"] = "Matched edge from {fromEdge} back to {toEdge} is added to augmenting path."
                        .replace("{fromEdge}", iVL[RightToLeftEdge[x][1]]["text"])
                        .replace("{toEdge}", iVL[RightToLeftEdge[x][2]]["text"]);
        cs["lineNo"] = isGreedy ? 4 : 2;
        stateList.push(cs);
        toUnSet.push(RightToLeftEdge[x]);
      }

      if (LeftToRightEdge.length > RightToLeftEdge.length) {
        var x = RightToLeftEdge.length;
        edgeTraversed[LeftToRightEdge[x][0]] = true;
        vertexTraversed[LeftToRightEdge[x][1]] = true;
        vertexTraversed2[LeftToRightEdge[x][2]] = true;
        toSet.push(LeftToRightEdge[x]);
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, vertexTraversed2, edgeTraversed2);
        cs["status"] = "Free edge from {fromEdge} to {toEdge} (free vertex) is added to augmenting path.<br>We find an augmenting path of length {length} edge(s)."
                        .replace("{fromEdge}", iVL[LeftToRightEdge[x][1]]["text"])
                        .replace("{toEdge}", iVL[LeftToRightEdge[x][2]]["text"])
                        .replace("{length}", toSet.length+toUnSet.length);
        cs["lineNo"] = isGreedy ? 4 : 2;
        stateList.push(cs);
      }

      vertexTraversed = {};
      vertexTraversed2 = {};
      for (var x = 0; x < toUnSet.length; x++) {
        edgeHighlighted[toSet[x][0]] = true;
        delete edgeTraversed[toSet[x][0]];
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, vertexTraversed2, edgeTraversed2);
        cs["status"] = "Flipped free edge from {fromEdge} to {toEdge} to matched edge."
                        .replace("{fromEdge}", iVL[LeftToRightEdge[x][1]]["text"])
                        .replace("{toEdge}", iVL[LeftToRightEdge[x][2]]["text"]);
        cs["lineNo"] = isGreedy ? 4 : 3;

        delete edgeHighlighted[RightToLeftEdge[x][0]];
        delete edgeTraversed2[toUnSet[x][0]];
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
        cs["status"] = "Flipped matched edge from {fromEdge} to {toEdge} to free edge."
                        .replace("{fromEdge}", iVL[LeftToRightEdge[x][1]]["text"])
                        .replace("{toEdge}", iVL[LeftToRightEdge[x][2]]["text"]);
        cs["lineNo"] = isGreedy ? 4 : 3;
      }

      if (toSet.length > toUnSet.length) {
        var x = toSet.length - 1;
        edgeHighlighted[toSet[x][0]] = true;
        delete edgeTraversed[toSet[x][0]];
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, vertexTraversed2, edgeTraversed2);
        cs["status"] = "Flipped free edge from {fromEdge} to {toEdge} to matched edge."
                        .replace("{fromEdge}", iVL[LeftToRightEdge[x][1]]["text"])
                        .replace("{toEdge}", iVL[LeftToRightEdge[x][2]]["text"]);
        cs["lineNo"] = isGreedy ? 4 : 3;
      }

      if (LeftToRightEdge.length > 0) { // is there an augmenting path of length 1 (or more)?
        toSet = [];
        toUnSet = [];
        edgeTraversed = {};
        edgeTraversed2 = {};
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
        cs["status"] = "All edges in this augmenting path are flipped.<div>Cardinality of matching increases by +1.</div>";
        cs["lineNo"] = isGreedy ? 4 : 3;
        stateList.push(cs);
      }
    }

    vertexTraversed = {};
    vertexTraversed2 = {};

    var numberOfMatchings = 0;
    for (var i = amountLeftSet; i < amountVertex; ++i)
      if (match[i] != -1) ++numberOfMatchings;

    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
    cs["status"] = "Done.<br>Found {numberOfMatchings} matchings (the black highlighted edges).".replace("{numberOfMatchings}", numberOfMatchings);
    cs["lineNo"] = isGreedy ? 4 : 4;
    stateList.push(cs);

    gw.startAnimation(stateList, callback);
    return true;

    function uncolourAllEdges(v) {
      for (var j=0; j < amountEdge; j++) {
        var edge = iEL[j];
        if (v === edge["vertexA"] ||v === edge["vertexB"]){
          toUnSet.push(j);
        }
      }
      return;
    }

    function Aug(l) {
      if (vis[l] !== 0) return 0;
      vis[l] = 1;
      for(var j = 0; j < amountEdge; j++) {
        var edge = iEL[j];
        var e,r;
        if (l === edge["u"]) {
          r = edge["v"];
          if (match[r] === -1 || Aug(match[r])) {
            e = edgeDict[[l, r]];
            LeftToRightEdge.push([e,l,r]);
            if (match[r]!==-1) {
              e = edgeDict[[r, match[r]]];
              RightToLeftEdge.push([e,r,match[r]]);
            }
            match[r] = l;
            return 1;
          }
        }
        else if (l === edge["v"]){
          r = edge["u"];
          if (match[r] === -1 || Aug(match[r])) {
            e = edgeDict[[l, r]];
            LeftToRightEdge.push([e,l,r]);
            if (match[r]!==-1) {
              e = edgeDict[[r,match[r]]];
              RightToLeftEdge.push([e,r,match[r]]);
            }
            match[r] = l;
            return 1;
          }
        }     
      }
      return 0;
    }

    function greedyMatch() {
      for (var x = 0; x < amountLeftSet; x++) {
        x = +x;
        var unmatchedNeighbour = new Array();
        for (var key in iEL) if(iEL[key]["u"] == x) {
          var y = iEL[key]["v"];
          if (match[y] != -1) continue;
          edgeTraversed[key] = true;  
          unmatchedNeighbour.push(y);
        }
        if (unmatchedNeighbour.length > 0) {
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
          cs["status"] = "Unmatched neighbour of {vertex} are {".replace("{vertex}", iVL[x]["text"]);
          for (var i = 0; i < unmatchedNeighbour.length; i++) {
            cs["status"] += iVL[unmatchedNeighbour[i]]["text"];
            if (i < unmatchedNeighbour.length-1) cs["status"] += ', ';
          }
          cs["status"] += '}';
          cs["lineNo"] = [2];
          stateList.push(cs);

          var randomSelect = unmatchedNeighbour[Math.floor(Math.random() * unmatchedNeighbour.length)];
          for (var key in iEL) if (iEL[key]["u"] == x) {
            var y = iEL[key]["v"];
            if (match[y] != -1) continue;
            if (y != randomSelect) 
              delete edgeTraversed[key];
          }
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
          cs["status"] = "Randomly match vertex {vertex} with vertex {randomVertex}."
                          .replace("{randomVertex}", iVL[randomSelect]["text"])
                          .replace("{vertex}", iVL[x]["text"]);
          cs["lineNo"] = [3];
          stateList.push(cs);

          match[x] = randomSelect;
          match[randomSelect] = x;

          for (var key in iEL) if(iEL[key]["u"] == x && iEL[key]["v"] == randomSelect) {
            delete edgeTraversed[key];
            edgeHighlighted[key] = true;
          }
        }
        else {
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed);
          cs["status"] = "There is no unmatched neighbour of {vertex}".replace("{vertex}", iVL[x]["text"]);
          cs["lineNo"] = [2];
          stateList.push(cs);
        }
      }
      return match;
    }
  }

  this.rookattack = function() {
    var numOfRows = parseInt($('#rows').val());
    var numOfColumns = parseInt($('#columns').val());
    var blocked = new Array(numOfRows);

    for (var i = 0; i < numOfRows; i++) {
      blocked[i] = new Array(numOfColumns);
      for (var j = 0; j < numOfColumns; j++)
        blocked[i][j] = false;
    }

    if (numOfRows < 1 || numOfColumns < 1 || numOfRows > 6 || numOfColumns > 6) { // no graph
      $('#modeling-err').html("Invalid size. Row and column size must be between 1 and 6 inclusive.");
      return false;
    }

    this.changeState = function(rowIndex,columnIndex) {
      var temp = '#cell' + rowIndex + columnIndex;
      if (blocked[rowIndex][columnIndex]) {
        $(temp).attr("bgcolor","white");
        blocked[rowIndex][columnIndex] = false;
      }
      else {
        $(temp).attr("bgcolor","black");
        blocked[rowIndex][columnIndex] = true;
      }
    }

    this.createBipartiteGraph = function() {
      iVL = {};
      iEL = {};
      vertexHighlighted = {};
      edgeRed = {};
      stateList = [];
      var cs;
      amountEdge = 0;
      amountVertex = numOfRows + numOfColumns;
      amountLeftSet = numOfRows;

      for (var i = 1; i <= numOfRows; i++) {
        iVL[i-1] = {
          "x": 225,
          "y": (250 + (i - (numOfRows + 1) / 2) * (numOfRows == 1 ? 0 : 450 / (numOfRows - 1))),
          "text": "R"+i
        }
        vertexHighlighted[i-1] = true;
      }

      cs = createState(iVL, iEL,vertexHighlighted);
      cs["status"] = 'Create a vertex for each rows';
      cs["status"] += '<br>and connect source vertex to each vertex with capacity 1</br>';
      cs["lineNo"] = [2];
      stateList.push(cs);
      for (var i = 1; i <= numOfRows; i++)
        delete vertexHighlighted[i-1];

      for (var i = 1; i <= numOfColumns; i++) {
        iVL[i+numOfRows-1] = {
          "x": 425,
          "y": (250 + (i - (numOfColumns + 1) / 2) * (numOfColumns == 1 ? 0 : 450 / (numOfColumns - 1))),
          "text": "C"+i
        }
        vertexHighlighted[i+numOfRows-1] = true;
      }
      cs = createState(iVL, iEL,vertexHighlighted);
      cs["status"] = 'Create a vertex for each columns';
      cs["status"] += '<br>and connect each vertex to sink vertex with capacity 1</br>';
      cs["lineNo"] = [3];
      stateList.push(cs);
      for (var i = 1; i <= numOfColumns; i++)
        delete vertexHighlighted[i+numOfRows-1];

      for (var i = 0; i < numOfRows; i++) {
        for (var j = 0; j < numOfColumns; j++) {
          var existEdge = 1-blocked[i][j];
          if (existEdge == 1) {
            iEL[amountEdge] = {
              "u": i,
              "v": j+numOfRows,
              "w": 9
            }
            amountEdge++;
            edgeRed[amountEdge-1] = true;
            cs = createState(iVL, iEL,vertexHighlighted, edgeRed);
            cs["status"] = 'Adding edge from R' + (i+1) + ' to C' + (j+1);
            cs["lineNo"] = [4,5];
            stateList.push(cs);
            delete edgeRed[amountEdge-1];
          }
        }
      }

      amountVertex = 0;
      amountEdge = 0;
      for (var i in iVL) amountVertex++;
      for (var i in iEL) amountEdge++;

      cs = createState(iVL, iEL);
      cs["status"] = 'Run any Max Cardinality Bipartite Matching';
      cs["status"] += '<br>to get the value of the maximum rooks that can be placed</br>';
      cs["lineNo"] = [6];
      stateList.push(cs);
      gw.startAnimation(stateList);
      return true;
    }

    this.inputFinished = function() {
      $('.overlays').hide("slow");
      $('#dark-overlay').hide("slow");
      $('#rookattack-board').hide("slow");
      bmw.createBipartiteGraph();
      $('#current-action').show();
      $('#current-action p').html("Modeling()");
      $('#progress-bar').slider( "option", "max", gw.getTotalIteration()-1);
      triggerRightPanels();
      populatePseudocode(2);
      isPlaying = true;
      return true;
    }

    this.cancel = function() {
      $('.overlays').hide("slow");
      $('#dark-overlay').hide("slow");
      $('#rookattack-board').hide("slow");
      $('#progress-bar').slider( "option", "max", gw.getTotalIteration()-1);
      return true;
    }

    this.inputRandomized = function() {
      for (var i = 0; i < numOfRows; i++)
        for (var j = 0; j < numOfColumns; j++)
          if (Math.random() < 0.5) this.changeState(i,j);
    }

    $('#dark-overlay').show("slow");
    var toWrite = '<html>\n';
    toWrite += '<p>Click on any cell to toggle between black/white cell</p>\n';
    toWrite += '<p>Rooks can\'t be placed in black cells</p>\n';
    toWrite += '<table border="1" id="board">'
    for (var j = 0; j < numOfColumns; j++)
      toWrite += '<col width="50">';
    for (var i = 0; i < numOfRows; i++) {
      toWrite += '<tr>';
      for (var j = 0; j < numOfColumns; j++)
        toWrite += '<td height="50" bgcolor="white" id="cell' + i + j + '" onclick=bmw.changeState('+i+','+j+')></td>';
      toWrite += '</tr>';
    }

    toWrite += '</table>\n';
    toWrite += '<div class="modeling-actions">';
    toWrite += '<p onclick=bmw.inputRandomized()>Randomized</p>';
    toWrite += '<p onclick=bmw.inputFinished()>Done</p>';
    toWrite += '<p onclick=bmw.cancel()>Cancel</p>';
    toWrite += '</div>\n'
    toWrite += '</html>\n';
    $('#rookattack-board').html(toWrite);
    $('#rookattack-board').show("slow");
  }

  this.modeling = function(modelingType) {
    iEL = {};
    iVL = {};
    if (modelingType == "rookattack") this.rookattack();
    if (modelingType == "baseball") this.baseball();
    return true;
  }

  this.hopcroftKarpViz = function(callback) {
    var graph = new HopcroftKarp.Graph(amountVertex);
    for (var key in iEL) {
      var u = +iEL[key]['u'];
      var v = +iEL[key]['v'];
      graph.adj[u][v] = graph.adj[v][u] = 1;
    }
    function findEdgeId(u, v) {
      for (var key in iEL) {
        if (+iEL[key]['u'] === u && +iEL[key]['v'] === v) {
          return +key;
        }
        if (+iEL[key]['v'] === u && +iEL[key]['u'] === v) {
          return +key;
        }
      }
      return -1;
    }
    var cs, stateList = [];
    var vizInfo = [];
    var result = HopcroftKarp.HopcroftKarp(graph, amountLeftSet, vizInfo);
    // console.log(JSON.stringify(vizInfo));
    var matchingSize = 0;
    var edgeHighlighted = {};
    for (var i = 0; i < vizInfo.length; i++) {
      var info = vizInfo[i];
      edgeHighlighted = {};
      for (var j = 0; j < graph.n; j++) {
        if (info.curMatching[j] !== -1) {
          var edgeId = findEdgeId(j, info.curMatching[j]);
          edgeHighlighted[edgeId] = true;
        }
      }
      switch (info.payload.kind) {
        case "BFSDistance":
          var maxDistance = -1;
          for (var j = 0; j < graph.n; j++) {
            iVL[j]["extratext"] = info.payload.distance[j] < 0 ? "INF" : info.payload.distance[j];
            if (info.payload.distance[j] > maxDistance) {
              maxDistance = info.payload.distance[j];
            }
          }
          cs = createState(iVL, iEL, {}, edgeHighlighted);
          if (maxDistance >= 0) {
            cs["status"] = "Partition the graph into layers based on augmenting path.";
            cs["lineNo"] = [1, 2];
            stateList.push(cs);
          } else {
            cs["status"] = "No more augmenting paths.";
            cs["lineNo"] = 1;
            stateList.push(cs);
          }
          break;
        case "NewMatching":
          var edgeTraversed = {};  // !matched && selected
          var edgeTraversed2 = {};  // matched && selected
          for (var j = 0; j < info.payload.newMatchings.length - 1; j++) {
            var edgeId = findEdgeId(info.payload.newMatchings[j][1], info.payload.newMatchings[j + 1][0]);
            if (edgeId === -1) {
              alert("W");
            }
            delete edgeHighlighted[edgeId];
            edgeTraversed2[edgeId] = true;
          }
          matchingSize++;
          var augmentingPath = [];
          for (var j = 0; j < info.payload.newMatchings.length; j++) {
            augmentingPath.push(info.payload.newMatchings[j][0]);
            augmentingPath.push(info.payload.newMatchings[j][1]);
            var edgeId = findEdgeId(info.payload.newMatchings[j][0], info.payload.newMatchings[j][1]);
            if (edgeId === -1) {
              alert("W");
            }
            edgeTraversed[edgeId] = true;
          }
          cs = createState(iVL, iEL, {}, edgeHighlighted, {}, edgeTraversed, {}, edgeTraversed2);
          cs['status'] = 'Found new matching from the following augmenting path: ' + augmentingPath.join(', ');
          cs['lineNo'] = [3, 4];
          stateList.push(cs);
          break;
        default:
      }
    }
    for (var i = 0; i < graph.n; i++) {
      iVL[i]['extratext'] = '';
    }
    cs = createState(iVL, iEL, {}, edgeHighlighted);
    cs["status"] = "Found matchings of size " + matchingSize;
    cs["lineNo"] = [];
    stateList.push(cs);
    populatePseudocode(1);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.edmondsBlossomViz = function(performGreedyAssignment) {
    var graph = new EdmondsBlossom.Graph(amountVertex);
    for (var key in iEL) {
      var u = +iEL[key]['u'];
      var v = +iEL[key]['v'];
      graph.adj[u][v] = graph.adj[v][u] = 1;
    }
    var vizInfo = [];
    var result = EdmondsBlossom.EdmondsBlossom(graph, performGreedyAssignment, vizInfo);
    var canRemove = {};
    // never hide vertices with degree 0
    {
      var degree = [];
      for (var i = 0; i < amountVertex; i++) {
        degree[i] = 0;
      }
      for (var key in iEL) {
        degree[+iEL[key]['u']]++;
        degree[+iEL[key]['v']]++;
      }
      for (var i = 0; i < amountVertex; i++) {
        canRemove[i] = degree[i] === 0 ? false : true;
      }
    }
    // console.log(JSON.stringify(vizInfo));
    var lastRoot = -1;
    function createVL(el, blossom) {
      var degree = [];
      for (var i = 0; i < amountVertex; i++) {
        degree[i] = 0;
      }
      for (var key in el) {
        degree[+el[key]['u']]++;
        degree[+el[key]['v']]++;
      }
      var newVL = {};
      for (var i = 0; i < amountVertex; i++) {
        newVL[i] = $.extend({}, iVL[i]);
        if (degree[i] === 0 && i !== lastRoot && canRemove[i]) {
          // hide this
          newVL[i]['x'] = 1000;
          newVL[i]['y'] = 1000;
        }
      }
      return newVL;
    }
    function createEL(graph) {
      var newEL = {};
      var edgeCount = 0;
      for (var i = 0; i < graph.n; i++) {
        for (var j = i + 1; j < graph.n; j++) {
          if (graph.adj[i][j]) {
            newEL[edgeCount++] = {'u': i, 'v': j};
          }
        }
      }
      return newEL;
    }
    function findEdgeIndex(el, from, to) {
      for (var key in el) {
        if (el[key]['u'] === from && el[key]['v'] === to) {
          return +key;
        }
        if (el[key]['v'] === from && el[key]['u'] === to) {
          return +key;
        }
      }
      return -1;
    }
    var lastMatching = [];
    var lastVL = iVL;
    var lastEL = iEL;
    var cs, stateList = [];
    var matchingSize = 0;
    var edgeHighlighted = {};  // matched && !selected
    for (var i = 0; i < vizInfo.length; i++) {
      if (lastEL === undefined) {
        alert("ERROR!" + i);
      }
      var info = vizInfo[i];
      var status = "";
      var vertexHighlighted = {};
      edgeHighlighted = {};
      var edgeTraversed = {};  // !matched && selected
      var edgeTraversed2 = {};  // matched && selected
      var vertexHighlighted = {};  // for blossom
      var vertexTraversed = {};
      var newEL = undefined;
      for (var j = 0; j < graph.n; j++) {
        var edgeIndex = findEdgeIndex(lastEL, j, info.curMatching[j]);
        if (edgeIndex === -1) {
          // hidden
          continue;
        }
        edgeHighlighted[edgeIndex] = true;
      }
      switch (info.payload.kind) {
        case "AddGreedyMatching":
          status = "Randomly match " + info.payload.newMatching[0] + " and " + info.payload.newMatching[1];
          cs = createState(iVL, iEL, {}, edgeHighlighted);
          cs["status"] = status;
          cs["lineNo"] = 1;
          stateList.push(cs);
          matchingSize++;
          break;
        case "FoundAugmentingPath":
          status = "Found an augmenting path " + info.payload.path.join(" -> ");
          for (var j = 1; j < info.payload.path.length; j++) {
            var prev = info.payload.path[j - 1];
            var cur = info.payload.path[j];
            var edgeIndex = findEdgeIndex(lastEL, info.payload.path[j - 1], info.payload.path[j]);
            if (edgeIndex === -1) {
              // error
              alert("what?");
              return false;
            }
            if (info.curMatching[prev] === cur) {
              delete edgeHighlighted[edgeIndex];
              edgeTraversed2[edgeIndex] = true;
            } else {
              edgeTraversed[edgeIndex] = true;
            }
          }
          cs = createState(createVL(lastEL), lastEL, {}, edgeHighlighted, {}, edgeTraversed, {}, edgeTraversed2);
          cs["status"] = status;
          if (performGreedyAssignment) {
            cs["lineNo"] = [2, 3];
          } else {
            cs["lineNo"] = [1, 2];
          }
          stateList.push(cs);
          break;
        case "NoAugmentingPath":
          status = "No augmenting path from " + info.payload.start + " found";
          cs = createState(createVL(lastEL), lastEL);
          cs["status"] = status;
          cs["lineNo"] = 1;
          stateList.push(cs);
          break;
        case "IncreaseMatching":
          status = "Increased the number of matching by one.";
          // do nothing
          cs = createState(createVL(lastEL), lastEL, {}, edgeHighlighted, {}, edgeTraversed, {}, edgeTraversed2);
          cs["status"] = status;
          if (performGreedyAssignment) {
            cs["lineNo"] = [2, 4, 5]
          } else {
            cs["lineNo"] = [1, 2, 4];
          }
          lastMatching = info.curMatching.slice(0);
          stateList.push(cs);
          matchingSize++;
          break;
        case "ContractBlossom":
          status = "Found an odd-length cycle " + (info.payload.blossom.concat([info.payload.blossom[0]]).join(" -> "));
          lastRoot = info.payload.root;
          for (var j = 0; j < info.payload.blossom.length; j++) {
            vertexHighlighted[info.payload.blossom[j]] = true;
          }
          for (var j = 0; j < info.payload.pathToBlossom.length; j++) {
            var cur = info.payload.pathToBlossom[j];
            var next = j === info.payload.pathToBlossom.length - 1 ? info.payload.root : info.payload.pathToBlossom[j + 1];
            var edgeIndex = findEdgeIndex(lastEL, cur, next);
            if (edgeIndex === -1) {
              // error
              alert("WHAT? " + JSON.stringify(lastEL) + " " + cur + " " + next);
              return false;
            }
            if (info.curMatching[cur] === next) {
              delete edgeHighlighted[edgeIndex];
              edgeTraversed2[edgeIndex] = true;
            } else {
              edgeTraversed[edgeIndex] = true;
            }
          }
          cs = createState(createVL(lastEL), lastEL, {}, edgeHighlighted, {}, edgeTraversed, {}, edgeTraversed2);
          cs["status"] = status;
          if (performGreedyAssignment) {
            cs["lineNo"] = [2, 6, 7];
          } else {
            cs["lineNo"] = [1, 5, 6];
          }
          stateList.push(cs);
          newEL = createEL(info.payload.newGraph);
          edgeHighlighted = {};
          for (var j = 0; j < graph.n; j++) {
            var k = info.curMatching[j];
            if (k !== -1) {
              var edgeIndex = findEdgeIndex(newEL, j, k);
              if (edgeIndex !== -1) {
                edgeHighlighted[edgeIndex] = true;
              }
            }
          }
          cs = createState(createVL(newEL), newEL, {}, edgeHighlighted);
          cs["status"] = status;
          if (performGreedyAssignment) {
            cs["lineNo"] = [2, 6, 7];
          } else {
            cs["lineNo"] = [1, 5, 6];
          }
          stateList.push(cs);
          break;
        case "ExpandBlossom":
          status = "Expanding blossom rooted at " + info.payload.root + ". ";
          var rootIndexInPath = -1;
          for (var j = 0; j < info.payload.highlightedPath.length; j++) {
            if (info.payload.highlightedPath[j] === info.payload.root) {
              rootIndexInPath = j;
              break;
            }
          }
          newEL = createEL(info.payload.newGraph);
          edgeHighlighted = {};
          for (var j = 0; j < graph.n; j++) {
            var k = info.curMatching[j];
            if (k === -1) {
              continue;
            }
            var edgeIndex = findEdgeIndex(newEL, j, k);
            if (edgeIndex === -1) {
              // ignore
              continue;
            }
            edgeHighlighted[edgeIndex] = true;
          }
          for (var j = 1; j < info.payload.highlightedPath.length; j++) {
            var prev = info.payload.highlightedPath[j - 1];
            var cur = info.payload.highlightedPath[j];
            if (j - 1 === rootIndexInPath) {
              continue;
            }
            var edgeIndex = findEdgeIndex(newEL, prev, cur);
            if (edgeIndex === -1) {
              // error
              alert("NANI?");
              return false;
            }
            if (info.curMatching[prev] === cur) {
              delete edgeHighlighted[edgeIndex];
              edgeTraversed2[edgeIndex] = true;
            } else {
              edgeTraversed[edgeIndex] = true;
            }
          }
          for (var j = 0; j < info.payload.pathTakenInside.length; j++) {
            var prev = j == 0 ? info.payload.root : info.payload.pathTakenInside[j - 1];
            var cur = info.payload.pathTakenInside[j];
            vertexTraversed[cur] = true;
            var edgeIndex = findEdgeIndex(newEL, prev, cur);
            if (edgeIndex === -1) {
              // error
              alert("?? " + prev + " " + cur + " " + JSON.stringify(newEL));
              return false;
            }
            if (info.curMatching[prev] === cur) {
              delete edgeHighlighted[edgeIndex];
              edgeTraversed2[edgeIndex] = true;
            } else {
              edgeTraversed[edgeIndex] = true;
            }
          }
          if (rootIndexInPath !== -1) {
            var prev = info.payload.blossomFrom;
            var cur = info.payload.highlightedPath[rootIndexInPath + 1];
            var edgeIndex = findEdgeIndex(newEL, prev, cur);
            if (info.curMatching[prev] === cur) {
              delete edgeHighlighted[edgeIndex];
              edgeTraversed2[edgeIndex] = true;
            } else {
              edgeTraversed[edgeIndex] = true;
            }
          }
          if (info.payload.pathTakenInside.length > 0) {
            var path = [info.payload.blossomRoot].concat(info.payload.pathTakenInside).concat([info.payload.highlightedPath[rootIndexInPath + 1]]);
            status += info.payload.highlightedPath[rootIndexInPath + 1] + " is connected to " + info.payload.blossomFrom + " from the blossom. ";
            status += "Taking the following path " + path.join(" -> ") + " inside the blossom.";
          }
          cs = createState(createVL(newEL), newEL, {}, edgeHighlighted, vertexTraversed, edgeTraversed, {}, edgeTraversed2);
          cs["status"] = status;
          if (performGreedyAssignment) {
            cs["lineNo"] = [2, 3, 4];
          } else {
            cs["lineNo"] = [1, 2, 3];  // TODO(raisfathin)
          }
          stateList.push(cs);
          break;
        default:
          alert("UNHANDLED " + info.kind);
          return false;
      }
      if (newEL !== undefined) {
        lastEL = newEL;
      }
    }
    var edgeHighlighted = {};
    for (var i = 0; i < graph.n; i++) {
      if (lastMatching[i] !== -1) {
        var edgeId = findEdgeIndex(iEL, i, lastMatching[i]);
        if (edgeId !== -1) {
          edgeHighlighted[edgeId] = true;
        }
      }
    }
    cs = createState(iVL, iEL, {}, edgeHighlighted);
    cs['status'] = 'Found matchings of size ' + matchingSize;
    cs['lineNo'] = [];
    stateList.push(cs);
    populatePseudocode(performGreedyAssignment ? 5 : 4);
    gw.startAnimation(stateList);
    return true;
  }

  this.generalRandom = function() {
    // var id = CS4234_TUTORIAL_THREE;
    var id = HOUSE_OF_CARDS;
    iVL = getExampleGraph(id, VL);
    iEL = getExampleGraph(id, EL);
    fixJSON();
    // console.log(JSON.stringify(iVL));
    // console.log(JSON.stringify(iEL));
    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
    return true;
  }

  this.bipartiteRandom = function(randomType) { 
    // 0 : random; 1 : left 1; 2 : right 1; 3 : all 1
    amountVertex = Math.floor(Math.random()*7) + 6; // 6 to 12
    var numL = Math.floor(Math.random() * (amountVertex-4)) + 2; // 2 to N-2
    var numR = amountVertex-numL;
    amountLeftSet = numL;
    
    iVL = new Object();
    iEL = new Object();
    amountEdge = 0;

    for (var i = 1; i <= numL; i++) {
      iVL[i-1] = {
        "x": 200,
        "y": (250 + (i-(numL+1)/2) * (numL == 1 ? 0 : 400/(numL-1))),
        "text": i-1,
      }
    }

    for (var i = 1; i <= numR; i++) {
      iVL[i+numL-1] =  {
        "x": 400,
        "y": (250 + (i-(numR+1)/2) * (numR == 1 ? 0 : 400/(numR-1))),
        "text": i+numL-1,
      }
    }

    for (var i = 0; i < numL; i++)
      for (var j = 0; j < numR; j++) {
        var existEdge = Math.floor(Math.random()*2); // 50% chance
        if (existEdge == 1) {
          iEL[amountEdge] = {
            "u": i,
            "v": j+numL,
            "w": 1
          }
          amountEdge++;
        }
      }

    amountVertex = 0;
    amountEdge = 0;
    for (var i in iVL) amountVertex++;
    for (var i in iEL) amountEdge++;
    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);

    return true;
  }

  this.examples = function(id) {
    iVL = getExampleGraph(id, VL);
    iEL = getExampleGraph(id, EL);
    amountVertex = 0;
    amountEdge = 0;
    for (var key in iVL) amountVertex++;
    for (var key in iEL) amountEdge++;
    for (var key in iVL) iVL[key]['text'] = key;

    //amountLeftSet = templateToUse[4]; // FIX THIS... I don't have this value yet
    for (var i = 0; i < amountVertex; i++) {
      var validAmountLeftSet = true;
      for (var key in iEL) {
        var u = +iEL[key]['u'];
        var v = +iEL[key]['v'];
        if ((u <= i) == (v <= i)) {
          validAmountLeftSet = false;
        }
      }
      if (validAmountLeftSet) {
        amountLeftSet = i + 1;
        break;
      }
    }
    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
    return true;
  }
}

function createState(iVLObject, iELObject, vertexHighlighted, edgeHighlighted, vertexTraversed, edgeTraversed, vertexTraversed2, edgeTraversed2){
  if (vertexHighlighted == null) vertexHighlighted = {};
  if (edgeHighlighted == null) edgeHighlighted = {};
  if (vertexTraversed == null) vertexTraversed = {};
  if (edgeTraversed == null) edgeTraversed = {};
  if (vertexTraversed2 == null) vertexTraversed2 = {};
  if (edgeTraversed2 == null) edgeTraversed2 = {};

  var key;
  var state = {
    "vl":{},
    "el":{}
  };

  for (key in iVLObject) {
    state["vl"][key] = {};
    state["vl"][key]["cx"] = iVLObject[key]["x"];
    state["vl"][key]["cy"] = iVLObject[key]["y"];
    if (iVLObject[key]["text"] == null)
      state["vl"][key]["text"] = +key;
    else
      state["vl"][key]["text"] = iVLObject[key]["text"];
    if (iVLObject[key]["state"] == OBJ_HIDDEN)
      state["vl"][key]["state"] = OBJ_HIDDEN;
    else
      state["vl"][key]["state"] = VERTEX_DEFAULT;
    state["vl"][key]["extratext"] = iVLObject[key]["extratext"];
  }

  for (key in iELObject) {
    state["el"][key] = {};
    state["el"][key]["vertexA"] = iELObject[key]["u"];
    state["el"][key]["vertexB"] = iELObject[key]["v"];
    state["el"][key]["type"] = EDGE_TYPE_UDE;
    state["el"][key]["weight"] = iELObject[key]["w"];
    if (iELObject[key]["state"] == OBJ_HIDDEN)
      state["el"][key]["state"] = OBJ_HIDDEN;
    else
      state["el"][key]["state"] = EDGE_GREY;
    state["el"][key]["displayWeight"] = false;
    state["el"][key]["animateHighlighted"] = false;
  }

  for (key in vertexHighlighted)
    state["vl"][key]["state"] = VERTEX_HIGHLIGHTED;

  for (key in edgeHighlighted)
    state["el"][key]["state"] = EDGE_DEFAULT;

  for (key in vertexTraversed)
    state["vl"][key]["state"] = VERTEX_TRAVERSED;

  for (key in edgeTraversed)
    state["el"][key]["state"] = EDGE_TRAVERSED;

  for (key in vertexTraversed2)
    state["vl"][key]["state"] = VERTEX_BLUE_OUTLINE;

  for (key in edgeTraversed2)
    state["el"][key]["state"] = EDGE_BLUE;

  return state;
}

function populatePseudocode(act) {
  switch (act) {
    case 0: // Augmenting Path
      $('#code1').html('for each vertex in the left set');
      $('#code2').html('&nbsp&nbspif &exist; an augmenting path of 1 (or more) edge(s)');
      $('#code3').html('&nbsp&nbsp&nbsp;&nbsp;flip edge status along augmenting path');
      $('#code4').html('return');
      $('#code5').html('');
      $('#code6').html('');
      $('#code7').html('');
      break;
    case 1: // Hopcroft Karp's
      $('#code1').html('while &exist; some augmenting path(s)');
      $('#code2').html('&nbsp;run BFS to partition the graph into layers');
      $('#code3').html('&nbsp;while &exist; an augmenting path in this layer');
      $('#code4').html('&nbsp;&nbsp;flip edge status along augmenting path');
      $('#code5').html('');
      $('#code6').html('');
      $('#code7').html('');
      break;
    case 2: // Rook Attack modeling
      $('#code1').html('create source and sink vertex');
      $('#code2').html('create one vertex Ri for each row i');
      $('#code3').html('create one vertex Cj for each column j');
      $('#code4').html('for each rook-placable cell (i, j)');
      $('#code5').html('&nbsp;&nbsp;add an edge from Ri to Cj');
      $('#code6').html('run any MCBM algorithm');
      $('#code7').html('');
      break;
    case 3: // Augmenting Path with randomized greedy preprocessing
      $('#code1').html('for each vertex v in the left set');
      $('#code2').html('&nbsp&nbsp(randomly) choose unmatched neighbour x');
      $('#code3').html('&nbsp&nbspmatch v (left set) with x (right set)');
      $('#code4').html('Run the standard Augmenting Path Algorithm');
      $('#code5').html('');
      $('#code6').html('');
      $('#code7').html('');
      break;
    case 4:
      $('#code1').html('while &exist; an unprocessed vertex');
      $('#code2').html('&nbsp;if &exiss; an augmenting path');
      $('#code3').html('&nbsp;&nbsp;expand the blossom');
      $('#code4').html('&nbsp;&nbsp;flip the status of edges in the augmenting path');
      $('#code5').html('&nbsp;else if there is an odd-length cycle');
      $('#code6').html('&nbsp;&nbsp;contract the odd cycle and update the graph');
      $('#code7').html('');
      break;
    case 5:
      $('#code1').html('go through each edge and pair them randomly');
      $('#code2').html('while &exist; an unprocessed vertex');
      $('#code3').html('&nbsp;if &exist; an augmenting path');
      $('#code4').html('&nbsp;&nbsp;expand the blossom');
      $('#code5').html('&nbsp;&nbsp;flip the status of edges in the augmenting path');
      $('#code6').html('&nbsp;else if there is an odd-length cycle');
      $('#code7').html('&nbsp;&nbsp;contract the odd cycle and update the graph');
      break;
  }
}



// matching_action.js
var actionsWidth = 150;
var statusCodetraceWidth = 410;

var isModelingOpen = false, isExamplesOpen = false, isAugPathOpen = false; // var isHopcroftOpen = false;

function openModeling() {
  $('#rookattack-input').hide();
  $('#baseball-input').hide();
  $('#bipartite-input').hide();
  if (!isModelingOpen) {
    $('.modeling').fadeIn('fast');
    isModelingOpen = true;
  }
}

function closeModeling() {
  if (isModelingOpen) {
    $('.modeling').fadeOut('fast');
    $('#modeling-err').html("");
    isModelingOpen = false;
  }
}

function openExamples() {
  if (!isExamplesOpen) {
    $('.examples').fadeIn('fast');
    isExamplesOpen = true;
  }
}

function closeExamples() {
  if (isExamplesOpen) {
    $('.examples').fadeOut('fast');
    isExamplesOpen = false;
  }
}

function openAugPath() {
  if (!isAugPathOpen) {
    $('.augpath').fadeIn('fast');
    isAugPathOpen = true;
  }
}

function closeAugPath() {
  if (isAugPathOpen) {
    $('.augpath').fadeOut('fast');
    $('#augpath-err').html("");
    isAugPathOpen = false;
  }
}

function hideEntireActionsPanel() {
  closeModeling();
  closeExamples();
  closeAugPath();
  hideActionsPanel();
}



// local
var bmw, gw;
var BIPARTITE_MATCHING = 1 << 0;
var WEIGHTED_GRAPH = 1 << 1;
var selectedState = -1;

$(function() {
  write(true, true);
  $('#play').hide();
  $('#drawgraph-form').append('<br><input type="checkbox" id="relayout" name="submit" value="submit" checked="checked">Relayout');
  $('#relayout').removeAttr('checked');
  bmw = new MCBM();
  gw = bmw.getGraphWidget();
  bmw.bipartiteRandom();
  //bmw.examples(CP3_4_42);

  $("#menu-unweighted-bipartite").on("click", function() {
    selectedState = BIPARTITE_MATCHING;
    $(".unweighted-general").hide();
    $(".unweighted-bipartite").show();
    $("#menu-unweighted-bipartite").removeClass("selected-viz");
    $("#menu-unweighted-general").removeClass("selected-viz");
    $("#menu-unweighted-general").html("U/G");
    $("#menu-unweighted-bipartite").addClass("selected-viz");
    $("#menu-unweighted-bipartite").html("(Unweighted Bipartite) Graph Matching");
    bmw.bipartiteRandom();
  });

  $("#menu-unweighted-general").on("click", function() {
    selectedState = 0;
    $(".unweighted-bipartite").hide();
    $(".unweighted-general").show();
    $("#menu-unweighted-bipartite").removeClass("selected-viz");
    $("#menu-unweighted-general").removeClass("selected-viz");
    $("#menu-unweighted-bipartite").html("U/B");
    $("#menu-unweighted-general").addClass("selected-viz");
    $("#menu-unweighted-general").html("(Unweighted General) Graph Matching");
    bmw.generalRandom();
  });

  $("#menu-unweighted-bipartite").click();

  var graphJSON = getQueryVariable("create");
  if (graphJSON.length > 0) {
    importjson(graphJSON);
    window.history.pushState("object or string", "Title", window.location.href.split('?')[0]);
  }

  $('#modeling').click(function() {
    openModeling();
    closeExamples();
    closeAugPath();
  });

  $('#examples').click(function() {
    closeModeling();
    openExamples();
    closeAugPath();
  });

  $('#augpath').click(function() {
    closeModeling();
    closeExamples();
    openAugPath();
  });
});

function importjson(text) {
  if(isPlaying) { stop(); }
  if (mode=="exploration") {
    bmw.importjson(text);
    closeExamples();
    isPlaying = false;
  }
}

function drawGraph() {
  if(isPlaying) { stop(); }
  if (mode=="exploration") {
    $('#dark-overlay').fadeIn(function(){
      $('#drawgraph').fadeIn();
    });
    bmw.startLoop();
    isPlaying = false;
  }
}
    
function drawDone() {
  if (!bmw.draw()) return false;
  bmw.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

function drawCancel() {
  bmw.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

function createRandom() {
  return; // this function is temporarily disabled
  if(isPlaying) { stop(); }
  if (mode=="exploration") {
    var n = Math.floor(5 + Math.random()*6);
    $.ajax({
      url: PHP_DOMAIN + "/php/Graph.php?mode=" + MODE_GET_RANDOM_SUBMITTED_GRAPH + "&directed=" + 0 + "&connected=" + 1 + "&bipartite=" + 1 + "&separatable=" + 1
    }).done(function(data){
      data = JSON.parse(data);
      var graph = extractQnGraph(data.graph);
      randomGraphID = data.graphID;
      bmw.initRandom(graph);
      $('#rate-sample-graph').show();
    })
    setTimeout(function(){
      $('#progress-bar').slider( "option", "max", 0);
      isPlaying = false;
    },500);
  }
}

function example(id) {
  if (isPlaying) stop();
  setTimeout(function() {
    if (bmw.examples(id)) { // (mode == "exploration") && 
      $('#progress-bar').slider("option", "max", 0);
      closeExamples();
      isPlaying = false;
    }
  }, 500);
}
 
function augmentingPath(callback) {
  if (isPlaying) stop();
  commonAction(bmw.augmentingPath(false, callback), "Augmenting Path Algorithm");
}
  
function greedyAug(callback) {
  if (isPlaying) stop();
  commonAction(bmw.augmentingPath(true, callback), "Augmenting Path Algorithm++");
}

function hopcroftKarp(callback) {
  if (isPlaying) stop();
  commonAction(bmw.hopcroftKarpViz(callback), "Hopcroft Karp's Algorithm");
}

function modelingOpen(modelingType) {
  $(".modeling").css("bottom","117px");
  if (modelingType != "rookattack") $('#rookattack-input').fadeOut('fast');
  if (modelingType != "baseball")   $('#baseball-input').fadeOut('fast');
  if (modelingType != "bipartite")  $('#bipartite-input').fadeOut('fast');
  $('#' + modelingType + '-input').fadeIn('fast');
}

function modeling(modelingType) {
  if(isPlaying) { stop(); }
  setTimeout( function() {
    if (mode != "exploration") return;
    if (!bmw.modeling(modelingType)) return;
  }, 500);
}

function bipartiteRandom(randomType) {
  bmw.bipartiteRandom(randomType);
  closeModeling();
}

function edmondsBlossomViz(performGreedyAssignment) {
  if (isPlaying) {stop();}
  setTimeout( function() {
    if ((mode=="exploration")&&bmw.edmondsBlossomViz(performGreedyAssignment)) {
      $('#current-action').show();
      $('#current-action p').html("Greedy + Augmenting Path MCBM");
      $('#progress-bar').slider("option","max",gw.getTotalIteration()-1);
      triggerRightPanels();
      isPlaying = true;
    }
  }, 500);
}

// Implement these functions in each visualisation
var userGraph = {
  'vl': {},
  'el': {},
};

// This function will be called before entering E-Lecture Mode
function ENTER_LECTURE_MODE() {
  //if (bmw) userGraph = bmw.getGraph();
}

// This function will be called before returning to Explore Mode
function ENTER_EXPLORE_MODE() {
  //loadGraph(userGraph);
}

// Lecture action functions
function CUSTOM_ACTION(action, data, mode) {
  if (action == 'augmentingpath') {
    hideSlide(function() {
      augmentingPath(showSlide);
    });
  }
  else if (action == 'hopcroftkarp') {
    hideSlide(function() {
      hopcroftKarp(showSlide);
    });
  }
  else if (action == 'greedyaug') {
    hideSlide(function() {
      greedyAug(showSlide);
    });
  }
}
</script>
</body>

<!-- Mirrored from visualgo.net/vi/matching by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 26 Nov 2020 06:40:17 GMT -->
</html>
