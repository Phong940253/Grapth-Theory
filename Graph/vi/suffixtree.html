<!DOCTYPE html>
<html lang="vi">

<!-- Mirrored from visualgo.net/vi/suffixtree by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 26 Nov 2020 06:40:37 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="description" content="A Suffix Tree is a compressed tree containing all the suffixes of the given text as their keys and positions in the text as their values. Suffix Tree provides a particularly fast implementation for many important string operations. This data structure is very related to Suffix Array data structure.">
<meta name="keywords" content="Suffix Tree Construction Common Prefix LCP String Matching Longest Repeated Substring">
 
<meta name="csrf-token" content="iVivZ7KRPe6XK7pbuGtOoEjljE1xyBVNhLKNFuF8">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/suffixtree.png">
<title>VisuAlgo - Suffix Tree</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common.css">
<link rel="stylesheet" href="../css/viz-1.0.1.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
      }
      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }
      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
    </style>
<style>
.execAction { padding: 5px 8px; }
.err { padding: 5px 0px; }
#actions-extras input {
  width: 35px;
  padding: 5px 8px 7px;
}

.build { bottom: 173px; } /* 146px; } */
.search { bottom: 146px; } /* 119px; } */
.lrs { bottom: 119px; } /*92px; }*/
.lcs { bottom: 65px; }

#build-input input, #search-input input, #lcs-input input { width: 120px; }

/*others*/
.background {
  fill: none;
  pointer-events: all;
}

.lcs_first {
  fill: #2ebbd1;
}

.lcs_second {
  fill: #52bc69;
}

.lcs_internal {
  fill: #eeeeee;
}
</style>
<script>
      function changeURL() {
        var URL = window.location.href.split('https://visualgo.net/');
        var val = document.getElementById("Language").value;
        URL[3] = val;
        window.location.assign(URL.join('https://visualgo.net/'));
      }
    </script>
</head>
<body>
<div id="top-bar">
<a href="http://www.comp.nus.edu.sg/~stevenha"><span class="colour" style="border: 1px solid green; border-radius: 25px;">7</span></a>&nbsp;&nbsp;&nbsp;
<a id="home" href="https://visualgo.net/">Visu<span class="colour">Algo</span><span style="font-size: 40%">.net</span></a>
/
<select id="Language" onchange="changeURL()">
<option value="en">en</option>
<option value="zh">zh</option>
<option value="es">es</option>
<option value="pt">pt</option>
<option value="ru">ru</option>
<option value="id">id</option>
<option value="de">de</option>
<option value="bn">bn</option>
 <option value="ja">ja</option>
<option value="ko">ko</option>
<option value="vi" selected>vi</option>
</select>
/suffixtree
<span class="right-links" id="useraccount">Login</span>
<span id="title">
<a id='title-suffixtree' class='selected-viz'>Suffix Tree</a>
</span>
<div id="mode-menu">
<div id='mode-button' title='exploration'>Chế độ thăm dò &#9663;</div>
<div id='other-modes'>
<a title='e-Lecture'>Chế độ Bài giảng trực tuyến</a>
</div>
</div>
</div>
<div id="dark-overlay"></div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id='speed-control'>Chậm<div id='speed-input'></div>Nhanh<br></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick=goToBeginning()><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick=stepBackward()><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick=pause()><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick=play()><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick=stepForward()><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick=goToEnd()><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id='viz'></div>
<div id='current-action' class='panel'></div>
<div id='e-lecture' class='panel'></div>
<div id="overlay" hidden></div>
<div id="dropdown-temp-holder" hidden></div>
<div id="electure-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>A <b>Suffix Tree</b> is a compressed tree containing all the suffixes of the given text as their keys and positions in the text as their values. Suffix Tree provides a particularly fast implementation for many important string operations. This data structure is very related to <a href="suffixarray.html"><u>Suffix Array</u></a> data structure.</p>
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
Please <a href="https://visualgo.net/login"><u>login</u></a> if you are a repeated visitor or <a href="https://visualgo.net/login"><u>register</u></a> for an (optional) free account first.</p>
<div id='electure-dropdown'>
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. Suffix Tree</option>
<option value="1-1">&nbsp;&nbsp;&nbsp;1-1. Suffix of a String T</option>
<option value="2">2. Suffix Tree Visualization</option>
<option value="2-1">&nbsp;&nbsp;&nbsp;2-1. Example with T = "GATAGACA$"</option>
<option value="2-2">&nbsp;&nbsp;&nbsp;2-2. Terminating Symbol $</option>
<option value="2-3">&nbsp;&nbsp;&nbsp;2-3. Suffix Tree has O(n) Vertices</option>
<option value="2-4">&nbsp;&nbsp;&nbsp;2-4. Much Shorter Suffix Tree</option>
<option value="3">3. Available Operations</option>
<option value="3-1">&nbsp;&nbsp;&nbsp;3-1. Build Suffix Tree (instant)</option>
<option value="3-2">&nbsp;&nbsp;&nbsp;3-2. Search</option>
<option value="3-3">&nbsp;&nbsp;&nbsp;3-3. Longest Repeated Substring (LRS)</option>
<option value="3-4">&nbsp;&nbsp;&nbsp;3-4. Longest Common Substring (LCS)</option>
<option value="4">4. Extras</option>
<option value="99">99. Status Panel</option>
<option value="99-1">&nbsp;&nbsp;&nbsp;99-1. Codetrace Panel</option>
<option value="99-2">&nbsp;&nbsp;&nbsp;99-2. Media Control</option>
<option value="99-3">&nbsp;&nbsp;&nbsp;99-3. Return to &#39;Exploration Mode&#39;</option>
</select>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-next' data-nextid="1-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-1-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>The suffix <b>i</b> (or the <b>i</b>-th suffix) of a (usually long) text string <b>T</b> is a &#39;special case&#39; of substring that goes from the <b>i</b>-th character of the string up to the <i>last</i> character of the string.</p><br><p>For example, if <b>T</b> = "STEVEN$", then suffix 0 of <b>T</b> is "STEVEN$" (0-based indexing), suffix 2 of <b>T</b> is "EVEN$", suffix 4 of <b>T</b> is "EN$", etc.</p>
<hr>
<p>Pro-tip: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b> to advance to the next slide, <b>[PageUp]</b> to go back to the previous slide, <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>The visualization of Suffix Tree of a string <b>T</b> is basically a rooted tree where path label (concatenation of edge label(s)) from root to each leaf describes a suffix of <b>T</b>. Each leaf vertex is a suffix and the integer value written inside the leaf vertex is the suffix number.</p><br><p>An internal vertex will branch to more than one child vertex, therefore there are more than one suffix from the root to the leaves via this internal vertex. The path label of an internal vertex is a common prefix among those suffix(es).</p>
<hr>
<p>Another pro-tip: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2017). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="1-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>The Suffix Tree above is built from string <b>T</b> = "GATAGACA$" that have these 9 suffixes:</p><table><tr><th><b>i</b></th><th><b>Suffix</b></th></tr><tr><td>0</td><td>GATAGACA$</td></tr><tr><td>1</td><td>ATAGACA$</td></tr><tr><td>2</td><td>TAGACA$</td></tr><tr><td>3</td><td>AGACA$</td></tr><tr><td>4</td><td>GACA$</td></tr><tr><td>5</td><td>ACA$</td></tr><tr><td>6</td><td>CA$</td></tr><tr><td>7</td><td>A$</td></tr><tr><td>8</td><td>$</td></tr></table><p>Now verify that the path labels of suffix 7/6/2 are "A$"/"CA$"/"TAGACA$", respectively (there are 6 other suffixes). The internal vertices with path label "A"/"GA" branch out to 4 suffixes {7, 5, 3, 1}/2 suffixes {4, 0}, respectively (we ignore the trivial internal vertex = root vertex that branches out to all 9 suffixes).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>In order to ensure that every suffix of the input string <b>T</b> ends in a leaf vertex, we enforce that string <b>T</b> ends with a special terminating symbol &#39;$&#39; that is not used in the original string <b>T</b> and has ASCII value lower than the lowest allowable character in <b>T</b> (which is character &#39;A&#39;). This way, edge label &#39;$&#39; always appear at the leftmost edge of an internal vertex of this Suffix Tree visualization.</p><br><p>For the Suffix Tree example above (for <b>T</b> = "GATAGACA$"), if we do not have terminating symbol &#39;$&#39;, notice that suffix 7 "A" does NOT end in a leaf vertex and can complicate some operations later.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2-3" class="electure-dialog" style="top:300px;left:60px;width:500px;">
<p>As we have ensured that all suffixes end at a leaf vertex, there are <i>at most</i> <b>n</b> leaves/suffixes in a Suffix Tree. All internal vertices (including the root vertex if it is an internal vertex) are always branching thus there can be at most <b>n</b>-1 such vertices, as shown with one of the extreme test case on the right.</p><br><p>The maximum number of vertices in a Suffix Tree is thus = <b>n</b> (leaves) + (<b>n</b>-1) internal vertices = <b>2n</b>-1 = O(<b>n</b>) vertices. As Suffix Tree is a tree, the maximum number of edges in a Suffix Tree is also (<b>2n</b>-1)-1 = O(<b>n</b>) edges.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2-4" class="electure-dialog" style="top:210px;left:50%;margin-left:-250px;width:500px;">
<p>When all the characters in string <b>T</b> is all distinct (e.g. <b>T</b> = "ABCDE$"), we can have the following very short Suffix Tree with exactly <b>n</b>+1 vertices (+1 due to root vertex).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3" class="electure-dialog" style="bottom:220px;left:60px;width:500px;">
<p>All available operations on the Suffix Tree in this visualization are listed below:</p><ol><li><b>Build Suffix Tree (instant)</b> &mdash; instant-build the Suffix Tree from string <b>T</b>.</li><li><b>Search</b> — Find the vertex in Suffix Tree of a (usually longer) string <b>T</b> that has path label containing the (usually shorter) pattern/search string <b>P</b>.</li><li><b>Longest Repeated Substring (LRS)</b> — Find the deepest internal vertex (as that vertex shares common prefix between two (or more) suffixes of <b>T</b>).</li><li><b>Longest Common Substring (LCS)</b> — Find the deepest internal vertex that contains suffixes from two different original strings.</li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-1" class="electure-dialog" style="bottom:220px;left:60px;width:500px;">
<p>In this visualization, we only show the fully constructed Suffix Tree <i>without describing the details of the O(<b>n</b>) Suffix Tree construction algorithm</i> &mdash; it is a bit too complicated.</p><br><p>We limit the input to only accept 12 UPPERCASE alphabet and the special terminating symbol &#39;$&#39; characters (ie.g [A-Z$]). If you do not write a terminating symbol &#39;$&#39; at the back of your input string, we will automatically do so. If you place a &#39;$&#39; in the middle of the input string, they will be ignored. And if you enter an empty input string, we will resort to the default "GATAGACA$".</p><br><p>For convenience, we provide a few classic test case input strings usually found in Suffix Tree/Array lectures.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-2" class="electure-dialog" style="bottom:220px;left:60px;width:500px;">
<p>Assuming that the Suffix Tree of a (usually longer) string <b>T</b> (of length <b>n</b>) has been built, we want to find all occurrences of pattern/search string <b>P</b> (of length <b>m</b>).</p><br><p>To do this, we search for the vertex <b>x</b> in the suffix Tree of <b>T</b> which has path label that represents <b>P</b>. Once we find this vertex <b>x</b>, all the leaves in the subtree rooted at <b>x</b> are the occurrences.</p><br><p>Time complexity: O(<b>m+occ</b>) where <b>occ</b> is the total number of occurrences.</p><br><p>For example, on the Suffix Tree of <b>T</b> = "GATAGACA$" above, let&#39;s try finding:</p><ol><li><span class="slide-actions" onclick="doButtonAction115()">Search("A")</span>, occurrences = {7, 5, 3, 1}</li><li><span class="slide-actions" onclick="doButtonAction116()">Search("GA")</span>, occurrences = {4, 0}</li><li><b>P</b> = "T", should return occurrences = {2}, but there is a silly bug that we have not killed yet</li><li><b>P</b> = "Z", should return occurrences = {NIL}, but there is a silly bug that we have not killed yet</li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-3" class="electure-dialog" style="bottom:220px;left:60px;width:500px;">
<p>Assuming that the Suffix Tree of a (usually longer) string <b>T</b> (of length <b>n</b>) has been built, we can find the Longest Repeated Substring (LRS) in <b>T</b> by simply finding the deepest internal vertex of the Suffix Tree of <b>T</b>.</p><br><p>This is because each internal vertex of the Suffix Tree of <b>T</b> branches out to at least two (or more) suffixes, i.e. the path label (common prefix of these suffixes) are <b>repeated</b>.</p><br><p>The internal vertex with the deepest/longest path label is the required answer, which can be found in O(<b>n</b>) with a simple tree traversal.</p><br><p>Without further ado, try <span class="slide-actions" onclick="doButtonAction117()">LRS(T)</span> on the Suffix Tree of string <b>T</b> = "GATAGACA$" above.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-4" class="electure-dialog" style="bottom:220px;left:60px;width:500px;">
<p>This time, we need two input strings <b>T1</b> and <b>T2</b> that terminate with symbol &#39;$&#39;/&#39;#&#39;, respectively. We then create the <b>generalized</b> Suffix Tree of these two strings <b>T1+T2</b>. Then, we can find the Longest Common Substring (LCS) of those two strings <b>T1</b> and <b>T2</b> by simply finding the deepest <b>and valid</b> internal vertex of the generalized Suffix Tree of <b>T1+T2</b>.</p><br><p>This is because each internal vertex of the Suffix Tree of <b>T</b> branches out to at least two (or more) suffixes, i.e. the path label (common prefix of these suffixes) are <b>repeated</b>. Then, we add an additional constraint where an internal vertex is considered valid (to be considered as LCS candidate) only if it represents suffixes from <b>both strings</b>, i.e. not just <b>repeated</b>, but a <b>common</b> substring found in both <b>T1</b> and <b>T2</b>.</p><br><p>The valid internal vertex with the deepest/longest path label is the required answer, which can be found in O(<b>n</b>) with a simple tree traversal.</p><br><p>Without further ado, try <span class="slide-actions" onclick="doButtonAction118()">LCS(T1,T2)</span> on the generalized Suffix Tree of string <b>T1</b> = "GATAGACA$" and <b>T2</b> = "CATABB#" (notice that the UI will change to generalized Suffix Tree version).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>There are a few other things that we can do with Suffix Tree like "Finding Longest Repeated Substring without overlap", "Finding Longest Common Substring of &ge; 2 strings", etc, but we will keep that for later.</p><br><p>We will continue the discussion of this String-specific data structure with the more versatile to <a href="suffixarray.html"><u>Suffix Array</u></a> data structure.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99" class="electure-dialog" style="right:150px;bottom:335px;width:500px;">
<p>As the action is being carried out, each step will be described in the status panel.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-1" class="electure-dialog" style="right:170px;bottom:275px;width:180px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-2" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-120px;width:260px;">
<p>Control the animation with the player controls! Keyboard shortcuts are:<br></p><div style="margin-top: 8px;"><strong>Spacebar:</strong> play/pause/replay</div><strong>Left/right arrows:</strong> step backward/step forward<br><strong>-/+:</strong> decrease/increase speed<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-3" class="electure-dialog" style="top:70px;right:60px;width:300px;">
<p>Return to &#39;Exploration Mode&#39; to start exploring!</p><br><p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99-2">Trước đó <u>PgUp</u></div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="actions" class="panel">
<p id="build">Build Suffix Tree (instant)</p>
<p id="search">Tìm kiếm</p>
<p id="LRS" class="execAction" onclick="goLRS()">Longest Repeated Substring</p>
<p>========================</p>
<p id="LCS">Longest Common Substring</p>
</div>
<div id="actions-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide actions panel" /></div>
<div id="actions-extras">
<div class="build action-menu-pullout">
<div id="build-example1" class="execAction new-menu-option coloured-menu-option" onclick="$('#arrv1').val('GATAGACA$'); buildSuffixTree();"><p>GATAGACA$</p></div>
<div id="build-example2" class="execAction new-menu-option coloured-menu-option" onclick="$('#arrv1').val('BANANA$'); buildSuffixTree();"><p>BANANA$</p></div>
<div id="build-example3" class="execAction new-menu-option coloured-menu-option" onclick="$('#arrv1').val('MISSISSIPPI$'); buildSuffixTree();"><p>MISSISSIPPI$</p></div>
<div id="build-example4" class="execAction new-menu-option coloured-menu-option" onclick="$('#arrv1').val('AAAAAAA$'); buildSuffixTree();"><p>AAAAAAA$</p></div>
<div id="build-input" class="new-menu-option"><input type="text" id="arrv1" autocomplete="off" onkeyup="this.value = this.value.replace(/[^A-Z$]/, '')" value="CUSTOMSTR$" maxlength="12"></div>
<div id="build-go" class="execAction coloured-menu-option" onclick="buildSuffixTree()"><p>Go</p></div>

</div>
<div class="search action-menu-pullout">
<div id="search-input" class="new-menu-option"><input type="text" id="search_inp" autocomplete="off" value="GA" maxlength="12"></div>
<div id="search-go" class="execAction coloured-menu-option" onclick="goSearch()"><p>Go</p></div>
<div id="search-err" class="err"></div>
</div>
<div class="lrs action-menu-pullout">
<div id="lrs-err" class="err"></div>
</div>
<div class="lcs action-menu-pullout">
<div id="lcs-input" class="new-menu-option"><input type="text" id="s1" autocomplete="off" value="GATAGACA$" style="border-right: 1px solid #777;" maxlength="12"><input type="text" id="s2" autocomplete="off" value="CATABB#" maxlength="12"></div>
<div id="lcs-go" class="execAction coloured-menu-option" onclick="goLCS()"><p>Build Generalized ST and Compute LCS</p></div>
<div id="lcs-err" class="err"></div>
</div>
</div>
<div id="bottom-bar">
<a id="trigger-about">Về</a>
<a id="trigger-team">Nhóm</a>
<a id="trigger-terms">Điều khoản sử dụng</a>
</div>
<div id="about" class="overlays">
<h4>Về</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
VisuAlgo được lên ý tưởng vào năm 2011 bởi tiến sĩ Steven Halim như là một công cụ để giúp những sinh viên của ông ấy có thể hiểu rõ hơn về các cấu trúc dữ liệu và thuật toán, bằng cách cho phép họ tự học những nội dung cơ bản nhất với tiến độ phù hợp với riêng họ.<br>VisuAlgo chứa rất nhiều thuật toán nâng cao đã được thảo luận trong cuốn sách của Tiến sĩ Steven Halim (&#39;Competitive Programming&#39;, đồng tác giả với anh trai của ông ấy, tiến sĩ Felix Halim) và hơn thế nữa. Hiện tại, một số mô phỏng/hiệu ứng hoạt hình của các thuật toán nâng cao này chỉ có thể tìm thấy ở VisuAlgo.<div>Mặc dù được thiết kế đặc biệt cho những sinh viên đại học quốc gia Singapore (phải học rất nhiều môn học về cấu trúc dữ liệu và thuật toán - ví dụ: CS1010, CS1020, CS2010, CS2020, CS3230, and CS3230), như những người ủng hộ việc học trực tuyến, chúng tôi hi vọng rằng những người quan tâm tới cấu trúc dữ liệu và thuật toán trên toàn thế giới cũng có thể thấy những mô tả này là hữu dụng.<br>Ngay từ đầu, VisuAlgo không được thiết kế để làm việc tốt trên những màn hình cảm ứng nhỏ (ví dụ như smartphones) do việc mô phỏng các thuật toán phức tạp cần rất nhiều điểm ảnh và cử chỉ nhấp và kéo để tương tác. Độ phân giải màn ảnh nhỏ nhất cho trải nghiệm người dùng chấp nhận được là 1024x768 và chỉ có duy nhất trang đích là tương đối thân thiện với bản di động.</div><div>VisuAlgo là một dự án liên tục và nhiều mô phỏng phức tạp vẫn đang được phát triển.<br>Cải tiến thú vị nhất là tạo và duyệt câu hỏi tự động (hệ thống câu hỏi trực tuyến) cho phép sinh viên kiểm tra kiến thức cơ bản về các cấu trúc dữ liệu và thuật toán. Các câu hỏi được tạo ngẫu nhiên thông qua những quy luật và câu trả lời của sinh viên sẽ được chấm điểm tự động và ngay lập tức dựa trên việc nộp bài tới server chấm điểm của chúng tôi. Hệ thống câu hỏi trực tuyến này, khi mà nó được chấp nhận bởi nhiều giảng viên CS trên toàn thế giới, sẽ xóa bỏ mặt kĩ thuật các câu hỏi về cấu trúc dữ liệu và thuật toán cơ bản khỏi các kỳ thi khoa học máy tính điển hình tại rất nhiều trường đại học. Bằng cách đặt một tiêu chí chấm điểm nhỏ (nhưng khác 0) vào việc vượt qua các câu hỏi trực tuyến, giảng viên CS có thể làm tăng (một cách đáng kể) sự thành thạo của những sinh viên trên những câu hỏi cơ bản này khi họ một lượng vô số các câu hỏi thực tế cho sự luyện tập cái mà có thể được kiểm chứng ngay lập tức trước khi họ làm câu hỏi trực tuyến. Hiện tại, chế độ hướng dẫn bao gồm các câu hỏi cho 12 module mô phỏng. Chúng tôi sẽ sớm thêm vào 8 module mô phỏng còn lại để cho tất cả các module mô phỏng ở VisuAlgo đều có phần câu hỏi trực tuyến.<br>Một cải tiến hấp dẫn khác là việc quốc tế hóa các dự án nhánh của VisuAlgo. Chúng tôi muốn chuẩn bị cơ sở dữ liệu các thuật ngữ CS cho các văn bản tiếng Anh đã từng xuất hiện trên hệ thống VisuAlgo. Đây là một nhiệm vụ lớn và cần điện toán đám đông. Một khi hệ thống đã sẵn sàng, chúng tôi sẽ mời người dùng VisuAlgo đóng góp, đặc biệt là khi bạn không phải là người nói tiếng Anh bản ngữ. Hiện tại, chúng tôi cũng đang viết những ghi chú về VisuAlgo bằng những ngôn ngữ khác nhau.<br></div>
<a href="https://weibo.com/p/230418436e9ee80102v4rk" target='_blank'><u>zh</u></a>, <a href='https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689' target='_blank'><u>id</u></a>, <a href="https://blog.naver.com/visualgo_nus" target='_blank'><u>kr</u></a>, <a href='https://www.facebook.com/groups/163215593699283/permalink/824003417620494/' target='_blank'><u>vn</u></a>, <a href='http://pantip.com/topic/32736343' target='_blank'><u>th</u></a>.</p>
</div>
</div>
<div id="team" class="overlays">
<h4>Nhóm</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
<p>
<strong><span style='line-height: 150%;'>Trưởng dự án và cố vấn (từ tháng 7/2011 đến nay)</span></strong><br>
<a href='http://www.comp.nus.edu.sg/~stevenha/' target='_blank'>Dr Steven Halim</a>, Senior Lecturer, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href='http://felix-halim.net/' target='_blank'>Dr Felix Halim</a>, Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style='line-height: 150%;'>Những nhà nghiên cứu sinh viên 1 (Jul 2011-Apr 2012)</span></strong><br>
Koh Zi Chun, <a href='http://roticv.rantx.com/' target='_blank'>Victor Loh Bo Huai</a>
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 1 (Jul 2012-Dec 2013)</span></strong><br>
Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 2 (Jun 2013-Apr 2014)</span></strong><br>
<a href='http://www.rosemarietan.com/' target='_blank'>Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style='line-height: 150%;'>Những nhà nghiên cứu sinh viên 2 (May 2014-Jul 2014)</span></strong><br>
Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 3 (Jun 2014-Apr 2015)</span></strong><br>
Erin Teo Yi Ling, Wang Zi
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 4 (Jun 2016-Dec 2017)</span></strong><br>
Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir
</p>
<p>
List of translators who have contributed &ge;100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style='line-height: 150%;'>Lời cảm ơn</span></strong><br>
This project is made possible by the generous <a href="http://www.cdtl.nus.edu.sg/teg/" target="_blank">Teaching Enhancement Grant</a> from NUS Centre for Development of Teaching and Learning (CDTL).
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Điều khoản sử dụng</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
VisuAlgo miễn phí đối với cộng đồng Khoa học Máy tính trên toàn thế giới. Nếu bạn yêu thích VisuAlgo, khoản chi phí duy nhất mà chúng tôi muốn bạn chi trả chính là hãy nói cho những <b>sinh viên/ giảng viên ngành khoa học máy tính</b> mà bạn biết<b> về sự tồn tại của VisuAlgo</b> =) thông qua Facebook, Twitter, trang web về khóa học, blog review, email , v.v &amp; v.v. Nếu bạn là một<b> sinh viên/ giảng viên</b> ngành cấu trúc dữ liệu và thuật toán, bạn được phép sử dụng website này một cách trực tiếp trong các lớp học của bạn. Nếu bạn lấy những ảnh chụp màn hình (videos) từ website này, bạn có thể sử dụng chúng ở bất kỳ đâu, miễn là có dẫn nguồn URL của website này (http://visualgo.net) và/hoặc liệt kê các công bố ở dưới như là tài liệu tham khảo. Tuy nhiên, bạn <b>KHÔNG</b> được phép tải xuống các tập tin VisuAlgo (phía máy trạm) và lưu trữ nó ở website riêng của bạn vì nó được coi là <b>đạo ý tưởng</b> .Hiện tại, chúng tôi <b>KHÔNG</b> cho phép những người khác chia nhỏ dự án này và tạo ra những phiên bản khác của VisuAlgo. Việc sử dụng bản sao ngoại tuyến của VisuAlgo (phía máy trạm) cho mục đích cá nhân của bạn thì có thể chấp nhận được.<br>Lưu ý rằng hệ thống câu hỏi trực tuyến của VisuAlgo có phần dữ liệu phía máy chủ rất lớn và không dễ dàng để lưu lại mã kịch bản phía máy chủ và cơ sở dữ liệu một cách cục bộ. Hiện tại, mọi người chỉ có thể sử dụng "chế độ đào tạo" để truy cập hệ thống câu hỏi trực tuyến này. Chế độ kiểm tra hiện là môi trường có kiểm soát hơn cho việc sử dụng những câu hỏi được tạo ngẫu nhiên này và tự động kiểm duyệt cho kỳ thi <b>thật sự</b> tại Đại học Quốc gia Singapore<span style="white-space: normal;">.</span> Những giảng viên quan tâm tới khoa học máy tính có thể liên hệ với Steven nếu muốn trải nghiệm "chế độ kiểm tra"<br><b>Danh sách phát hành</b><br>Dự án này đươc trình bày một cách vắn tắt ở Hội thảo CLI tại ACM ICPC World Finals 2012 (Warsaw, Ba Lan) và tại Hội nghị IOI 2012 (Sirmione-Montichiari, Italy). Bạn có thể nhấn vào link này để đọc bài viết năm 2012 của chúng tôi về hệ thống này (nó không được gọi là VisuAlgo vào năm 2012)<br>Dự án này được hoàn thiện hầu hết bởi những cựu sinh viên của tôi. Báo cáo cuối cùng gần đây nhất là của: <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/erin-report.pdf" target="_blank">Erin</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/wangzi-report.pdf" target="_blank">Wang Zi</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/rose-report.pdf" target="_blank">Rose</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/ivan-report.pdf" target="_blank">Ivan</a>.<br><b>Báo cáo lỗi hoặc đề xuất tính năng mới</b><br>VisuAlgo là một dự án chưa hoàn thiện. Tiến sĩ Steven Halim vẫn đang tiếp tục phát triển VisuAlgo một cách tích cực/ Nếu bạn đang sử dụng VisuAlgo và phát hiện ra lỗi ở bất kỳ trang mô phỏng/ công cụ câu hỏi trực tuyến nào của chúng tôi hoặc nếu bạn muốn đề xuất những tính năng mới, hãy liên lạc với Tiến sĩ Steven Halim. Địa chỉ liên lạc của ông ấy là stevenhalim@gmail.com<br>
</div>
</div>

<script src="../js/jquery-3.3.1.min.js"></script>
<script>
      var PHP_DOMAIN = "";

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        //setTimeout(function() {
          if (retval) { // mode == "exploration" && // now not only for exploration mode, but check if this opens other problems
            $('#current-action').show();
            $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
            $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
            triggerRightPanels();
            isPlaying = true;
          }
        //}, 500);
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; i++) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.right-links').css('background', surpriseColour);
        $('#login-go').css('background', surpriseColour);

        $('.colour').css("color", surpriseColour); // name
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
          // temporary quick fix for Google Chrome Aug 2016 issue...
          setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 100); // force resize/redraw...
          setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        });

        // overlays stuffs
        $('#trigger-about').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#about').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('#trigger-team').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#team').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('#trigger-terms').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#termsofuse').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('.close-overlay').click(function() {
          $('.overlays').fadeOut(function() {
            $('#dark-overlay').fadeOut();
          });
        });

        $('#dark-overlay').click(function() {
          $('.overlays').fadeOut();
          $('#dark-overlay').fadeOut();
        });

        $.get('/isloggedin', function(data) {
          var isLoggedIn = data['isloggedin'] == '1';
          var element;
          if (isLoggedIn) {
            // element = '<a onclick="verifyLogout()">Đăng Xuất<div><br></div></a>';
            element = '<a href="https://visualgo.net/profile">Profile</a>'; 
          }
          else {
            element = '<a href="https://visualgo.net/login">Đăng nhập</a>'
          }
          $('#useraccount').html(element);
        });
      });

      function verifyLogout() {
        // Steven's remarks: use a better 'confirm' than the default :(
        var doesLogout = confirm('Are you sure to logout?');
        if (doesLogout == true) {
          window.location = "https://visualgo.net/logout";
        }
      }

      function checkLogin() {
        $.get('/checklogin', function(data) {
          var url = data['url'];
          window.location.href = '/' + url;
        });
      }

      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','../../www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-1566631-4', 'auto');
      ga('send', 'pageview');
    </script>

<script src="../js/jquery-ui.min.js"></script>

<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.3.js"></script>
<script src="../js/visualgo_print.js"></script>
<script src="../js/graph_library.js"></script>
<script>
      function runSlide(slide) {
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 5 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '1-1') {
          $("#e-lecture").html("slide " + slide + " (" + 11 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 17 + "%)");
          $("#arrv1").val("GATAGACA$");
buildSuffixTree();
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-1') {
          $("#e-lecture").html("slide " + slide + " (" + 23 + "%)");
          $("#arrv1").val("GATAGACA$");
buildSuffixTree();
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-2') {
          $("#e-lecture").html("slide " + slide + " (" + 29 + "%)");
          $("#arrv1").val("GATAGACA$");
buildSuffixTree();
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-3') {
          $("#e-lecture").html("slide " + slide + " (" + 35 + "%)");
          $("#arrv1").val("AAAAAAA$");
buildSuffixTree();
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-4') {
          $("#e-lecture").html("slide " + slide + " (" + 41 + "%)");
          $("#arrv1").val("ABCDE$");
buildSuffixTree();
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 47 + "%)");
          
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-1') {
          $("#e-lecture").html("slide " + slide + " (" + 52 + "%)");
          $("#build").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-2') {
          $("#e-lecture").html("slide " + slide + " (" + 58 + "%)");
          $("#search").click().addClass("menu-highlighted");
$("#arrv1").val("GATAGACA$");
buildSuffixTree();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-3') {
          $("#e-lecture").html("slide " + slide + " (" + 64 + "%)");
          closeBuild();
closeSearch();
closeLCS();
$("#LRS").addClass("menu-highlighted");
$("#arrv1").val("GATAGACA$");
buildSuffixTree();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-4') {
          $("#e-lecture").html("slide " + slide + " (" + 70 + "%)");
          $("#LCS").addClass("menu-highlighted");
$("#arrv1").val("GATAGACA$");
buildSuffixTree();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 76 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99') {
          $("#e-lecture").html("slide " + slide + " (" + 82 + "%)");
          
          hideEntireActionsPanel();
 
          showStatusPanel();
          showCodetracePanel();
      
        }
        if (slide == '99-1') {
          $("#e-lecture").html("slide " + slide + " (" + 88 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99-2') {
          $("#e-lecture").html("slide " + slide + " (" + 94 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99-3') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };

      function pushState(slideValue) {
        var url = '/vi/suffixtree';
        if (typeof slideValue != 'undefined' && slideValue != null) url += '?slide=' + slideValue;
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5); 
        $('#overlay').show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      $(function() {
        var slide = getUrlParameter('slide');
        
        $.get('/hasvisited' + '/suffixtree', function(data) {
          var hasVisited = data['hasvisited'] == '1';
          if (!hasVisited) {
            var postData = {
              '_token': 'iVivZ7KRPe6XK7pbuGtOoEjljE1xyBVNhLKNFuF8',
              'page': '/suffixtree'.substring(1),
            };

            $.post("/visitpage", postData, function(data) {
              // non critical request...
            });

            if (typeof slide != undefined && slide != null) {
              cur_slide = slide;
            }

            $("#mode-menu a").trigger("click");
          }
          else {
            if (typeof slide != undefined && slide != null) {
              cur_slide = slide;
              $('#mode-menu a').click();
            }    
          }
        }).fail(function() {
          if (typeof slide != undefined && slide != null) {
            cur_slide = slide;
            $('#mode-menu a').click();
          }
        });

        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
      
        $('#electure-1-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-1-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
      
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
      
        $('#electure-2-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2-2');
          pushState('2-2');
        });
        $('#electure-2-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
      
        $('#electure-2-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2-3');
          pushState('2-3');
        });
        $('#electure-2-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
      
        $('#electure-2-3 .electure-next').click(function() {
          hidePopup();
          runSlide('2-4');
          pushState('2-4');
        });
        $('#electure-2-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-2');
          pushState('2-2');
        });
      
        $('#electure-2-4 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-3');
          pushState('2-3');
        });
      
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-4');
          pushState('2-4');
        });
      
        $('#electure-3-1 .electure-next').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
        $('#electure-3-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
      
        $('#electure-3-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
        $('#electure-3-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
      
        $('#electure-3-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
        $('#electure-3-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
      
        $('#electure-3-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
      
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('99');
          pushState('99');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
      
        $('#electure-99 .electure-next').click(function() {
          hidePopup();
          runSlide('99-1');
          pushState('99-1');
        });
        $('#electure-99 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
      
        $('#electure-99-1 .electure-next').click(function() {
          hidePopup();
          runSlide('99-2');
          pushState('99-2');
        });
        $('#electure-99-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('99');
          pushState('99');
        });
      
        $('#electure-99-2 .electure-next').click(function() {
          hidePopup();
          runSlide('99-3');
          pushState('99-3');
        });
        $('#electure-99-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('99-1');
          pushState('99-1');
        });
      
        $('#electure-99-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('99-2');
          pushState('99-2');
        });
      
 

        // temporary quick fix for Google Chrome Aug 2016 issue..., put at last part so that everything else has been loaded
        // setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 500);
        // setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        // I turn it off on 14 June 2018, seems 'ok'?
      });

      function doButtonAction115() {
        $("#search_inp").val("A");
goSearch();
      }
      function doButtonAction116() {
        $("#search_inp").val("GA");
goSearch();
      }
      function doButtonAction117() {
        goLRS();
      }
      function doButtonAction118() {
        goLCS();
      }

      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();  
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url.html) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}
    </script>
<script>
// Suffix Tree Widget
// original author: Nguyen Hoang Duy, then maintained by Steven Halim

var SuffixTreeWidget = function() {
  var self = this;
  var graphWidget = new GraphWidget();

  var coord = new Array();
  var A = new Array();
  var amountVertex = 0;
  var amountEdge = 0;

  var stateList = [];
  var edgeGenerator = d3.svg.line()
  .x(function(d){return d.x;})
  .y(function(d){return d.y;})
  .interpolate("linear");
  var mousedown_node = null;
  var mousemove_coor = null;
  var edgeList = [];
  var mousedown_in_progress = false, mousemove_in_progress = false, mouseup_in_progress = false;
  var mousedown_event = null, mousemove_event = null, mouseup_event = null;
  var deleted_vertex_list = [];
  var used_alt = -1;
  var adjMatrix = [], adjList = [];
  var edgeId = 0;

  var Txt='',    // the input text string
    root=null, // root of the suffix tree
    infinity;  // quite a big number
    nForks=0;  // number of branching nodes in the suffix tree
    width = 50;
    height = 30;
    height_offset = 18;
  var suffix_table = new Array(), reverse_suffix_table = new Array();
  var height_level = new Array();
  var draw_data = new Array();
  var processQueue = new Array();
  var fromResultNode = null, toResultNode = null;
  var foundResult = false;
  var cur_LRS_max = '', old_LRS_max ='';
  var LRSMax;
  var LRSMaxEqual = new Array();
  var currentColorNode = -1, currentColorElem = -1;
  var saveEdge = 0;
  var isCanvasClear = true;
  var maxX = 0, maxY = 0;

  mainSvg.style("class", "unselectable");
  mainSvg.attr("height", window.innerHeight-80);
  mainSvg.attr("width", window.innerWidth);
  
  $( window ).resize(function() {
  mainSvg.attr("height", window.innerHeight-80);
  mainSvg.attr("width", window.innerWidth);
  });
  
  var projection = d3.geo.albersUsa()
    .scale(1070)
    .translate([MAIN_SVG_WIDTH / 2, MAIN_SVG_HEIGHT / 2]);

  var path = d3.geo.path()
      .projection(projection);

  mainSvg.append("rect")
    .attr("class", "background")
    .attr("width", MAIN_SVG_WIDTH)
    .attr("height", MAIN_SVG_HEIGHT)
    .on("click", clicked);

  var g = mainSvg.append("g");

  function getCircleLineIntersectionPoint(x1, y1, x2, y2, r, cx, cy) {
    var baX = x2 - x1; //pointB.x - pointA.x;
    var baY = y2 - y1; //pointB.y - pointA.y;
    var caX = cx - x1; //center.x - pointA.x;
    var caY = cy - y1; //center.y - pointA.y;

    var a = baX * baX + baY * baY;
    var bBy2 = baX * caX + baY * caY;
    var c = caX * caX + caY * caY - r * r;

    var pBy2 = bBy2 / a;
    var q = c / a;
    
    var disc = pBy2 * pBy2 - q;
    var tmpSqrt = Math.sqrt(disc);
    var abScalingFactor1 = -pBy2 + tmpSqrt;
    var abScalingFactor2 = -pBy2 - tmpSqrt;

    var r_x1 = x1 - baX * abScalingFactor1;
    var r_y1 = y1 - baY * abScalingFactor1
    //Point p1 = new Point(pointA.x - baX * abScalingFactor1, pointA.y
    //      - baY * abScalingFactor1);
    var r_x2 = x1 - baX * abScalingFactor2;
    var r_y2 = y1 - baY * abScalingFactor2

    //Point p2 = new Point(pointA.x - baX * abScalingFactor2, pointA.y
    //       - baY * abScalingFactor2);
    var res = new Array();
    res[0] = r_x1; 
    res[1] = r_y1;
    res[2] = r_x2;
    res[3] = r_y2 ;
    return res;
  }

  function moveCircle(x, y, class_id) {
    mainSvg.selectAll(".v" + class_id)
    .attr("cx", x)
    .attr("cy", y);
    
    
    var b = mainSvg.selectAll(".v" + class_id);
    b[0] = b[0].splice(2,1);
    b.attr("y", y + 3);
    b.attr("x", x);
  
    for (var i=1; i <= Object.size(edgeList); i++) {
      var e = edgeList["#e" + i.toString()];
      if (typeof(e) == "undefined") continue;
      if (e[0] == class_id || e[1] == class_id)
        moveWeightedText(i);
    }     
  }

  function calculateEdge(x1, y1, x2, y2) {
    var pts = getCircleLineIntersectionPoint(x1, y1, x2, y2, 15, x1, y1);
    var pts2 = getCircleLineIntersectionPoint(x1, y1, x2, y2, 15, x2, y2);
    var min = 5000;
    var save1 = 0, save2 = 0;
    for (var i=1; i<=3; i+=2) 
      for (var j=1; j<=3; j+=2) 
      {
        var d = Math.sqrt((pts[i-1]-pts2[j-1])*(pts[i-1]-pts2[j-1]) + (pts[i] - pts2[j])*(pts[i] - pts2[j]));
        if (d < min) {
          min = d;
          save1 = i; save2 = j;
        }
      }
      
      var beginPoint = {"x": pts[save1-1], "y": pts[save1]};
      var endPoint = {"x": pts2[save2-1], "y": pts2[save2]};

      return [beginPoint, endPoint];
    }

  // ax + by = c
  // return coordinate of intersection point
  // if parallel, return [-1,-1]
  function getLinesIntersection(a1, b1, c1, a2, b2, c2) {
    if (a1*b2 - a2*b1 == 0) return [-1, 1];
    return [(c1*b2 - b1*c2)/(a1*b2 - b1*a2), (a1*c2 - c1*a2)/(a1*b2 - b1*a2)];
  }

  // return distance from (x, y) to ax + by + c = 0
  function getDistancePointToLine(x, y, a, b, c) {    
    return (Math.abs(a*x + y*b + c))/Math.sqrt(a*a + b*b);
  }

  // x1 is the origin
  function getStraightLineCoordinate(x1, y1, x2, y2) {
    // intersection with x - y - x1 + y1 = 0
    var intersection = getLinesIntersection(1, 1, x2 + y2, 1, -1, x1 - y1);
    var min = getDistancePointToLine(x2, y2, 1, -1, -x1 + y1);
    var save = intersection;
    // intersection with x + y - x1 - y1 = 0
    intersection = getLinesIntersection(-1, 1, -x2 + y2, 1, 1, x1 + y1);
    var dist = getDistancePointToLine(x2, y2, 1, 1, -x1 - y1);
    if (min > dist) {
      min = dist;
      save = intersection;
    }
    // intersection with x - x1 = 0
    intersection = getLinesIntersection(0, 1, y2, 1, 0, x1);
    dist = getDistancePointToLine(x2, y2, 1, 0, -x1);
    if (min > dist) {
      min = dist;
      save = intersection;
    }
    // intersection with y - y1 = 0
    intersection = getLinesIntersection(-1, 0, -x2, 0, 1, y1);
    dist = getDistancePointToLine(x2, y2, 0, 1, -y1);
    if (min > dist) {
      min = dist;
      save = intersection;
    }
    return save;
  }

  this.getGraphWidget = function() { return graphWidget; }
  
  this.getAmountVertex = function() {
    return amountVertex;
  }

  this.getAmountEdge = function() {
    return amountEdge;
  }

  function dist2P(x1, y1, x2, y2) {
    return Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
  }

  // return the circle class id if is inside the circle
  // return -1 if free
  function isUsed(x,y) {
    var i,j;
    for (i=1; i<amountVertex; i++) {
      if (dist2P(x, y, coord[i][0], coord[i][1]) <= 35)
       return i;
   }
   return -1;
  }

  function resetEverything() {
    coord = new Array();
    A = new Array();
    amountVertex = 0;
    amountEdge = 0;

    stateList = [];
    edgeGenerator = d3.svg.line()
    .x(function(d){return d.x;})
    .y(function(d){return d.y;})
    .interpolate("linear");
    mousedown_node = null;
    mousemove_coor = null;
    edgeList = [];
    mousedown_in_progress = false, mousemove_in_progress = false, mouseup_in_progress = false;
    mousedown_event = null, mousemove_event = null, mouseup_event = null;
    deleted_vertex_list = [];
    used_alt = -1;
    adjMatrix = [], adjList = [];
    edgeId = 0;

    Txt='',    // the input text string
    root=null, // root of the suffix tree
    infinity;  // quite a big number
    nForks=0;  // number of branching nodes in the suffix tree
    width = 50;
    height = 30;
    height_offset = 18;
    suffix_table = new Array(), reverse_suffix_table = new Array();
    height_level = new Array();
    draw_data = new Array();
    processQueue = new Array();
    fromResultNode = null, toResultNode = null;
    foundResult = false;
    cur_LRS_max = '', old_LRS_max ='';
    LRSMax;
    LRSMaxEqual = new Array();
    currentColorNode = -1, currentColorElem = -1;
    saveEdge = 0;
    isCanvasClear = true;
    maxX = 0, maxY = 0;
  }

  function clearScreen() {
    var i;

    // remove edges first
    for (i = 1; i <= amountEdge; i++){
      graphWidget.removeEdge(i);
    }

    // remove vertices after removing edges
    for (i = 1; i < amountVertex; i++){
      graphWidget.removeVertex(A[i].getSecond());
    }
    try {
      graphWidget.removeVertex(0);
    } catch (err) {}

    mainSvg.selectAll(".edgelabel").remove();
    mainSvg.selectAll("text").remove();
    amountVertex = 0;
    resetEverything();
  }  

  // Javascript addon: get size of an object
  Object.size = function(obj) {
    var size = 0, key;
    for (key in obj) {
      if (obj.hasOwnProperty(key)) size++;
    }
    return size;
  };

  function addIndirectedEdge(vertexClassA, vertexClassB, edgeIdNumber, type, weight, show) {
    graphWidget.addEdge(vertexClassA, vertexClassB, edgeIdNumber, type, weight, show);
    var edgeId = "#e" + edgeIdNumber.toString();
    edgeList[edgeId.toString()] = [vertexClassA, vertexClassB];
  }

  function createAdjMatrix() {
    var vertex_count = getNextVertexId() - 1;
    adjMatrix = new Array(vertex_count);
    for (var i = 0; i < vertex_count; i++) {
      adjMatrix[i] = new Array(vertex_count);
      for (var j=0; j < vertex_count; j++)
        adjMatrix[i][j] = 0;
    }

    var tmp = "#e";
    for (var i=1; i <= Object.size(edgeList); i++) {
      var edge_id = tmp + i.toString();
      if (mainSvg.select(edge_id).attr("style"))
        if (mainSvg.select(edge_id).attr("style").indexOf("hidden") != -1) continue;
      var from_vertex_id = edgeList[edge_id][0];
      var target = mainSvg.selectAll(".v" + from_vertex_id.toString());
      var from_vertex_content = target[0][2].textContent;

      var to_vertex_id = edgeList[edge_id][1];
      if (from_vertex_id == to_vertex_id) continue;

      target = mainSvg.selectAll(".v" + to_vertex_id.toString());
      var to_vertex_content = target[0][2].textContent;       

      if (document.getElementById("weighted_checkbox").checked) {
        var weight = document.getElementById("w_e"+ i.toString());
        adjMatrix[parseInt(from_vertex_content)][parseInt(to_vertex_content)] = (weight == null) ? 1 : weight.textContent;
        if (!document.getElementById("direct_checkbox").checked) 
          adjMatrix[parseInt(to_vertex_content)][parseInt(from_vertex_content)] = (weight == null) ? 1 : weight.textContent;       
      } else {
        adjMatrix[parseInt(from_vertex_content)][parseInt(to_vertex_content)] = 1;        
        if (!document.getElementById("direct_checkbox").checked) 
          adjMatrix[parseInt(to_vertex_content)][parseInt(from_vertex_content)] = 1;           
      }
    }
    var xv = 1;
    drawAdjMatrix();
  }

  function pair(a, b) { this.fst = a; this.snd = b; } // i.e. <fst, snd>
// NB. most of Ukkonen's functions return a pair (s,w)


  function isEmptyStrng() { return this.right < this.left; }

  function Strng(left, right) // represents Txt[left..right]
  { this.left=left; this.right=right;
   this.isEmpty = isEmptyStrng;
  }//constructor


  function addTrnstn(left, right, s) // this['a'] >---(left..right)---> s
  // add a transition to `this' state
  { this[Txt.charAt(left)] = new pair(new Strng(left,right), s);
   this.isLeaf = false;
  }

  function State() // i.e. a new leaf node in the suffix tree
  { this.addTransition = addTrnstn; this.isLeaf = true; }

  function Node(word, x, y) {
    this.word = word;
    this.x = x;
    this.y = y;
  }

  function stringCmp(a, b) {
    for (var i=0; i<Math.min(a.length, b.length); i++) {
      if (a[i] < b[i]) return 1;
      else if (a[i] > b[i]) return -1;
    }
    if (a.length == b.length) return 0;
    else if (a.length > b.length) return -1;
    return 1;
  }

  function Node2(word, index) {
    this.word = word;
    this.index = index;
  }

  function Node3(word, suffix_index, parent_index, x, y, path_label, class_id, color)  {
    this.word = word;
    this.suffix_index = suffix_index;
    this.parent_index = parent_index;
    this.x = x;
    this.y = y;
    this.path_label = path_label;
    this.class_id = class_id;
    if (typeof(color)=='undefined') this.color = 'black';
    else this.color = color;
  }

  function Node4(path_label, node_label,  x, y, match_flag) {
    this.path_label = path_label;
    this.node_label = node_label;
    this.x = x;
    this.y = y;
    this.match_flag = match_flag;
  }

  function NodeLRS(path_label, x, y, is_leaf) {
    this.path_label = path_label;
    this.x = x;
    this.y = y;
    this.is_leaf = is_leaf;
  }

  function NodeG(prev_x, isString1, isString2) {
    this.prev_x = prev_x;
    this.isString1 = isString1;
    this.isString2 = isString2;
  }
 
  function upDate(s, k, i)                                                   
  // (s, (k, i-1)) is the canonical reference pair for the active point         
  { 
    var oldr = root;                                                        
    var endAndr = test_and_split(s, k, i-1, Txt.charAt(i))                  
    var endPoint = endAndr.fst; var r = endAndr.snd                         
                                                                           
    while (!endPoint)                                                       
    { r.addTransition(i, infinity, new State());                           
      if (oldr != root) oldr.sLink = r;                                    
                                                                           
      oldr = r;
      var sAndk = canonize(s.sLink, k, i-1)                                
      s = sAndk.fst; k = sAndk.snd;                                        
      endAndr = test_and_split(s, k, i-1, Txt.charAt(i))                   
      endPoint = endAndr.fst; r = endAndr.snd;                             
    }                                                                      
                                                                           
    if(oldr != root) oldr.sLink = s;                                       

    return new pair(s, k);
  }//upDate


  function test_and_split(s, k, p, t) { 
    if(k<=p)                                                                
    { // find the t_k transition g'(s,(k',p'))=s' from s                  
      // k1 is k'  p1 is p'                                                
      var w1ands1 = s[Txt.charAt(k)];          // s --(w1)--> s1            
      var s1 = w1ands1.snd;                                               
      var k1 = w1ands1.fst.left;  var p1 = w1ands1.fst.right;

      if (t == Txt.charAt(k1 + p - k + 1))
         return new pair(true, s);
      else
       { var r = new State()
         s.addTransition(k1, k1+p-k,   r);     // s ----> r ----> s1
         r.addTransition(    k1+p-k+1, p1, s1);
         return new pair(false, r)
       }
    }
    else // k > p;  ? is there a t-transition from s ?
    return new pair(s[t] != null, s);
  }//test_and_split


  function canonize(s, k, p) { 
    if(p < k) return new pair (s, k);

     // find the t_k transition g'(s,(k',p'))=s' from s
     // k1 is k',  p1 is p'
     var w1ands1 = s[Txt.charAt(k)];                            // s --(w1)--> s1
     var s1 = w1ands1.snd;
     var k1 = w1ands1.fst.left;  var p1 = w1ands1.fst.right;

     while(p1-k1 <= p-k)                               // s --(w1)--> s1 ---> ...
      { k += p1 - k1 + 1;                    // remove |w1| chars from front of w
        s = s1;
        if(k <= p)
         { w1ands1 = s[Txt.charAt(k)];                          // s --(w1)--> s1
           s1 = w1ands1.snd;
           k1 = w1ands1.fst.left; p1 = w1ands1.fst.right;
         }
       }
      return new pair(s, k);
  }//canonize


  function insertionSort(Txt, second) // NB. O(n**2) or worse; unacceptable for long input strings!
  { //if(Txt.length > 11) return;//too long for sorting
    //var suffixW = document.getElementById('suffixW');
    //suffixW.value = '';
    var table = document.getElementById('myTable');
    var A = new Array(), len = Txt.length;
    //cleanup();
    var i;
    for(i = 0; i < Txt.length; i++) A[i] = i;
    for(i = 0; i < Txt.length-1; i++)
    { var j,  small = i;
      for(j = i+1; j < Txt.length; j++)
         if(Txt.substring(A[j],len) < Txt.substring(A[small], len))
            small = j;
      var temp = A[i]; A[i] = A[small]; A[small] = temp;
    }
    for(i = 0; i < len; i++)
    { var numbr = '    '+(A[i])+': ';
      numbr = numbr.substring(numbr.length-4, numbr.length);
      //document.theForm.opt.value += numbr+Txt.substring(A[i], len)+'\n';
      suffix_table[A[i]] = Txt.substring(A[i], len);
      reverse_suffix_table[Txt.substring(A[i], len)] = A[i];
    }   
    for (i=0; i < suffix_table.length-1; i++) {
      for (var j=i+1; j< suffix_table.length; j++) {
        if (suffix_table[i] > suffix_table[j]) {
          var tmp = suffix_table[i];
          suffix_table[i] = suffix_table[j];
          suffix_table[j] = tmp;
        }
      }   
    }
    /*
    for (i=0; i < suffix_table.length; ++i) {
      var $input = $('<tr><td height=20px>' + i + '</td>' +  ' <td>' + reverse_suffix_table[suffix_table[i]] + '</td> ' + '<td>' + suffix_table[i] + '</td> ' + ' </tr>').appendTo(suffixW.getWidget().find('.tb1'));
      //row_draw_data[suffix_table[i]] = i;
    } */
    //document.theForm.opt.value += '\n';
    /*
    var canvas = document.getElementById('canvas');  
    if (typeof(second)!== "undefined") {
    canvas.addEventListener('click', function(evt) {
          var mousePos = getMousePos(canvas, evt);
          //alert(mousePos.x + " " + mousePos.y);
          var message = 'Mouse position: ' + mousePos.x + ',' + mousePos.y;
          insertionSort(Txt);
          highlightFromTreeToArray(mousePos);
        }, false);

    $('.vertices').css('pointer-events','none');  
    $('.edges').css('pointer-events','none');
    $('.overlays').css('pointer-events','none');

    }*/
 }//insertionSort

  function algorithm2() { 
    var s, k, i;
    var bt;

    root = new State();
    bt = new State();                                      // bt (bottom or _|_)

    // Want to create transitions for all possible chars
    // from bt to root
    for (i = 0; i < Txt.length; i++)
      bt.addTransition(i,i, root);

    root.sLink = bt;
    s = root; k = 0;  // NB. Start k=0, unlike Ukkonen paper our strings are 0 based

    for (i = 0; i < Txt.length; i++) {
      var sAndk = upDate(s, k, i);   // (s,k) < - upDate(...)
      s = sAndk.fst; k = sAndk.snd;
      sAndk = canonize(s, k, i);     // (s,k) < - canonize(...)
      s = sAndk.fst; k = sAndk.snd;
    }
  } // algorithm2 

  this.showGATAGACA = function() {
    clearScreen();
    stDriver();
  }

  this.buildSuffixTree = function(txt) {
    clearScreen();
    Txt = txt;
// console.log('this.buildSuffixTree txt = ' + txt);
    stDriver(txt);
  }

  this.buildGeneralSuffixTree = function() {
    clearScreen();
    stGeneralDriver();
  }

  // return values:
  // .index of input that will be used to match later (>0)
  // .-1 when not match from the beginning
  // .-2 when match
  // .1  when partial match
  /*
  function isPrefix(input, input_idx, node_label) {
    if (node_label=='') return 0;
    var j = 0, i;
    for (i= input_idx; i < input.length; i++) {
      if (input[i] != node_label[j]) return -1; // not match
      j++;
      if (j == node_label.length) break;
    } 
    //if (input.length - input_idx > node_label.length) return i;
    //if (input.length - input_idx <= node_label.length) return -2;
    if ()
  }
*/

  function isPrefix(input, input_idx, node_label) {
// console.log('input = ' + input + ', input_idx = ' + input_idx + ', node_label = ' + node_label);
    if (node_label == '') return 0;
    if (input[input_idx] != node_label[0]) return -1; // no match
    var j = 1, i;
    for (i = input_idx+1; i < input.length; i++) {
      // if (input[i] != node_label[j]) return -1; // this character does not match
      // j++;
      // if (j == node_label.length) break; // return i; // full match
      if (j == node_label.length) return i-1;
      if (input[i] == node_label[j]) j++;
    }
    //if (j != node_label.length) return 1; // input.length-input_idx >  node_label.length) return i;
    // if (input.length-input_idx <= node_label.length) return -2;
    return -2;
  }

  function prepareStDriver() {
    // if (Txt.length == 0) {
    //   alert('Please enter a non-empty string');
    //   return;
    // }
    // if (Txt[Txt.length-1] != '$') {
    //   alert('$ has been appended to your string');
    //   Txt += '$';
    //   document.getElementById("arrv1").value = Txt;
    // }
    infinity = Txt.length + 1000; // well it's quite big :-)
    nForks = 0;
    draw_data = new Array();
    //document.theForm.opt.value = '';
    suffix_table = new Array();
    reverse_suffix_table = new Array();
    currentColorNode = -1;
    currentColorElem = -1;
    insertionSort(Txt);

    algorithm2();  // ------------ the business
    height_level = new Array();
    for (var i=0; i < Txt.length; i++) height_level[i] = 0;
    //show(root, '', 'tree:|', 0, '');
    //document.theForm.opt.value += nForks + ' branching nodes';
    height = Txt.length*32;

    /*
    var ctx = document.getElementById("canvas").getContext("2d");
    ctx.clearRect(0, 0, 3000, 3000);

    ctx.save();
    */
    height_level[0] = height_offset ;
    for (var i=1; i < Txt.length; i++) {
        height_level[i] = height_level[0]*i*5.5;
    }   
    maxY = 0; maxX = 0;
    // TODO:
    var startX = 70;
  }

  function stDriver(txt) { 
    Txt = txt;
    // if (Txt.length == 0) {
    //   alert('Please enter a non-empty string');
    //   return
    // }
    // if (Txt[Txt.length-1] != '$') {
    //   alert('$ has been appended to your string');
    //   Txt += '$';
    //   document.getElementById("arrv1").value = Txt;
    // }

// console.log('Txt = ' + Txt);
    infinity = Txt.length + 1000; // well it's quite big :-)
    nForks = 0;
    draw_data = new Array();
    suffix_table = new Array();
    reverse_suffix_table = new Array();
    currentColorNode = -1;
    currentColorElem = -1;
    insertionSort(Txt);

    algorithm2();  // ------------ the business
    height_level = new Array();
    for (var i=0; i < Txt.length; i++) height_level[i] = 0;
    //show(root, '', 'tree:|', 0, '');
    //document.theForm.opt.value += nForks + ' branching nodes';
    height = Txt.length*32;

    /*
    var ctx = document.getElementById("canvas").getContext("2d");
    ctx.clearRect(0, 0, 3000, 3000);
    ctx.save();
    */
    height_level[0] = height_offset ;
    for (var i = 1; i < Txt.length; i++)
      height_level[i] = height_level[0]*i*5.5;
    maxY = 0; maxX = 0;

    // TODO:
    var startX = 70;
    drawSuffixTree(root, 0, startX, '');
    startX = (window.innerWidth - (maxX - startX))/2.5;
    clearScreen();
    Txt = txt;
    prepareStDriver();
    drawSuffixTree(root, 0, startX, '');
    // TODO:
    drawAllLabel();

    // update coord
    var count = 1;
    for (var i in draw_data) {
      //var st = Txt.substring(i);
      var node = draw_data[i];
      var idx = parseInt(node.class_id)+1;
      coord[idx] = new Array();
      coord[idx][0] = node.x;
      coord[idx][1] = node.y;
      //draw_data[i].class_id = count++;
    }
    // coord[1] = new Array();
    //coord[1][0] = draw_data[""].x;
    //coord[1][1] = draw_data[""].y;
  } // stDriver

  function drawSuffixTree(T, level, prev_x, text) {
    var count = 0, iter = 0;
    for (attr in T) {
      if (attr.length == 1) count++;
    }   

    var used = new Array(), min = '';
    for (attr in T) 
      if (attr.length == 1) {
        var wAndT2 = T[attr];
        var w = wAndT2.fst;
        var myStr = Txt.substring(w.left, w.right+1);
        used.push(new Node2(myStr, attr));
      }
    for (var i=0; i<used.length-1; i++)
      for (var j=i+1; j<used.length; j++) {
        if (stringCmp(used[i].index, used[j].index) == -1 ) {
          var tmp = used[i];
          used[i] = used[j];
          used[j] = tmp;
        }       
        else if (stringCmp(used[i].index, used[j].index) == 0) {
          if (stringCmp(used[i].word, used[j].word) == -1) {
            var tmp = used[i];
            used[i] = used[j];
            used[j] = tmp;
          }         
        }
      }

    var update_prev_x = prev_x;
    var tmp_store = text.split(":");
    var T_idx = text, T_string = text;
    //for(attr in T)//each subtree
      //if(attr.length == 1)//a char attribute selects a suffix-tree branch
    for (var i = 0; i < used.length; i++) {
      iter++;
      var attr = used[i];
      if (iter > count/2) break; 
      var wAndT2 = T[attr.index];
      var w = wAndT2.fst, T2 = wAndT2.snd;
      var Str_idx = Txt.substring(w.left, w.right+1);
      var myStr = T_string+ Str_idx ;
      //height = height_level[level];
      var y = (level+1)*height + height_offset;
      //drawVertex(update_prev_x,y,myStr,'black');
      var suffix_idx = -1;
      if (reverse_suffix_table[T_string + Str_idx]) {
        suffix_idx = reverse_suffix_table[T_string + Str_idx];
      }
      draw_data[T_string + Str_idx] = new Node3(T_string + Str_idx, suffix_idx, T_idx, 0, 0, T_string + Str_idx);
      update_prev_x = Math.max(update_prev_x, drawSuffixTree(T2, level+1, update_prev_x, myStr));
    }    
    update_prev_x += width;
    var vertex_name = "";
    if (reverse_suffix_table[text] || reverse_suffix_table[text] === 0) vertex_name = reverse_suffix_table[text];
    height = height_level[level];
    if (maxX < update_prev_x) maxX = update_prev_x;
    if (maxY < height) maxY = height;

    //drawVertex(update_prev_x, height, vertex_name, 'black'); TODO:
    A[amountVertex] = new ObjectPair(vertex_name, amountVertex);
    graphWidget.addVertex(update_prev_x, height, A[amountVertex].getFirst(), A[amountVertex++].getSecond(), true);
    if (T_idx == "")
      draw_data[""] = new Node3(T_string, -1, -2, update_prev_x, level*height + height_offset, "", amountVertex-1);
    else {
      draw_data[T_idx].x = update_prev_x;
      draw_data[T_idx].y = height;
      draw_data[T_idx].class_id = amountVertex - 1;
    }
    iter = 0;
    for (var i = 0; i < used.length; i++) {
      iter++;
      if (iter > count/2) {
        var attr = used[i];
        var wAndT2 = T[attr.index];
        var w = wAndT2.fst, T2 = wAndT2.snd;
        var Str_idx = Txt.substring(w.left, w.right+1);
        //if (Str_idx.indexOf("#") > -1) 
        //Str_idx = Str_idx.substring(0, Str_idx.indexOf("#")+1);
        var myStr = T_string + Str_idx;
        //show(T2, str2, myStr);
        var y = (level+1)*height + height_offset;
        //drawVertex(update_prev_x,y,myStr,'black');
        var suffix_idx = -1;
        if (reverse_suffix_table[T_string + Str_idx]) {
          suffix_idx = reverse_suffix_table[T_string + Str_idx];
        }
        draw_data[T_string + Str_idx] = new Node3(T_string + Str_idx, suffix_idx, T_idx, 0, 0, T_string + Str_idx);
        update_prev_x = Math.max(update_prev_x, drawSuffixTree(T2, level+1, update_prev_x, myStr));
      }
    }   
    return update_prev_x;
  }

  function drawAllLabel() {
    var node;
    for (attr in draw_data) {
      if (attr == "") continue;
      node = draw_data[attr];
      if (typeof(node.parent_index) != 'undefined') {
        var tmp = draw_data[node.parent_index];
        var a = node.path_label, b = tmp.path_label, c="", i;
        if (b) {
          for (i = 0; i < a.length; i++) {
            if (a[i] != b[i]) break;
          }
          for (; i < a.length; i++) {
            c += a[i];
          }
        } else c = a;
        var pts = getCircleLineIntersectionPoint(tmp.x, tmp.y, node.x, node.y, 14, tmp.x, tmp.y);
        var pts2 = getCircleLineIntersectionPoint(tmp.x, tmp.y, node.x, node.y, 14, node.x, node.y);
        var min = 5000;
        var save1 = 0, save2 = 0;
        for (var i=1; i<=3; i+=2) 
          for (var j=1; j<=3; j+=2) 
        {
          if (Math.abs(pts[i] - pts2[j]) < min) {
            min = Math.abs(pts[i] - pts2[j]);
            save1 = i; save2 = j;
          }
        }

        drawLabel(tmp.class_id, node.class_id, pts[save1-1], pts[save1], pts2[save2-1], pts2[save2], c, node.color);
        //drawLabel(tmp.x, tmp.y, node.x, node.y, c, node.color);   
        //drawLabel(pts[save1-1], pts[save1], pts2[save2-1],pts2[save2],c, node.color);
      }
    }
  }

  function drawLabel(from_class_id, to_class_id, xA, yA, xB, yB, text, color) {
    graphWidget.addEdge(from_class_id, to_class_id, ++amountEdge, EDGE_TYPE_UDE, 1, true);
    edgeList["#e" + amountEdge.toString()] = new Array();
    edgeList["#e" + amountEdge.toString()][0] = from_class_id;
    edgeList["#e" + amountEdge.toString()][1] = to_class_id;
    mainSvg.select("#e" + (amountEdge).toString()).attr("style", "stroke-width:0.5");
    var slope = (yA - yB)/(xA - xB);
    var x0 = xA, y0 = 0;
    var b = (yA - slope*xA);
    var deltaX = xA - xB;
    var delta = deltaX/(text.length+1);
    for (var i=0; i<text.length; i++) {
      x0-=delta;
      y0=slope*x0 + b;
      //ctx.fillText(text[i],x0,y0);
      mainSvg
     .append("text")
     .attr("class", "edgelabel")
     .attr("x", x0)
     .attr("y", y0)
     .attr("dx", 1)
     .attr("dy", ".35em")
     .attr("text-anchor", "middle")     
     .text(function(d) { return text[i] });
    }
  }

  function clicked(d) {
    return;
    var cur = d3.mouse(this);
    mainSvg.selectAll(".edgelabel")
      .style("pointer-events", "none")
    .transition()
      .duration(750)
      .attr("transform", "translate(80,80)");

    if (!d || centered === d) {
    projection.translate([MAIN_SVG_WIDTH / 2, MAIN_SVG_HEIGHT / 2]);
    centered = null;
  } else {
    var centroid = path.centroid(d),
        translate = projection.translate();
    projection.translate([
      translate[0] - centroid[0] + MAIN_SVG_WIDTH / 2,
      translate[1] - centroid[1] + MAIN_SVG_HEIGHT / 2
    ]);
    centered = d;
  }

  // Transition to the new projection.
  g.selectAll("path").transition()
    .duration(750)
    .attr("d", path);
  }

  function createState(internalHeapObject) {
    var state = {
      "vl":{},
      "el":{},
      "status":{}
    };

    for (var i = 0; i < internalHeapObject.length; i++) {
      var key = internalHeapObject[i].getSecond();
      //var key = i;
      state["vl"][key] = {};
      state["vl"][key]["cx"] = coord[key+1][0];
      state["vl"][key]["cy"] = coord[key+1][1];
      state["vl"][key]["text"] = internalHeapObject[i].getFirst();
      state["vl"][key]["state"] = VERTEX_DEFAULT;
    }

    //for (var i = 1; i < internalHeapObject.length; i++){
    for (var i = 1; i <= Object.size(edgeList); i++){
      var edgeId = i;
      state["el"][edgeId] = {};
      state["el"][edgeId]["vertexA"] = edgeList["#e" + i.toString()][0]; //internalHeapObject[parent(i)].getSecond();
      state["el"][edgeId]["vertexB"] = edgeList["#e" + i.toString()][1];//internalHeapObject[i].getSecond();
      state["el"][edgeId]["type"] = EDGE_TYPE_UDE;
      state["el"][edgeId]["weight"] = 1;
      state["el"][edgeId]["state"] = EDGE_DEFAULT;
      state["el"][edgeId]["animateHighlighted"] = false;
    }

    return state;
  }

  this.testAnimation = function() {
    var currentState = createState(A);
    currentState["vl"][A[4].getSecond()]["state"] = VERTEX_HIGHLIGHTED;
    currentState["status"] = 'animate1 animate';
    currentState["lineNo"] = 0;
    stateList.push(currentState);
    //graphWidget.startAnimation(stateList);
    
    currentState = createState(A);
    currentState["vl"][A[4].getSecond()]["state"] = VERTEX_TRAVERSED;
    currentState["vl"][A[1].getSecond()]["state"] = VERTEX_HIGHLIGHTED;
    currentState["status"] = 'animate123';
    //currentState["lineNo"] = 1;
    //currentState["status"] = 'animate_2';
    stateList.push(currentState);
    //graphWidget.startAnimation(stateList);
    for (var i=0; i < 10; i++) {
      currentState = createState(A);
      currentState["vl"][A[i+1].getSecond()]["state"] = VERTEX_TRAVERSED;
      currentState["vl"][A[i].getSecond()]["state"] = VERTEX_HIGHLIGHTED;
      currentState["status"] = 'animate' + i.toString();
      currentState["lineNo"] = 2;
      stateList.push(currentState);
     //graphWidget.startAnimation(stateList);
    }

    var s2 = createState(A);
    currentState["vl"][A[4].getSecond()]["state"] = VERTEX_TRAVERSED;
    stateList.push(currentState);
    
    graphWidget.startAnimation(stateList);
    return true;
  }

  this.goSearch = function(input, callback) {
    populatePseudocode(0);
    this.buildSuffixTree(currentT);

    // (path_label, node_label, x, y, match_flag)
    var stateList = new Array();
    foundResult = false;
    processQueue = new Array();
    processQueue.push(new Node4('', '', draw_data[''].x, draw_data[''].y, -1));
    processTreeForSearch(root, '', '', '', input, 0);
    if (!foundResult) {
      // alert("Missing feature alert (not updated yet). Pattern string P is not in the Suffix Tree. The search should attempt searching all vertices in Suffix Tree and report failure at the end.");
      // return false;
      // processQueue.push(-1);
// console.log('oi');
    }
    var stack = new Array(), prev = new Array();
    var tmpProcessQ = new Array();
    var isGoingUp = new Array();
    tmpProcessQ[0] = processQueue[0];
    stack.push(processQueue[0]);
    var is_popping = false;
    for (var i=1; i < processQueue.length; i++) {
      var top = stack[stack.length-1];
      var next_node = processQueue[i];
      if ((draw_data[next_node.path_label].parent_index == top.path_label) && !is_popping) {
        stack.push(next_node);
        is_popping = false;
        tmpProcessQ.push(next_node);
      }
      else {
        while (true) {
          stack.pop();
          is_popping = true;
          top = stack[stack.length-1];
          if (draw_data[next_node.path_label].parent_index == top.path_label) {
            tmpProcessQ.push(top);
            isGoingUp[tmpProcessQ.length-1] = true;
            tmpProcessQ.push(next_node);
            stack.push(next_node);
            is_popping = false;
            break;
          }
          else {
            tmpProcessQ.push(top);
            isGoingUp[tmpProcessQ.length-1] = true;
          }
        }
      }
    }
    processQueue = tmpProcessQ;

    var prev = new Array();
    var prev_edge = new Array();
    var curState = createState(A);
    var populateResult = false;
    var isResultPartial = true;
    var results = new Array();
    var noMatch = false;
    curState["status"] = 'Current result will be yellow colored.';
    stateList.push(curState);
    for (var i in processQueue) {
      var currentState = createState(A);

      if (populateResult) {
        if (!isResultPartial) {
          isResultPartial = true;
          results = new Array();
        }
        var pl = processQueue[i].path_label;
        var tmp_q = new Array();
        tmp_q.push(pl);
        while (Object.size(tmp_q)) {
          pl = tmp_q.pop();
          if (pl[pl.length-1] != "$") {
            for (var j in draw_data) {
              var tpp = draw_data[j];
              if (tpp.parent_index == pl) tmp_q.push(tpp.path_label);
            }
          } else {
            results.push(pl);
          }
        }
        //results.push(processQueue[i].path_label);
        continue;
      }

      var node = processQueue[i];      
      var node_idx = null;
      node_idx = parseInt(draw_data[node.path_label].class_id);
      if (isGoingUp[i]) {
        currentState = createState(A);
        currentState["status"] = 'Going back.';
        for (var j = 0; j < prev.length; j++)
          currentState["vl"][prev[j]]["state"] = VERTEX_TRAVERSED;
        for (var w = 0; w < Object.size(prev_edge); w++)
          currentState["el"][prev_edge[w]]["state"] = EDGE_TRAVERSED;
        currentState["vl"][node_idx]["state"] = VERTEX_HIGHLIGHTED;      
        stateList.push(currentState);
        continue;
      }

      currentState["vl"][node_idx]["state"]= VERTEX_HIGHLIGHTED;      
      for (var w = 0; w < Object.size(prev_edge); w++)
        currentState["el"][prev_edge[w]]["state"] = EDGE_TRAVERSED;
      for (var w = 1; w <= Object.size(edgeList); w++) {
        var e = edgeList["#e" + w.toString()];
        if (typeof(e) == "undefined") continue;
        if (e[1] == node_idx) {
          currentState["el"][w]["state"]= EDGE_HIGHLIGHTED;  
          prev_edge.push(w);
          break;
        }
      }
      
      for (var j = 0; j < prev.length; j++)
        currentState["vl"][prev[j]]["state"]= VERTEX_TRAVERSED;
      prev.push(node_idx);
      if (node.match_flag == -2) {
        currentState["status"] = 'Path label: "{path_label}"<div>Pattern string P match with this path label</div>'.replace("{path_label}", node.path_label);
        currentState["lineNo"] = 5;
        isResultPartial = false;
        results.push(node.path_label);
        stateList.push(currentState);
        populateResult = true;
      }
      else if (node.match_flag == -1) {
        if (i == "0") {
          currentState["status"] = 'Start from root';
          currentState["lineNo"] = 1;
        }
        else {
          currentState["status"] = 'Path label: "{path_label}".<div>Not a match with the pattern string, going back</div>'.replace("{path_label}", node.path_label);
          currentState["lineNo"] = 4;
        }
      }
      else {
        currentState["status"] = 'Path label: "{path_label}".<div>Pattern string P matches path label partially, going deeper</div>'.replace("{path_label}", node.path_label);
        currentState["lineNo"] = 6;
      }
      stateList.push(currentState);
    }

// console.log(processQueue[i]);
    if (!foundResult) { // processQueue[i] == -1) {
      currentState["status"] = 'No match found.'
      currentState["lineNo"] = 7;
      noMatch = true;
      for (var j = 0; j < prev.length; j++)
        currentState["vl"][prev[j]]["state"]= VERTEX_TRAVERSED;
      stateList.push(currentState);
      // break;
    }
    else {
    // if (!noMatch) {
      currentState = createState(A);
      currentState["status"] = 'The results are yellow colored.'
      currentState["lineNo"] = 5;
      for (var j=0; j<results.length; j++) {
        var tmp_idx = parseInt(draw_data[results[j]].class_id);
        currentState["vl"][tmp_idx]["state"] = VERTEX_RESULT;
      }
      stateList.push(currentState);
    }

    graphWidget.startAnimation(stateList, callback);
    return true;
  }

  function processTreeForSearch(T, str, arc, node_label, input, input_idx) {
    if (T.isLeaf)
      return;
    var attr, iter = 0, i;
    //spaces += '|';   // |spaces|==|arc|
    //var str2 = str+spaces;//nosilla l

    var used = new Array(); 
    var min = '';
    
    for (attr in T) 
      if (attr.length == 1) {
        var wAndT2 = T[attr];
        var w = wAndT2.fst;
        var myStr = Txt.substring(w.left, w.right+1);
        used.push(new Node2(myStr, attr));
      }
    for (var i = 0; i < used.length-1; i++)
      for (var j = i+1; j < used.length; j++) {
        if (stringCmp(used[i].index, used[j].index) == -1) {
          var tmp = used[i];
          used[i] = used[j];
          used[j] = tmp;
        }       
        else if (stringCmp(used[i].index, used[j].index) == 0) {
          if (stringCmp(used[i].word, used[j].word) == -1) {
            var tmp = used[i];
            used[i] = used[j];
            used[j] = tmp;
          }         
        }
      }
    for (var i = 0; i < used.length; i++) {
      attr = used[i];
      var wAndT2 = T[attr.index];
      var w = wAndT2.fst, T2 = wAndT2.snd;
      var node_label_cur = Txt.substring(w.left, w.right+1);
      var myStr = '('+(w.left)+':'+ node_label_cur +')|';
      var is_prefix = isPrefix(input, input_idx, node_label_cur);
      //(path_label, node_label, x, y, match_flag)
      processQueue.push(new Node4(node_label+node_label_cur, node_label_cur, draw_data[node_label+node_label_cur].x, draw_data[node_label+node_label_cur].y, is_prefix));
// console.log('is_prefix ' + is_prefix);
      if (is_prefix >= 0) {
        //processTreeForSearch(T2, "", myStr, Txt.substring(w.left, w.right+1), input, is_prefix+1);
        processTreeForSearch(T2, "", myStr, node_label+node_label_cur, input, is_prefix+1);
// console.log('IS THIS EVER EXECUTED ');
        return;
      }
      else if (is_prefix == -2) {
        fromResultNode = T;
        toResultNode = T2;
        var tmpQ = new Array();
        for (aattr in T2) {
          if (aattr.length == 1) {
            var wAndT2 = T2[aattr];
            var w = wAndT2.fst;
            var myStr = Txt.substring(w.left, w.right+1);
            // tmpQ.push(new Node4(input+myStr, myStr, draw_data[input+myStr].x, draw_data[input+myStr].y, 0));
            tmpQ.push(new Node4(node_label+node_label_cur+myStr, myStr, draw_data[node_label+node_label_cur+myStr].x, draw_data[node_label+node_label_cur+myStr].y, 0));
          }
        }
        for (var k = 0; k < tmpQ.length-1; k++)
          for (var j = k+1; j < tmpQ.length; j++)
            if (stringCmp(tmpQ[k].path_label, tmpQ[j].path_label) == -1) {
              var tmp = tmpQ[k];
              tmpQ[k] = tmpQ[j];
              tmpQ[j] = tmp;
            }       
        for (var k = 0; k < tmpQ.length; k++)
          processQueue.push(tmpQ[k]);
        foundResult = true;
        return;
      }
    }
  }

  function addTraversedNode(state_list, prevs, current_state) {
    var stateList = state_list;
    for (var j = 0; j < prevs.length; j++)
      current_state["vl"][prevs[j]]["state"]= VERTEX_TRAVERSED;
    stateList.push(currentState);
    return stateList;
  }

  this.goLRS = function(callback) {
    populatePseudocode(1);
    this.buildSuffixTree(currentT);

    processQueueLRS = new Array();
    processQueueLRS.push(new NodeLRS('', draw_data[''].x, draw_data[''].y, false));
    var is_LCS = false;
    processTreeForLRS(root, '', is_LCS); // is_LCS always false

    var stateList = new Array();
    var currentState = createState(A);
    // if (is_LCS) { // legacy, I think Duong separates LRS with LCS eventually
    //   currentState["status"] = 'Purple vertices belong to string 1. Green vertices belong to string 2. Current result will be yellow colored.';
    //   stateList.push(currentState);
    // }
    currentState = createState(A);
    currentState["status"] = 'Start from root.';
    currentState["lineNo"] = 1;
    //currentState["vl"][6]["state"] = VERTEX_HIGHLIGHTED;
    stateList.push(currentState);

    var stack = new Array(), prev = new Array();
    var tmpProcessQ = new Array();
    var isGoingUp = new Array();
    tmpProcessQ[0] = processQueueLRS[0];
    stack.push(processQueueLRS[0]);
    var is_popping = false;
    for (var i = 1; i < processQueueLRS.length; i++) {
      var top = stack[stack.length-1];
      var next_node = processQueueLRS[i];
      if ((draw_data[next_node.path_label].parent_index == top.path_label) && !is_popping) {
        stack.push(next_node);
        is_popping = false;
        tmpProcessQ.push(next_node);
      }
      else {
        while (true) {
          stack.pop();
          is_popping = true;
          top = stack[stack.length-1];
          if (draw_data[next_node.path_label].parent_index == top.path_label) {
            tmpProcessQ.push(top);
            isGoingUp[tmpProcessQ.length-1] = true;
            tmpProcessQ.push(next_node);
            stack.push(next_node);
            is_popping = false;
            break;
          }
          else {
            tmpProcessQ.push(top);
            isGoingUp[tmpProcessQ.length-1] = true;
          }
        }
      }
    }

    processQueueLRS = tmpProcessQ;
    var results = new Array();
    var max = "";
    // the animation starts here
    var prev = new Array();
    var prev_edge = new Array();
    for (var i in processQueueLRS) {
      var currentState = createState(A);
      var node = processQueueLRS[i];      
      var node_idx = null;
      node_idx = parseInt(draw_data[node.path_label].class_id);
      currentState["vl"][node_idx]["state"]= VERTEX_HIGHLIGHTED;
      var edgeId = 0;
      for (var w = 0; w < Object.size(prev_edge); w++) {
        currentState["el"][prev_edge[w]]["state"]= EDGE_TRAVERSED;
      }
      for (var w = 1; w <= Object.size(edgeList); w++) {
        var e = edgeList["#e" + w.toString()];
        if (typeof(e) == "undefined") continue;
        if (e[1] == node_idx) {
          currentState["el"][w]["state"]= EDGE_HIGHLIGHTED;  
          prev_edge.push(w);
          break;
        }
      }

      for (var j = 0; j < prev.length; j++)
        currentState["vl"][prev[j]]["state"]= VERTEX_TRAVERSED;
      prev.push(node_idx);

      if (isGoingUp[i]) {
        currentState["status"] = 'Going back.'
        currentState["lineNo"] = [2, 3];
      }
      else if (node.is_leaf) {
        currentState["status"] = 'This is a leaf vertex (not repeated), we skip this.';
        currentState["lineNo"] = 4;
      }
      else {
        currentState["status"] = 'Path label: "{path_label}". '.replace("{path_label}", node.path_label) + '<br>';
        if (node.path_label.length > max.length) {
          max = node.path_label;
          results = [];
          results.push(node.path_label);
          currentState["lineNo"] = 6;
          currentState["status"]+= 'Longer than the length of current ans, ans is now "{newans}".'.replace("{newans}", max);
        }
        else if (node.path_label.length == max.length) {
          results.push(node.path_label);
          currentState["lineNo"] = 6;
          currentState["status"]+= 'Equal to the length of current ans; ans is now "{newans}".'.replace("{newans}", max);
        }
        else {
          currentState["lineNo"] = 5;
          currentState["status"]+= 'Smaller than the length of current ans, ignored.';
        }
      }
      for (var j = 0; j < results.length; j++) {
        var tmp_idx = parseInt(draw_data[results[j]].class_id);
        currentState["vl"][tmp_idx]["state"] = VERTEX_RESULT;
        currentState["vl"][tmp_idx]["extratext"]= "ans";
      }
      if (isGoingUp[i])
        currentState["vl"][node_idx]["state"]= VERTEX_HIGHLIGHTED;
      stateList.push(currentState);
    }
    currentState = createState(A);
    currentState["lineNo"] = 7;

    var lrsResult = "";
    for (var i = 0; i < results.length; i++) {
      if (i > 0) lrsResult += ", ";
      lrsResult += results[i] + " ";
    }

    if (results.length > 1) {
      currentState["status"] = 'LRS are {lrsResult}'.replace("{lrsResult}", lrsResult);
    }
    else {
      if (results.length == 1 && results[0].length == 0)
        currentState["status"] = 'LRS is an empty string.';
      else
        currentState["status"] = 'LRS is "{lrsResult}" (highlighted with yellow color)'.replace("{lrsResult}", lrsResult);
    }

    for (var j = 0; j < prev.length; j++) {
      currentState["vl"][prev[j]]["state"]= VERTEX_TRAVERSED;
    }
    for (var j = 0; j < results.length; j++) {
      var tmp_idx = parseInt(draw_data[results[j]].class_id);
      currentState["vl"][tmp_idx]["state"] = VERTEX_RESULT;
      currentState["vl"][tmp_idx]["extratext"] = "LRS";
    }
    for (var w = 0; w < Object.size(prev_edge); w++) {
      currentState["el"][prev_edge[w]]["state"]= EDGE_TRAVERSED;
    }
    stateList.push(currentState);
    graphWidget.startAnimation(stateList, callback);
    return true;
  }

  function processTreeForLRS(T, path_label, isLCS) {
    if (T.isLeaf)
      return;
    var attr, iter = 0;
    var spaces = '';  var i;

    var used = new Array(); 
    var min = '';
    if (isLCS && draw_data[path_label].color!='black') return;
    for (attr in T) 
      if (attr.length == 1) {
        var wAndT2 = T[attr];
        var w = wAndT2.fst;
        var myStr = Txt.substring(w.left, w.right+1);
        used.push(new Node2(myStr, attr));
      }
    for (var i = 0; i < used.length-1; i++)
      for (var j = i+1; j < used.length; j++) {
        if (stringCmp(used[i].index, used[j].index) == -1) {
          var tmp = used[i];
          used[i] = used[j];
          used[j] = tmp;
        }       
        else if (stringCmp(used[i].index, used[j].index) == 0) {
          if (stringCmp(used[i].word, used[j].word) == -1) {
            var tmp = used[i];
            used[i] = used[j];
            used[j] = tmp;
          }         
        }
      }
    for (var i=0; i < used.length; i++) {
      attr = used[i];
      var wAndT2 = T[attr.index];
      var w = wAndT2.fst, T2 = wAndT2.snd;
      var node_label_cur = Txt.substring(w.left, w.right+1);
      var path_lb = path_label + node_label_cur;
      processQueueLRS.push(new NodeLRS(path_lb, draw_data[path_lb].x, draw_data[path_lb].y, T2.isLeaf));
      processTreeForLRS(T2, path_lb, isLCS);       
    }
  }

  this.coloring = function() {
    for (var j=0; j < 100; j++)
    for (var i in draw_data) {
      var tmp_vertex = mainSvg.selectAll(".v" + draw_data[i].class_id.toString());
      tmp_vertex[0] = tmp_vertex[0].splice(0,2);
      tmp_vertex.attr("fill", "yellow !important");
      tmp_vertex.attr("class", "comeon");
    }
  }

  this.goLCS = function(callback) {
    clearScreen();
    var stateList = new Array();
    // Determine whether an inside vertex contains both strings
    processQueueLRS = new Array();
    var internals = stGeneralDriver(true);
    populatePseudocode(2);
    // TODO: remove color of inside vertex that belongs to 1 string here
    /*
    for (var i in draw_data) {
      // check if i is internal vetex
      var tmp = draw_data[i];
      var isInternal = false;
      for (var j in draw_data) {
        if (j == i) continue;
        if (draw_data[j].parent_index == tmp.path_label) {
          isInternal = true;
          break;
        }
      }
      if (isInternal) {
        var tmp_vertex = mainSvg.selectAll(".v" + tmp.class_id.toString());
        if (tmp.color == "orchid")
          tmp_vertex.classed("lcs_first", false);
        else if (tmp.color != "black")
          tmp_vertex.classed("lcs_second", false);
      }
    } */

    processQueueLRS.push(new NodeLRS('', draw_data[''].x, draw_data[''].y, false));
    processTreeForLRS(root, '', false);
    var currentState = createState(A);
    currentState["status"] = 'Start from root.';
    currentState["lineNo"] = 1;
    //currentState["vl"][6]["state"] = VERTEX_HIGHLIGHTED;
    stateList.push(currentState);

    var stack = new Array(), prev = new Array();
    var tmpProcessQ = new Array();
    var isGoingUp = new Array();
    tmpProcessQ[0] = processQueueLRS[0];
    stack.push(processQueueLRS[0]);
    var is_popping = false;
    for (var i=1; i < processQueueLRS.length; i++) {
      var top = stack[stack.length-1];
      var next_node = processQueueLRS[i];
      if ((draw_data[next_node.path_label].parent_index == top.path_label) && !is_popping) {
        stack.push(next_node);
        is_popping = false;
        tmpProcessQ.push(next_node);
      } else {
        while (true) {
          stack.pop();
          is_popping = true;
          top = stack[stack.length-1];
          if (draw_data[next_node.path_label].parent_index == top.path_label) {
            tmpProcessQ.push(top);
            isGoingUp[tmpProcessQ.length-1] = true;
            tmpProcessQ.push(next_node);
            stack.push(next_node);
            is_popping = false;
            break;
          } else {
            tmpProcessQ.push(top);
            isGoingUp[tmpProcessQ.length-1] = true;
          }
        }
      }
    }

    processQueueLRS = tmpProcessQ;
    var results = new Array();
    var max = "";
    // the animation starts here
    var prev = new Array();
    var prev_edge = new Array();
    var string1s = new Array();
    var string2s = new Array();
    for (var i in processQueueLRS) {
      var currentState = createState(A);
      var node = processQueueLRS[i];      
      var node_idx = null;
      node_idx = parseInt(draw_data[node.path_label].class_id);
      
      var edgeId = 0;
      
      for (var w=1; w <= Object.size(edgeList); w++) {
        var e = edgeList["#e" + w.toString()];
        if (typeof(e) == "undefined") continue;
        if (e[1] == node_idx) {
          currentState["el"][w]["state"]= EDGE_HIGHLIGHTED;  
          prev_edge.push(w);
          break;
        }
      }

      for (var w = 0; w < Object.size(prev_edge); w++)
        currentState["el"][prev_edge[w]]["state"] = EDGE_TRAVERSED;
      for (var j = 0; j < prev.length; j++)
        currentState["vl"][prev[j]]["state"] = VERTEX_TRAVERSED;
      prev.push(node_idx);
      currentState["vl"][node_idx]["state"] = VERTEX_HIGHLIGHTED;

      if (isGoingUp[i]) {
        // currentState["status"] = 'Going back';
        // currentState["lineNo"] = 1;
        // for (var k = 0; k < Object.size(string1s); k++)
        //   currentState["vl"][string1s[k]]["state"] = VERTEX_BLUE_FILL; 
        // for (var k = 0; k < Object.size(string2s); k++)
        //   currentState["vl"][string2s[k]]["state"] = VERTEX_GREEN_FILL; 
        // stateList.push(currentState);
        currentState = createState(A);
        currentState["status"] = 'Going back';
        currentState["lineNo"] = 1;
        for (var w = 0; w < Object.size(prev_edge); w++)
          currentState["el"][prev_edge[w]]["state"] = EDGE_TRAVERSED;
        for (var j = 0; j < prev.length; j++)
          currentState["vl"][prev[j]]["state"] = VERTEX_TRAVERSED;
        var tmp_vertex = mainSvg.selectAll(".v" + draw_data[node.path_label].class_id.toString());
        if (draw_data[node.path_label].color == "orchid") {
          currentState["status"] = 'This internal vertex only contains suffix(es) from string 1';
          currentState["lineNo"] = 1;
          string1s.push(node_idx);
        }
        else if (draw_data[node.path_label].color != 'black') {
          currentState["status"] = 'This internal vertex only contains suffix(es) from string 2';
          currentState["lineNo"] = 1;
          string2s.push(node_idx);
        }
        for (var k = 0; k < Object.size(string1s); k++)
          currentState["vl"][string1s[k]]["state"] = VERTEX_BLUE_FILL; 
        for (var k = 0; k < Object.size(string2s); k++)
          currentState["vl"][string2s[k]]["state"] = VERTEX_GREEN_FILL; 
        currentState["vl"][node_idx]["extratext"] = "^";
        stateList.push(currentState);
        continue;
      }
      else if (node.is_leaf) {
        currentState["status"] = 'This is a leaf vertex, going back.';
        currentState["lineNo"] = 1;
        currentState["vl"][node_idx]["state"]= VERTEX_HIGHLIGHTED;
        //currentState["lineNo"] = 4;
        for (var k = 0; k < Object.size(string1s); k++)
          currentState["vl"][string1s[k]]["state"] = VERTEX_BLUE_FILL; 
        for (var k = 0; k < Object.size(string2s); k++)
          currentState["vl"][string2s[k]]["state"] = VERTEX_GREEN_FILL; 
      }
      else {
        // TODO: do the check here and color node that belongs to 1 string
        //if (draw_data[i].color == "orchid")
        //tmp_vertex.attr("class", "lcs_first");
        //else tmp_vertex.attr("class", "lcs_second");        
        currentState["status"] = 'This is an internal vertex';
        for (var k = 0; k < Object.size(string1s); k++)
          currentState["vl"][string1s[k]]["state"] = VERTEX_BLUE_FILL; 
        for (var k = 0; k < Object.size(string2s); k++)
          currentState["vl"][string2s[k]]["state"] = VERTEX_GREEN_FILL; 
      }
      if (isGoingUp[i]) currentState["vl"][node_idx]["state"]= VERTEX_HIGHLIGHTED;
      currentState["vl"][node_idx]["state"] = VERTEX_HIGHLIGHTED;
      currentState["vl"][node_idx]["extratext"] = "^";
      stateList.push(currentState);
    }
    currentState = createState(A);
    currentState["status"] = 'The internal vertices that belongs to only 1 string are highlighted with the same color as the original string color';
    for (var w = 0; w < Object.size(prev_edge); w++)
      currentState["el"][prev_edge[w]]["state"] = EDGE_TRAVERSED;
    for (var j = 0; j < prev.length; j++)
      currentState["vl"][prev[j]]["state"] = VERTEX_TRAVERSED;
    for (var k = 0; k < Object.size(string1s); k++)
      currentState["vl"][string1s[k]]["state"] = VERTEX_BLUE_FILL; 
    for (var k = 0; k < Object.size(string2s); k++)
      currentState["vl"][string2s[k]]["state"] = VERTEX_GREEN_FILL; 
    stateList.push(currentState);

    // ends
    stGeneralDriver(true);
    populatePseudocode(3);
    processQueueLRS = new Array();
    processQueueLRS.push(new NodeLRS('', draw_data[''].x, draw_data[''].y, false));
    processTreeForLRS(root, '', true);
    prev_edge = new Array();

    var currentState = createState(A);
    currentState["status"] = 'Start of the actual process of finding LCS';
    for (var i = 0; i < Object.size(internals); i++) {
      var node_idx = null;
      var node = internals[i];
      node_idx = parseInt(draw_data[node].class_id);
      if (draw_data[node].color == "orchid")
        currentState["vl"][node_idx]["state"]= VERTEX_NORMAL_BLUE;
      else 
        currentState["vl"][node_idx]["state"]= VERTEX_NORMAL_GREEN;
    }
    stateList.push(currentState);    
    currentState = createState(A);
    currentState["status"] = 'Start from root.';
    //currentState["vl"][6]["state"] = VERTEX_HIGHLIGHTED;
    currentState["lineNo"] = 2;
    for (var i=0; i < Object.size(internals); i++) {
      var node_idx = null;
      var node = internals[i];
      node_idx = parseInt(draw_data[node].class_id);
      if (draw_data[node].color == "orchid")
        currentState["vl"][node_idx]["state"]= VERTEX_NORMAL_BLUE;
      else 
        currentState["vl"][node_idx]["state"]= VERTEX_NORMAL_GREEN;
    }
    stateList.push(currentState);

    var stack = new Array(), prev = new Array();
    var tmpProcessQ = new Array();
    var isGoingUp = new Array();
    tmpProcessQ[0] = processQueueLRS[0];
    stack.push(processQueueLRS[0]);
    var is_popping = false;
    for (var i=1; i < processQueueLRS.length; i++) {
      var top = stack[stack.length-1];
      var next_node = processQueueLRS[i];
      if ((draw_data[next_node.path_label].parent_index == top.path_label) && !is_popping) {
        stack.push(next_node);
        is_popping = false;
        tmpProcessQ.push(next_node);
      } else {
        while (true) {
          stack.pop();
          is_popping = true;
          top = stack[stack.length-1];
          if (draw_data[next_node.path_label].parent_index == top.path_label) {
            tmpProcessQ.push(top);
            isGoingUp[tmpProcessQ.length-1] = true;
            tmpProcessQ.push(next_node);
            stack.push(next_node);
            is_popping = false;
            break;
          } else {
            tmpProcessQ.push(top);
            isGoingUp[tmpProcessQ.length-1] = true;
          }
        }
      }
    }

    processQueueLRS = tmpProcessQ;
    var results = new Array();
    var max = "";
    // the animation starts here
    var prev = new Array();
    for (var i in processQueueLRS) {
      var currentState = createState(A);
      var node = processQueueLRS[i];      
      var node_idx = null;
      for (var j0=0; j0 < Object.size(internals); j0++) {
        var node_idx = null;
        var node1 = internals[j0];
        node_idx = parseInt(draw_data[node1].class_id);
        if (draw_data[node1].color == "orchid")
          currentState["vl"][node_idx]["state"]= VERTEX_NORMAL_BLUE;
        else 
          currentState["vl"][node_idx]["state"]= VERTEX_NORMAL_GREEN;
      }
      node_idx = parseInt(draw_data[node.path_label].class_id);
      currentState["vl"][node_idx]["state"]= VERTEX_HIGHLIGHTED;
      for (var w=0; w < Object.size(prev_edge); w++) {
        currentState["el"][prev_edge[w]]["state"]= EDGE_TRAVERSED;
      }
      for (var j=0; j < prev.length; j++) {
        currentState["vl"][prev[j]]["state"]= VERTEX_TRAVERSED;
      }
      for (var w=1; w <= Object.size(edgeList); w++) {
        var e = edgeList["#e" + w.toString()];
        if (typeof(e) == "undefined") continue;
        if (e[1] == node_idx) {
          currentState["el"][w]["state"]= EDGE_HIGHLIGHTED;  
          prev_edge.push(w);
          break;
        }
      }
      prev.push(node_idx);

      if (isGoingUp[i]) {
        currentState["status"] = 'Going back'
      }
      else if (node.is_leaf) {
        currentState["status"] = 'This is a leaf vertex, going back.';
        currentState["lineNo"] = 4;
      }
      else if (draw_data[node.path_label].color != 'black') {
        currentState["status"] = 'This is not a common vertex, going back.';
        currentState["lineNo"] = 5;
      }
      else {
        currentState["status"] = 'Path label: "{path_label}". '.replace("{path_label}", node.path_label);
        currentState["lineNo"] = 6;        
        if (node.path_label.length > max.length) {
          max = node.path_label;
          results = [];
          results.push(node.path_label);
          currentState["status"]+= 'Longer than current max<div>Updating max</div>';
        }
        else if (node.path_label.length == max.length && node.path_label != max) {
          results.push(node.path_label);
          currentState["status"]+= 'Equal to current max<div>Updating max</div>';
        }
        else if (node.path_label != max)
          currentState["status"]+= 'Smaller than current max';
      }
      for (var j = 0; j < results.length; j++) {
        var tmp_idx = parseInt(draw_data[results[j]].class_id);
        currentState["vl"][tmp_idx]["state"] = VERTEX_RESULT;
        currentState["vl"][tmp_idx]["extratext"] = "ans";
      }
      if (isGoingUp[i]) currentState["vl"][node_idx]["state"] = VERTEX_HIGHLIGHTED;
      currentState["vl"][node_idx]["extratext"] = "^";
      stateList.push(currentState);
    }
    currentState = createState(A);
    
    var lcsResult = "";
    for (var i = 0; i < results.length; i++) {
      if (i > 0) lcsResult += ", ";
      lcsResult += results[i] + " ";
    }

    if (results.length > 1)
      currentState["status"] = 'LCS are "{lcsResult}"'.replace("{lcsResult}", lcsResult);
    else
      currentState["status"] = 'LCS is "{lcsResult}" (highlighted with yellow color)'.replace("{lcsResult}", lcsResult);
    
    for (var i = 0; i < Object.size(internals); i++) {
      var node_idx = null;
      var node = internals[i];
      node_idx = parseInt(draw_data[node].class_id);
      if (draw_data[node].color == "orchid")
        currentState["vl"][node_idx]["state"]= VERTEX_NORMAL_BLUE;
      else 
        currentState["vl"][node_idx]["state"]= VERTEX_NORMAL_GREEN;
    }
    for (var j = 0; j < prev.length; j++)
      currentState["vl"][prev[j]]["state"]= VERTEX_TRAVERSED;
    for (var j = 0; j < results.length; j++) {
      var tmp_idx = parseInt(draw_data[results[j]].class_id);
      currentState["vl"][tmp_idx]["state"] = VERTEX_RESULT;
      currentState["vl"][tmp_idx]["extratext"] = "LCS";
    }    

    stateList.push(currentState);
    graphWidget.startAnimation(stateList, callback);
    return true;
  }

  var lcs_txt = "";
  function stGeneralDriver(notColorInternal) { 
   //Txt = document.getElementById("s1").value;
    var s1 = document.getElementById("s1").value, s2 = document.getElementById("s2").value;
    //var s1 = "GATAGACA$", s2 = "CATA#";
    if (s1.length == 0 || s2.length == 0) {
      alert("Please enter non-empty strings");
      return;
    }
    if (s1[s1.length-1] != '$') {
      alert("$ has been appended to your first string");
      s1 += '$';
      document.getElementById("s1").value = s1;
    }
    if (s2[s2.length-1] != '#') {
      alert("# has been appended to your second string");
      s2 += '#';
      document.getElementById("s2").value = s2;
    }
    Txt =  s1 + s2;

    infinity = Txt.length + 1000; 
    nForks = 0;
    draw_data = new Array();
    suffix_table = new Array();
    reverse_suffix_table = new Array();
    insertionSort(s1);
    insertionSort(s2);

    algorithm2();  // ------------ the business
    height_level = new Array();
    for (var i=0; i < Txt.length; i++) height_level[i] = 0;
    show2(root, '', 'tree:|', 0, '');
    height = Txt.length*32;
    height_level[0] = height_offset;
    for (var i=1; i < Txt.length; i++) {
      height_level[i] = height_level[0]*i*5.5;
    }   
    maxY = 0; maxX = 0;
    var startX = 70;
    drawGeneralSuffixTree(root, 0, startX, '');  
    startX = (window.innerWidth - (maxX - startX))/2.5;
    lcs_txt = Txt;
    clearScreen();
    Txt = lcs_txt;
    infinity = Txt.length + 1000; 
    nForks = 0;
    draw_data = new Array();
    suffix_table = new Array();
    reverse_suffix_table = new Array();
    insertionSort(s1);
    insertionSort(s2);

    algorithm2(); // ------------ the business
    height_level = new Array();
    for (var i = 0; i < Txt.length; i++)
      height_level[i] = 0;
    show2(root, '', 'tree:|', 0, '');
    height = Txt.length*32;
    height_level[0] = height_offset;
    for (var i = 1; i < Txt.length; i++)
      height_level[i] = height_level[0]*i*5.5;
    drawGeneralSuffixTree(root, 0, startX, '');
    drawAllLabel();
    // update coord
    var count = 1;
    for (var i in draw_data) {
      //var st = Txt.substring(i);
      var node = draw_data[i];
      var idx = parseInt(node.class_id) + 1;
      coord[idx] = new Array();
      coord[idx][0] = node.x;
      coord[idx][1] = node.y;
      //draw_data[i].class_id = count++;
    }

    // coloring
    if (typeof(notColorInternal) == "undefined") {
      for (var i in draw_data) {
        var tmp_vertex = mainSvg.selectAll(".v" + draw_data[i].class_id.toString());
        tmp_vertex[0] = tmp_vertex[0].splice(0,2);
        if (draw_data[i].color == "black") continue;
        if (draw_data[i].color == "orchid")
          tmp_vertex.attr("class", "lcs_first");
        else tmp_vertex.attr("class", "lcs_second");
      }
    } else {
      var internals = new Array();
      for (var i in draw_data) {
        var tmp_vertex = mainSvg.selectAll(".v" + draw_data[i].class_id.toString());
        tmp_vertex[0] = tmp_vertex[0].splice(0,2);
        var tmp = draw_data[i];
        var isInternal = false;
        for (var j in draw_data) {
          if (j == i) continue;
          if (draw_data[j].parent_index == tmp.path_label) {
            isInternal = true;
            break;
          }
        }
        if (isInternal) {
          //tmp_vertex.attr("class", "lcs_internal");
          if (draw_data[i].color != "black")
            internals.push(i);
          continue;
        }
        if (draw_data[i].color == "black") continue;
        if (draw_data[i].color == "orchid")
          tmp_vertex.attr("class", "lcs_first");
        else tmp_vertex.attr("class", "lcs_second");
      }
      return internals;
    }
  } // stGeneralDriver

  function drawGeneralSuffixTree(T, level, prev_x, text) {
    var count = 0, iter=0;
    for (attr in T) {
      if (attr.length == 1) count++;
    }   
    
    var used = new Array(), min = '';
    for (attr in T) 
      if (attr.length == 1) {
        var wAndT2 = T[attr];
        var w = wAndT2.fst;
        var myStr = Txt.substring(w.left, w.right+1);
        used.push(new Node2(myStr, attr));
      }
    for (var i=0; i<used.length-1; i++)
      for (var j=i+1; j<used.length; j++) {
        if (stringCmp(used[i].index, used[j].index) == -1 ) {
          var tmp = used[i];
          used[i] = used[j];
          used[j] = tmp;
        }       
        else if (stringCmp(used[i].index, used[j].index) == 0) {
          if (stringCmp(used[i].word, used[j].word) == -1) {
            var tmp = used[i];
            used[i] = used[j];
            used[j] = tmp;
          }         
        }
      }
    
    var update_prev_x = prev_x;
    var tmp_store = text.split(":");
    var T_idx = text, T_string = text;
    var currentIs1 = false, currentIs2 = false;
    //for(attr in T)//each subtree
      //if(attr.length == 1)//a char attribute selects a suffix-tree branch
    for (var i=0; i < used.length; i++) {
      iter++;
      var attr = used[i];
      if (iter>count/2) break; 
      var wAndT2 = T[attr.index];
      var w = wAndT2.fst, T2 = wAndT2.snd;
      var Str_idx = Txt.substring(w.left, w.right+1);
      var myStr = T_string+ Str_idx ;
      //height = height_level[level];
      var y = (level+1)*height + height_offset;
      //drawVertex(update_prev_x,y,myStr,'black');
      var suffix_idx = -1;
      if (reverse_suffix_table[T_string + Str_idx]) {
        suffix_idx = reverse_suffix_table[T_string + Str_idx];
      }
      draw_data[T_string + Str_idx] = new Node3(T_string + Str_idx, suffix_idx, T_idx, 0, 0, T_string + Str_idx);
      //update_prev_x = Math.max(update_prev_x, drawSuffixTree(T2, level+1, update_prev_x, myStr));
      var tmpNode = drawGeneralSuffixTree(T2, level+1, update_prev_x, myStr);
      currentIs1 = currentIs1 || tmpNode.isString1; currentIs2 = currentIs2 || tmpNode.isString2;
      update_prev_x = Math.max(update_prev_x, tmpNode.prev_x);
    }    
    update_prev_x += width;
    var vertex_name = "";
    var current_x = update_prev_x;
    if (reverse_suffix_table[text] || reverse_suffix_table[text] === 0) vertex_name = reverse_suffix_table[text];
    height = height_level[level];
    if (maxX < update_prev_x) maxX = update_prev_x;
    if (maxY < height) maxY = height;

    var current_height = height;
    A[amountVertex] = new ObjectPair(vertex_name, amountVertex);
    graphWidget.addVertex(update_prev_x, height, A[amountVertex].getFirst(), A[amountVertex++].getSecond(), true);
    if (maxX < update_prev_x) maxX = update_prev_x;
    //drawVertex(update_prev_x, height, vertex_name, 'black');
    if (T_idx == "") {
      draw_data[""] = new Node3(T_string, -1, -2, update_prev_x, level*height + height_offset, "");
      draw_data[T_idx].class_id = amountVertex - 1;
    }
    else {
      draw_data[T_idx].x = update_prev_x;
      draw_data[T_idx].y = height;
      draw_data[T_idx].class_id = amountVertex - 1;
    }
    iter = 0;
    for (var i = 0; i < used.length; i++) {
      iter++;
      if (iter>count/2) {
        var attr = used[i];
        var wAndT2 = T[attr.index];
        var w = wAndT2.fst, T2 = wAndT2.snd;
        var Str_idx = Txt.substring(w.left, w.right+1);

        var myStr = T_string + Str_idx;
        //show(T2, str2, myStr);
        var y = (level+1)*height + height_offset;
        //drawVertex(update_prev_x,y,myStr,'black');
        var suffix_idx = -1;
        if (reverse_suffix_table[T_string + Str_idx]) {
          suffix_idx = reverse_suffix_table[T_string + Str_idx];
        }
        draw_data[T_string + Str_idx] = new Node3(T_string + Str_idx, suffix_idx, T_idx, 0, 0, T_string + Str_idx);
        //update_prev_x = Math.max(update_prev_x, drawSuffixTree(T2, level+1, update_prev_x, myStr));
        var tmpNode = drawGeneralSuffixTree(T2, level+1, update_prev_x, myStr);
        if (!currentIs1) currentIs1 = tmpNode.isString1; 
        if (!currentIs2) currentIs2 = tmpNode.isString2;
        update_prev_x = Math.max(update_prev_x, tmpNode.prev_x);
      }
    }   
 
    if (T.isLeaf) {
        if (text[text.length-1] == '$') currentIs1 = true;
        else currentIs2 = true;       
    }
    
    if (currentIs1 && currentIs2) {
      draw_data[T_idx].color = 'black';    
      //drawVertex(current_x, current_height, vertex_name, 'darkorchid');
    } else if (currentIs1) {
      draw_data[T_idx].color = 'orchid';
      //drawVertex(current_x, current_height, vertex_name, 'black');
    } else {
      draw_data[T_idx].color = 'chartreuse';
      //drawVertex(current_x, current_height, vertex_name, 'chartreuse');
    }
    return new NodeG(update_prev_x, currentIs1, currentIs2);
  }
  
  function show2(T, str, arc, level, node_label) { // print the suffix tree
    if (T == null) // should not happen!
      return; // should not be here
    if (T.isLeaf) { 
      if (node_label.length > height_level[level]) height_level[level] = node_label.length;
      return; // llewop d
    }
    nForks++;
    var attr, iter = 0;
    var spaces = '';  var i;
    for (i = 1; i < arc.length; i++) spaces += ' ';
    spaces += '|';   // |spaces|==|arc|
    var str2 = str+spaces;//nosilla l

    var used = new Array(); 
    var min = '';
    
    for (attr in T) 
      if (attr.length == 1) {
        var wAndT2 = T[attr];
        var w = wAndT2.fst;
        var myStr = Txt.substring(w.left, w.right+1);
        used.push(new Node2(myStr, attr));
      }
    for (var i=0; i<used.length-1; i++)
      for (var j=i+1; j<used.length; j++) {
        if (stringCmp(used[i].index, used[j].index) == -1 ) {
          var tmp = used[i];
          used[i] = used[j];
          used[j] = tmp;
        }       
        else if (stringCmp(used[i].index, used[j].index) == 0) {
          if (stringCmp(used[i].word, used[j].word) == -1) {
            var tmp = used[i];
            used[i] = used[j];
            used[j] = tmp;
          }         
        }
    }
    if (node_label.length > height_level[level]) height_level[level] = node_label.length;
    for (var i=0; i < used.length; i++) {
      iter++;
      attr = used[i];
      var wAndT2 = T[attr.index];
      var w = wAndT2.fst, T2 = wAndT2.snd;
      var myStr = '('+(w.left)+':'+Txt.substring(w.left, w.right+1)+')|';
      var label = node_label + Txt.substring(w.left, w.right + 1);
      
      if (label.indexOf('$') > -1) {
        T[attr.index].fst.right = Txt.indexOf('$');
        wAndT2 = T[attr.index];
        w = wAndT2.fst;
      }
          
      show2(T2, str2, myStr, level+1, Txt.substring(w.left, w.right+1))
    }
  } // show

  function populatePseudocode(act) {
    switch (act) {
      case 0: // Search
        //document.getElementById('code1').innerHTML = 'consider current node';
        // document.getElementById('code2').innerHTML = 'for (i in current node child)';
        // document.getElementById('code3').innerHTML = '&nbsp&nbsp if (i not match)';
        // document.getElementById('code4').innerHTML = '&nbsp&nbsp&nbsp&nbsp continue';
        // document.getElementById('code5').innerHTML = '&nbsp&nbsp if (i is full match) return all results';
        // document.getElementById('code6').innerHTML = '&nbsp&nbsp else if (i is partial match) go deeper';
        // document.getElementById('code7').innerHTML = 'return no match';
        document.getElementById('code1').innerHTML = 'consider current vertex cur';
        document.getElementById('code2').innerHTML = 'for (each child&nbsp;of current vertex cur)';
        document.getElementById('code3').innerHTML = '&nbsp;&nbsp;if (P does not match child.label)';
        document.getElementById('code4').innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;continue';
        document.getElementById('code5').innerHTML = '&nbsp;&nbsp;if (a full match) return all results';
        document.getElementById('code6').innerHTML = '&nbsp;&nbsp;if (a partial match) go deeper';
        document.getElementById('code7').innerHTML = 'return no match';
        break;
      case 1: // LRS
        // document.getElementById('code1').innerHTML = 'result = \'\'';
        // document.getElementById('code2').innerHTML = 'consider current node';
        // document.getElementById('code3').innerHTML = 'for (i in current node child)';
        // document.getElementById('code4').innerHTML = '&nbsp&nbspif i is leave continue';
        // document.getElementById('code5').innerHTML = '&nbsp&nbspelse if (path label length >= result.length)';
        // document.getElementById('code6').innerHTML = '&nbsp&nbsp&nbsp&nbsp update result';
        // document.getElementById('code7').innerHTML = 'return result';
        document.getElementById('code1').innerHTML = 'ans = &#39;&#39;';
        document.getElementById('code2').innerHTML = 'consider current vertex cur';
        document.getElementById('code3').innerHTML = 'for (each child&nbsp;of current vertex cur)';
        document.getElementById('code4').innerHTML = '&nbsp;&nbsp;if (child is a leaf) continue';
        document.getElementById('code5').innerHTML = '&nbsp;&nbsp;if (child.label.length &gt;= ans.length)';
        document.getElementById('code6').innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;ans = child.label';
        document.getElementById('code7').innerHTML = 'return ans';
        break;
      case 2: // LCS step 1, color internal node
        // document.getElementById('code1').innerHTML = 'if curent node is a leaf, return';
        // document.getElementById('code2').innerHTML = 'if current node belongs to string 1 only';
        // document.getElementById('code3').innerHTML = '&nbsp&nbspcolor current node as string 1';
        // document.getElementById('code4').innerHTML = 'if current node belongs to string 2 only';
        // document.getElementById('code5').innerHTML = '&nbsp&nbspcolor current node as string 2';    
        document.getElementById('code1').innerHTML = 'if curent node is a leaf, return';
        document.getElementById('code2').innerHTML = 'if current node belongs to string 1 only';
        document.getElementById('code3').innerHTML = '&nbsp;&nbsp;color current node as string 1';
        document.getElementById('code4').innerHTML = 'if current node belongs to string 2 only';
        document.getElementById('code5').innerHTML = '&nbsp;&nbsp;color current node as string 2';
        break;
      case 3: // LCS main
        // document.getElementById('code1').innerHTML = 'indexing the nodes';
        // document.getElementById('code2').innerHTML = 'max = root';
        // document.getElementById('code3').innerHTML = 'findLCS(current node):';
        // document.getElementById('code4').innerHTML = '&nbsp&nbspif current node is a leaf, return';
        // document.getElementById('code5').innerHTML = '&nbsp&nbspif current node is not common, return';
        // document.getElementById('code6').innerHTML = '&nbsp&nbspif current node length >= max, update max';
        // document.getElementById('code7').innerHTML = '&nbsp&nbspfindLCS(current node\'s children)';      
        document.getElementById('code1').innerHTML = 'indexing the nodes';
        document.getElementById('code2').innerHTML = 'ans = &quot;&quot;';
        document.getElementById('code3').innerHTML = 'findLCS(current vertex cur):';
        document.getElementById('code4').innerHTML = '&nbsp;&nbsp;if (cur is a leaf) return';
        document.getElementById('code5').innerHTML = '&nbsp;&nbsp;if (cur is not a candidate) return';
        document.getElementById('code6').innerHTML = '&nbsp;&nbsp;if (cur.label.length &gt;= ans.length) update';
        document.getElementById('code7').innerHTML = '&nbsp;&nbsp;findLCS(cur&#39;s children)';
        break;
    }
  }
}

// Suffix Tree action
var actionsWidth = 180;
var statusCodetraceWidth = 370;

var isBuildOpen = false;
var isSearchOpen = false;
var isLRSOpen = false;
var isLCSOpen = false;

function openBuild() {
  if (!isBuildOpen) {
    $('.build').fadeIn('fast');
    isBuildOpen = true;
  }
}

function closeBuild() {
  if (isBuildOpen) {
    $('.build').fadeOut('fast');
    $('#build-err').html(""); 
    isBuildOpen = false;
  }
}

function openSearch() {
  if (!isSearchOpen) {
    $('.search').fadeIn('fast');
    isSearchOpen = true;
  }
}

function closeSearch() {
  if (isSearchOpen) {
    $('.search').fadeOut('fast');
    $('#search-err').html("");
    isSearchOpen = false;
  }
}

function openLRS() {
  if (!isLRSOpen) {
    $('.lrs').fadeIn('fast');
    isLRSOpen = true;
  }
}

function closeLRS() {
  if (isLRSOpen) {
    $('.lrs').fadeOut('fast');
    $('#lrs-err').html(""); 
    isLRSOpen = false;
  }
}

function openLCS() {
  if (!isLCSOpen) {
    $('.lcs').fadeIn('fast');
    isLCSOpen = true;
  }
}

function closeLCS() {
  if (isLCSOpen) {
    $('.lcs').fadeOut('fast');
    $('#lcs-err').html(""); 
    isLCSOpen = false;
  }
}

function hideEntireActionsPanel() {
  closeBuild();
  closeSearch();
  closeLRS();
  closeLCS();
  hideActionsPanel();
}



// local
// start by showing actions panel
$('#play').hide();
var stWidget = new SuffixTreeWidget();
var gw = stWidget.getGraphWidget();
var option = ["GATAGACA$", "BANANA$", "MISSISSIPPI$", "AAAAAAA$"];
var currentT = option[Math.floor(Math.random()*4)];
stWidget.buildSuffixTree(currentT);

$(function() {
  $('#build').click(function() {
    closeSearch();
    closeLRS();
    closeLCS();
    openBuild();
  }); 

  $('#search').click(function() {
    closeBuild();
    closeLRS();
    closeLCS();
    openSearch();
  });

  $("#LCS").click(function() {
    closeBuild();
    closeSearch();
    closeLRS();
    openLCS();
  });

  $("#LRS").click(function() {
    closeBuild();
    closeSearch();
    closeLCS();
    openLRS();
  });
});

function buildSuffixTree() {
  if (isPlaying) stop();
  currentT = $("#arrv1").val();
  if (currentT == "" || currentT == "$") currentT = "GATAGACA$";
  currentT = currentT.replace(/\$/g, "") + "$"; // ensure that $ is only used once, and at the back
  $("#arrv1").val(currentT);
  commonAction(stWidget.buildSuffixTree(currentT), "Suffix Tree of \"" + currentT + "\"");
  if (isStatusOpen()) $("#status-hide").click(); // right side is irrelevant after a new build
  if (isCodetraceOpen()) $("#codetrace-hide").click();

  // try {
  //   if (isPlaying) stop();
  // } 
  // catch (err) {}

  // if (mode == "exploration") {
  //   currentT = $("#arrv1").val();
  //   if (currentT == "" || currentT == "$") currentT = "GATAGACA$";
  //   currentT = currentT.replace(/\$/g, "") + "$"; // ensure that $ is only used once, and at the back
  //   $("#arrv1").val(currentT);
  //   stWidget.buildSuffixTree(currentT);
  //   closeBuild();
  //   isPlaying = false;
  // }
}

function goSearch(callback) {
  if (isPlaying) stop();
  var input = $('#search_inp').val();
  commonAction(res = stWidget.goSearch(input, callback), "Search \"" + input + "\"");
console.log('res = ' + res);
  if (!res) {
    if (isStatusOpen()) $("#status-hide").click(); // right side is irrelevant in this bug scenario
    if (isCodetraceOpen()) $("#codetrace-hide").click();
  }
}

function goLRS(callback) {
  if (isPlaying) stop();
  commonAction(stWidget.goLRS(callback), "Find Longest Repeated Substring of \"" + currentT + "\"");
}

function goLCS(callback) {
  if (isPlaying) stop();
  var input1 = $('#s1').val();
  var input2 = $('#s2').val();
  commonAction(stWidget.goLCS(callback), "Find Longest Common Substring of \"" + input1 + "\" and \"" + input2 + "\"");
}
</script>
</body>

<!-- Mirrored from visualgo.net/vi/suffixtree by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 26 Nov 2020 06:40:37 GMT -->
</html>
