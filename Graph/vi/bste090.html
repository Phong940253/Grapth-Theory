<!DOCTYPE html>
<html lang="vi">

<!-- Mirrored from visualgo.net/vi/bst?slide=3-5 by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 26 Nov 2020 06:40:30 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="description" content="A Binary Search Tree (BST) is a binary tree in which each vertex has only up to 2 children that satisfies BST property: All vertices in the left subtree of a vertex must hold a value smaller than its own and all vertices in the right subtree of a vertex must hold a value larger than its own (we have assumption that all values are distinct integers in this visualization and small tweak is needed to cater for duplicates/non integer). Try clicking Search(7) for a sample animation on searching a random value &amp;in; [1..99] in the random BST above.An Adelson-Velskii Landis (AVL) tree is a self-balancing BST that maintains it&#39;s height to be O(log N) when having N vertices in the AVL tree.Click &#39;Next&#39; (on the top right)/press &#39;Page Down&#39; to advance this e-Lecture slide, use the drop down list/press &#39;Space&#39; to jump to a specific slide, or Click &#39;X&#39; (on the bottom right)/press &#39;Esc&#39; to go to Exploration mode.">
<meta name="keywords" content="Binary Search Tree BST Balanced Adelson Velskii Landis AVL Map Set Search Insert Delete Predecessor Successor Inorder VisuAlgo Data Structure Algorithm Visualization Animation Online Learning Tutorial Lecture">
 
<meta name="csrf-token" content="iVivZ7KRPe6XK7pbuGtOoEjljE1xyBVNhLKNFuF8">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/bst.png">
<title>VisuAlgo - Cây Nhị Phân Tìm Kiếm, Cây AVL</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common.css">
<link rel="stylesheet" href="../css/viz-1.0.1.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
      }
      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }
      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
    </style>
<style>
.execAction { padding: 5px 8px; }
.err { padding: 5px 0px; }
#actions-extras input {
  width: 35px;
  padding: 5px 8px 7px;
}

#insert-input input, #remove-input input { width: 100px; }

.create { bottom: 200px; }
.search { bottom: 173px; }
.insert { bottom: 146px; }
.remove { bottom: 119px; }
.predsucc { bottom: 92px; }
.inorder { bottom: 65px; }
</style>
<script>
      function changeURL() {
        var URL = window.location.href.split('https://visualgo.net/');
        var val = document.getElementById("Language").value;
        URL[3] = val;
        window.location.assign(URL.join('https://visualgo.net/'));
      }
    </script>
</head>
<body>
<div id="top-bar">
<a href="http://www.comp.nus.edu.sg/~stevenha"><span class="colour" style="border: 1px solid green; border-radius: 25px;">7</span></a>&nbsp;&nbsp;&nbsp;
<a id="home" href="https://visualgo.net/">Visu<span class="colour">Algo</span><span style="font-size: 40%">.net</span></a>
/
<select id="Language" onchange="changeURL()">
<option value="en">en</option>
<option value="zh">zh</option>
<option value="es">es</option>
<option value="pt">pt</option>
<option value="ru">ru</option>
<option value="id">id</option>
<option value="de">de</option>
<option value="bn">bn</option>
<option value="ja">ja</option>
<option value="ko">ko</option>
<option value="vi" selected>vi</option>
</select>
/bst
<span class="right-links" id="useraccount">Login</span>
<span id="title">
<a id='title-BST' class='selected-viz'>Cây nhị phân tìm kiếm</a>
<a id='title-AVL'>Cây AVL</a>
</span>
<div id="mode-menu">
<div id='mode-button' title='exploration'>Chế độ thăm dò &#9663;</div>
<div id='other-modes'>
<a title='e-Lecture'>Chế độ Bài giảng trực tuyến</a>
</div>
</div>
</div>
<div id="dark-overlay"></div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id='speed-control'>Chậm<div id='speed-input'></div>Nhanh<br></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick=goToBeginning()><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick=stepBackward()><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick=pause()><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick=play()><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick=stepForward()><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick=goToEnd()><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id='viz'></div>
<div id='current-action' class='panel'></div>
<div id='e-lecture' class='panel'></div>
<div id="overlay" hidden></div>
<div id="dropdown-temp-holder" hidden></div>
<div id="electure-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>A Binary Search Tree (BST) is a binary tree in which each vertex has only up to 2 children that satisfies <b>BST property</b>: All vertices in the left subtree of a vertex must hold a value smaller than its own and all vertices in the right subtree of a vertex must hold a value larger than its own (we have assumption that all values are distinct integers in this visualization and small tweak is needed to cater for duplicates/non integer). Try clicking <span class="slide-actions" onclick="doButtonAction1()">Search(7)</span> for a sample animation on searching a random value &in; [1..99] in the random BST above.</p><br><p>An Adelson-Velskii Landis (AVL) tree is a <b>self-balancing</b> BST that maintains it&#39;s height to be O(log <b>N</b>) when having <b>N</b> vertices in the AVL tree.</p><br><p>Click &#39;Next&#39; (on the top right)/press &#39;Page Down&#39; to advance this e-Lecture slide, use the drop down list/press &#39;Space&#39; to jump to a specific slide, or Click &#39;X&#39; (on the bottom right)/press &#39;Esc&#39; to go to Exploration mode.</p>
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
Please <a href="https://visualgo.net/login"><u>login</u></a> if you are a repeated visitor or <a href="https://visualgo.net/login"><u>register</u></a> for an (optional) free account first.</p>
<div id='electure-dropdown'>
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. Binary Search Tree</option>
<option value="2">2. BST & Balanced BST (AVL Tree)</option>
<option value="3">3. Motivation</option>
<option value="3-1">&nbsp;&nbsp;&nbsp;3-1. What Kind of Table ADT?</option>
<option value="3-2">&nbsp;&nbsp;&nbsp;3-2. Using Unsorted Array/Vector</option>
<option value="3-3">&nbsp;&nbsp;&nbsp;3-3. Using Sorted Array/Vector</option>
<option value="3-4">&nbsp;&nbsp;&nbsp;3-4. O(log N) Complexities?</option>
<option value="3-5">&nbsp;&nbsp;&nbsp;3-5. Other Table ADT Operations</option>
<option value="3-6">&nbsp;&nbsp;&nbsp;3-6. The Solution</option>
<option value="3-7">&nbsp;&nbsp;&nbsp;3-7. What about Linked List?</option>
<option value="3-8">&nbsp;&nbsp;&nbsp;3-8. The Solution</option>
<option value="3-9">&nbsp;&nbsp;&nbsp;3-9. What about Hash Table?</option>
<option value="3-10">&nbsp;&nbsp;&nbsp;3-10. The Solution</option>
<option value="4">4. Visualization</option>
<option value="4-1">&nbsp;&nbsp;&nbsp;4-1. BST Vertex Attributes</option>
<option value="4-2">&nbsp;&nbsp;&nbsp;4-2. BST Property</option>
<option value="5">5. BST Operations</option>
<option value="5-1">&nbsp;&nbsp;&nbsp;5-1. A Few Other BST Operations</option>
<option value="5-2">&nbsp;&nbsp;&nbsp;5-2. Static vs Dynamic Data Structure</option>
<option value="6">6. Search(v)</option>
<option value="6-1">&nbsp;&nbsp;&nbsp;6-1. FindMin() and FindMax()</option>
<option value="6-2">&nbsp;&nbsp;&nbsp;6-2. O(h) Time Complexity</option>
<option value="7">7. Successor(v)</option>
<option value="7-1">&nbsp;&nbsp;&nbsp;7-1. Predecessor(v)</option>
<option value="7-2">&nbsp;&nbsp;&nbsp;7-2. O(h) Time Complexity</option>
<option value="8">8. Inorder Traversal</option>
<option value="8-1">&nbsp;&nbsp;&nbsp;8-1. O(N) Time Complexity</option>
<option value="8-2">&nbsp;&nbsp;&nbsp;8-2. The Solution</option>
<option value="8-3">&nbsp;&nbsp;&nbsp;8-3. Preorder and Postorder Traversal</option>
<option value="9">9. Insert(v)</option>
<option value="9-1">&nbsp;&nbsp;&nbsp;9-1. O(h) Time Complexity</option>
<option value="9-2">&nbsp;&nbsp;&nbsp;9-2. Mini Quiz</option>
<option value="10">10. Remove(v) - Three Possible Cases</option>
<option value="10-1">&nbsp;&nbsp;&nbsp;10-1. Remove(v) - Case 1</option>
<option value="10-2">&nbsp;&nbsp;&nbsp;10-2. Remove(v) - Case 2</option>
<option value="10-3">&nbsp;&nbsp;&nbsp;10-3. Remove(v) - Case 3</option>
<option value="10-4">&nbsp;&nbsp;&nbsp;10-4. Remove(v) - Case 3 Discussion</option>
<option value="10-5">&nbsp;&nbsp;&nbsp;10-5. The Answer</option>
<option value="10-6">&nbsp;&nbsp;&nbsp;10-6. O(h) Time Complexity</option>
<option value="11">11. Create BST</option>
<option value="12">12. Intermezzo</option>
<option value="12-1">&nbsp;&nbsp;&nbsp;12-1. Try Exploration Mode</option>
<option value="13">13. Balanced BST</option>
<option value="13-1">&nbsp;&nbsp;&nbsp;13-1. AVL Tree</option>
<option value="13-2">&nbsp;&nbsp;&nbsp;13-2. Extra BST Attribute: height(v)</option>
<option value="13-3">&nbsp;&nbsp;&nbsp;13-3. Formal Definition of height(v)</option>
<option value="13-4">&nbsp;&nbsp;&nbsp;13-4. Mini Quiz</option>
<option value="13-5">&nbsp;&nbsp;&nbsp;13-5. The Lower Bound of BST Height</option>
<option value="13-6">&nbsp;&nbsp;&nbsp;13-6. Derivation of the Lower Bound</option>
<option value="13-7">&nbsp;&nbsp;&nbsp;13-7. The Upper Bound of BST Height</option>
<option value="13-8">&nbsp;&nbsp;&nbsp;13-8. The Solution</option>
<option value="13-9">&nbsp;&nbsp;&nbsp;13-9. The Combined Bound</option>
<option value="14">14. AVL Tree</option>
<option value="14-1">&nbsp;&nbsp;&nbsp;14-1. Step 1: Maintaining height(v) Efficiently</option>
<option value="14-2">&nbsp;&nbsp;&nbsp;14-2. Step 2: Define AVL Tree Invariant</option>
<option value="14-3">&nbsp;&nbsp;&nbsp;14-3. Proof - 1</option>
<option value="14-4">&nbsp;&nbsp;&nbsp;14-4. Proof - 2</option>
<option value="14-5">&nbsp;&nbsp;&nbsp;14-5. Proof - 3</option>
<option value="14-6">&nbsp;&nbsp;&nbsp;14-6. Proof - 4</option>
<option value="14-7">&nbsp;&nbsp;&nbsp;14-7. Step 3: Maintain Invariant</option>
<option value="14-8">&nbsp;&nbsp;&nbsp;14-8. Introducing Tree Rotation</option>
<option value="14-9">&nbsp;&nbsp;&nbsp;14-9. Non-trivial O(1) Tree Rotation Pseudo-code</option>
<option value="14-10">&nbsp;&nbsp;&nbsp;14-10. Four Rebalancing Cases</option>
<option value="14-11">&nbsp;&nbsp;&nbsp;14-11. Insert(v) in AVL Tree</option>
<option value="14-12">&nbsp;&nbsp;&nbsp;14-12. The Answer</option>
<option value="14-13">&nbsp;&nbsp;&nbsp;14-13. Remove(v) in AVL Tree</option>
<option value="14-14">&nbsp;&nbsp;&nbsp;14-14. AVL Tree Summary</option>
<option value="15">15. Extras</option>
<option value="15-1">&nbsp;&nbsp;&nbsp;15-1. Those 2 Extra BST Operations</option>
<option value="15-2">&nbsp;&nbsp;&nbsp;15-2. Side Usage of Balanced BST?</option>
<option value="15-3">&nbsp;&nbsp;&nbsp;15-3. Online Quiz</option>
<option value="15-4">&nbsp;&nbsp;&nbsp;15-4. Online Judge Exercises</option>
<option value="15-5">&nbsp;&nbsp;&nbsp;15-5. The Solution</option>
<option value="99">99. Status Panel</option>
<option value="99-1">&nbsp;&nbsp;&nbsp;99-1. Codetrace Panel</option>
<option value="99-2">&nbsp;&nbsp;&nbsp;99-2. Media Control</option>
<option value="99-3">&nbsp;&nbsp;&nbsp;99-3. Return to &#39;Exploration Mode&#39;</option>
</select>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-next' data-nextid="2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2" class="electure-dialog" style="top:60px;left:280px;width:500px;">
<p>To toggle between the standard Binary Search Tree and the AVL Tree (only different behavior during Insertion and Removal of an Integer), select the respective header.</p><br><p>We also have URL shortcut to quickly access the AVL Tree mode, which is <a href="bstb4ef.html?mode=AVL"><u>https://visualgo.net/en/avl</u></a> (you can change the &#39;en&#39; to your two characters preferred language - if available).</p>
<hr>
<p>Pro-tip: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b> to advance to the next slide, <b>[PageUp]</b> to go back to the previous slide, <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>BST (and especially balanced BST like AVL Tree) is an efficient data structure to implement <i>a certain kind</i> of <b>Table</b> (or <b>Map</b>) Abstract Data Type (ADT).</p><br><p>A Table ADT must support <b>at least</b> the following three operations as efficient as possible:</p><ol><li>Search(v) — determine if <b>v</b> exists in the ADT or not,</li><li>Insert(v) — insert <b>v</b> into the ADT,</li><li>Remove(v) — remove <b>v</b> from the ADT.</li></ol><hr><p>Reference: See <a href="https://visualgo.net/en/hashtable?slide=2-1" target="_blank"><u>similar slide in Hash Table e-Lecture</u></a>.</p>
<hr>
<p>Another pro-tip: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2017). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>We are referring to Table ADT where the keys need to be ordered (as opposed to Table ADT where the keys do not need to be unordered).</p><br><p>This special requirement of Table ADT will be made clearer in the next few slides.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>If we use <b>unsorted</b> array/vector to implement Table ADT, it can be inefficient:</p><ol><li>Search(v) runs in O(<b>N</b>), as we may end up exploring all <b>N</b> elements of the ADT if <b>v</b> actually does not exist,</li><li>Insert(v) can be implemented in O(<b>1</b>), just put <b>v</b> at the back of the array,</li><li>Remove(v) runs in O(<b>N</b>) too as we have to first search for <b>v</b> which is already O(<b>N</b>) and later close the resulting gap after deletion — also in O(<b>N</b>).</li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>If we use <b>sorted</b> array/vector to implement Table ADT, we can improve the Search(v) performance but weakens the Insert(v) performance:</p><ol><li>Search(v) can now be implemented in O(log <b>N</b>), as we can now use <b>binary search</b> on the sorted array,</li><li>Insert(v) now runs in O(<b>N</b>) as we need to implement an insertion-sort like strategy to make the array remains sorted,</li><li>Remove(v) runs in O(<b>N</b>) because even if Search(v) runs in O(log <b>N</b>), we still need to close the gap after deletion &mdash; which is in O(<b>N</b>).</ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-4" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>The goal for this e-Lecture is to introduce BST and then balanced BST (AVL Tree) data structure so that we can implement the basic Table ADT operations: Search(v), Insert(v), Remove(v), <b>and a few other Table ADT operations</b> — see the next slide — in O(log <b>N</b>) time — which is much smaller than <b>N</b>.</p><br><p>PS: Some of the more experienced readers may notice that &exist; <a href="hashtable7d66.html?slide=11-4"><u>another data structure</u></a> that can implement the three basic Table ADT operations in faster time, but read on...</p><br><table style="width: 100%; border: 1px solid white"><tbody><tr><td><b>N</b></td><td>≈ 1 000</td><td>≈ 1 000 000</td><td>≈ 1 000 000 000</td></tr><tr><td>log <b>N</b></td><td>10</td><td>Only 20 :O</td><td>Only 30 :O:O</td></tr></tbody></table>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-5" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>On top of the basic three, there are a few other possible Table ADT operations:</p><ol><li>Find the Min()/Max() element,</li><li>Find the Successor(v) &mdash; &#39;next larger&#39;/Predecessor(v) &mdash; &#39;previous smaller&#39; element,</li><li>List elements in sorted order,</li><li>Operation X &amp; Y - hidden for pedagogical purpose in an NUS module,</li><li>There are others possible operations.</li></ol><p>Discussion: What are the best possible implementation for the first three additional operations if we are limited to use [sorted|unsorted] array/vector?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-6">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-6" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-7">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-7" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>The simpler data structure that can be used to implement Table ADT is <a href="list.html"><u>Linked List</u></a>.</p><br><input class="mcq-answer" id="mcq-answer-16" value="70" hidden><p>Quiz: <b>Can we perform all basic three Table ADT operations: Search(v)/Insert(v)/Remove(v) efficiently (read: faster than O(<b>N</b>)) using Linked List?</b></p><form><input type="radio" name="mcq-16-choice" value="70"> No<br><input type="radio" name="mcq-16-choice" value="69"> Yes<br></form><button class="mcq-submit" id="submit-16">Submit</button> <span id="answer-status-16"></span><br><br><p>Discussion: Why?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-6">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-8">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-8" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-7">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-9">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-9" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Another data structure that can be used to implement Table ADT is <a href="hashtable.html"><u>Hash Table</u></a>. It has very fast Search(v), Insert(v), and Remove(v) performance (all in expected O(<b>1</b>) time).</p><br><input class="mcq-answer" id="mcq-answer-17" value="72" hidden><p>Quiz: <b>So what is the point of learning this BST module if Hash Table can do the crucial Table ADT operations in unlikely-to-be-beaten expected O(<b>1</b>) time?</b></p><form><input type="radio" name="mcq-17-choice" value="72"> There are valid reasons, which are ____<br><input type="radio" name="mcq-17-choice" value="71"> There is no point, so this BST module can be ignored<br></form><button class="mcq-submit" id="submit-17">Submit</button> <span id="answer-status-17"></span><br><br><p>Discuss the answer above! Hint: Go back to the previous 4 slides ago.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-8">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-10">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-10" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-9">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>We will now introduce BST data structure. See the visualization of an example BST above!</p><br><p>Root vertex does not have a parent. There can only be one root vertex in a BST. Leaf vertex does not have any child. There can be more than one leaf vertex in a BST. Vertices that are not leaf are called the internal vertices. Sometimes root vertex is not included as part of the definition of internal vertex as the root of a BST with only one vertex can actually fit into the definition of a leaf too.</p><br><p>In the example above, vertex 15 is the root vertex, vertex {5, 7, 50} are the leaves, vertex {4, 6, 15 (also the root), 23, 71} are the internal vertices.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-10">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Each vertex has <b>at least</b> 4 attributes: parent, left, right, key/value/data (there are potential other attributes). Not all attributes will be used for all vertices, e.g. the root vertex will have its parent attribute = NULL. Some other implementation separates key (for ordering of vertices in the BST) with the actual <i>satellite data</i> associated with the keys.</p><br><p>The left/right child of a vertex (except leaf) is drawn on the left/right and below of that vertex, respectively. The parent of a vertex (except root) is drawn above that vertex. The (integer) key of each vertex is drawn inside the circle that represent that vertex. In the example above, (key) 15 has 6 as its left child and 23 as its right child. Thus the parent of 6 (and 23) is 15.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>As we do not allow duplicate integer in this visualization, the BST property is as follow: For every vertex X, all vertices on the left subtree of X are <b>strictly</b> smaller than X and all vertices on the right subtree of X are <b>strictly</b> greater than X.</p><br><p>In the example above, the vertices on the left subtree of the root 15: {4, 5, 6, 7} are all smaller than 15 and the vertices on the right subtree of the root 15: {23, 50, 71} are all greater than 15. You can recursively check BST property on other vertices too.</p><br><p>For more complete implementation, we should consider duplicate integers too and we must consistently place integers that are equal to X to one subtree only (not arbitrary).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5" class="electure-dialog" style="bottom:240px;left:60px;width:500px;">
<p>We provide visualization for the following common BST/AVL Tree operations:</p><ol><li>Query operations (the BST structure remains unchanged):<ol><li>Search(v),</li><li>Predecessor(v) (and similarly Successor(v)), and</li><li>Inorder Traversal (<i>we will add Preorder and Postorder Traversal soon</i>),</li></ol></li><li>Update operations (the BST structure may likely change):<ol><li>Insert(v),</li><li>Remove(v), and</li><li>Create BST (several criteria).</li></ol></li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-1" class="electure-dialog" style="bottom:240px;left:60px;width:500px;">
<p>There are a few other BST (Query) operations that have not been visualized in VisuAlgo:</p><ol><li>Rank(v): Given a key <b>v</b>, determine what is its rank (1-based index) in the sorted order of the BST elements. That is, Rank(FindMin()) = 1 and Rank(FindMax()) = <b>N</b>. If <b>v</b> does not exist, we can report -1.</li><li>Select(k): Given a rank <b>k</b>, 1 ≤ <b>k</b> ≤ <b>N</b>, determine the key <b>v</b> that has that rank <b>k</b> in the BST. Or in another word, find the <b>k</b>-th smallest element in the BST. That is, Select(1) = FindMin() and Select(<b>N</b>) = FindMax().</li></ol><p>The details of these two operations are currently hidden for pedagogical purpose in a certain NUS module.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-2" class="electure-dialog" style="bottom:240px;left:60px;width:500px;">
<p>Data structure that is only efficient if there is no (or rare) update, especially the insert and/or remove operation(s) is called <b>static</b> data structure.</p><br><p>Data structure that is efficient even if there are many update operations is called <b>dynamic</b> data structure. BST and especially balanced BST (e.g. AVL Tree) are in this category.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="6">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-6" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Because of the way data (distinct integers for this visualization) is organised inside a BST, we can <b>binary</b> search for an integer <b>v</b> efficiently (hence the name of <b>Binary Search</b> Tree).</p><br><p>First, we set the current vertex = root and then check if the current vertex is smaller/equal/larger than integer <b>v</b> that we are searching for. We then go to the right subtree/stop/go the left subtree, respectively. We keep doing this until we either find the required vertex or we don&#39;t.</p><br><p>On the example BST above, try clicking <span class="slide-actions" onclick="doButtonAction2()">Search(15)</span> (found after just 1 comparison), <span class="slide-actions" onclick="doButtonAction1()">Search(7)</span> (found after 3 comparisons), <span class="slide-actions" onclick="doButtonAction3()">Search(21)</span> (not found after 3 comparisons).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="6-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-6-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Similarly, because of the way data is organised inside a BST, we can find the minimum/maximum element (an integer in this visualization) by starting from root and keep going to the left/right subtree, respectively.</p><br><p>Try clicking <span class="slide-actions" onclick="doButtonAction52()">FindMin()</span> and <span class="slide-actions" onclick="doButtonAction53()">FindMax()</span> on the example BST shown above. The answers should be 4 and 71 (both after 4 comparisons).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="6-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-6-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Search(v)/FindMin()/FindMax() operations run in O(<b>h</b>) where <b>h</b> is the height of the BST.</p><br><p>But note that this <b>h</b> can be as tall as O(<b>N</b>) in a normal BST as shown in the random &#39;skewed right&#39; example above. Try <span class="slide-actions" onclick="doButtonAction5()">Search(100)</span> (this value should not exist as we only use random integers between [1..99] to generate this random BST and thus the Search routine should check all the way from root to the only leaf in O(<b>N</b>) time &mdash; not efficient.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Because of the BST properties, we can find the Successor of an integer <b>v</b> (assume that we already know where integer <b>v</b> is located from earlier call of Search(<b>v</b>)) as follows:</p><ol><li>If <b>v</b> has a right subtree, the minimum integer in the right subtree of <b>v</b> must be the successor of <b>v</b>. Try <span class="slide-actions" onclick="doButtonAction6()">Successor(23)</span> (should be 50).</li><li>If <b>v</b> does not have a right subtree, we need to traverse the ancestor(s) of <b>v</b> until we find &#39;a right turn&#39; to vertex <b>w</b> (or alternatively, until we find the first vertex <b>w</b> that is greater than vertex <b>v</b>). Once we find vertex <b>w</b>, we will see that vertex <b>v</b> is the maximum element in the left subtree of <b>w</b>. Try <span class="slide-actions" onclick="doButtonAction54()">Successor(7)</span> (should be 15).</li><li>If <b>v</b> is the maximum integer in the BST, <b>v</b> does not have a successor. Try <span class="slide-actions" onclick="doButtonAction55()">Successor(71)</span> (should be none).</li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>The operations for Predecessor of an integer <b>v</b> are defined similarly (just the mirror of Successor operations).</p><br><p>Try the same three corner cases (but mirrored): <span class="slide-actions" onclick="doButtonAction56()">Predecessor(6)</span> (should be 5), <span class="slide-actions" onclick="doButtonAction57()">Predecessor(50)</span> (should be 23), <span class="slide-actions" onclick="doButtonAction58()">Predecessor(4)</span> (should be none).</p><br><p>At this point, stop and ponder these three Successor(v)/Predecessor(v) cases to ensure that you understand these concepts.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Predecessor(v) and Successor(v) operations run in O(<b>h</b>) where <b>h</b> is the height of the BST.</p><br><p>But recall that this <b>h</b> can be as tall as O(<b>N</b>) in a normal BST as shown in the random &#39;skewed right&#39; example above. If we call <span class="slide-actions" onclick="doButtonAction64()">Successor(FindMax())</span>, we will go up from that last leaf back to the root in O(<b>N</b>) time &mdash; not efficient.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="8">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-8" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>We can perform an <b>Inorder Traversal</b> of this BST to obtain a list of sorted integers inside this BST (in fact, if we &#39;flatten&#39; the BST into one line, we will see that the vertices are ordered from smallest/leftmost to largest/rightmost).</p><br><p>Inorder Traversal is a recursive method whereby we visit the left subtree first, exhausts all items in the left subtree, visit the current root, before exploring the right subtree and all items in the right subtree. Without further ado, let&#39;s try <span class="slide-actions" onclick="doButtonAction59()">Inorder Traversal</span> to see it in action on the example BST above.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="8-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-8-1" class="electure-dialog" style="top:300px;left:50%;margin-left:-250px;width:500px;">
<p>Inorder Traversal runs in O(<b>N</b>), regardless of the height of the BST.</p><br><p>Discussion: Why?</p><br><p>PS: Some people call insertion of <b>N</b> unordered integers into a BST in O(<b>N</b> log <b>N</b>) and then performing the O(<b>N</b>) Inorder Traversal as &#39;<b>BST sort</b>&#39;. It is rarely used though as there are several easier-to-use (comparison-based) <a href="sorting.html"><u>sorting algorithms</u></a> than this.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="8">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="8-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-8-2" class="electure-dialog" style="top:300px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="8-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="8-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-8-3" class="electure-dialog" style="top:300px;left:50%;margin-left:-250px;width:500px;">
<p>We have not included the animation of these two other classic tree traversal methods, <i>but we will do so very soon</i>.</p><br><p>But basically, in Preorder Traversal, we visit the current root before going to left subtree and then right subtree. For the example BST shown in the background, we have: {{15}, {6, 4, 5, 7}, {23, 71, 50}}. PS: Do you notice the recursive pattern? root, members of left subtree of root, members of right subtree of root.</p><br><p>In Postorder Traversal, we visit the left subtree and right subtree first, before visiting the current root. For the example BST shown in the background, we have: {{5, 4, 7, 6}, {50, 71, 23}, {15}}.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="8-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="9">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-9" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>We can insert a new integer into BST by doing similar operation as <b>Search(v)</b>. But this time, instead of reporting that the new integer is not found, we create a new vertex in the insertion point and put the new integer there. Try <span class="slide-actions" onclick="doButtonAction60()">Insert(60)</span> on the example above.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="8-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="9-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-9-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p><b>Insert(v)</b> runs in O(<b>h</b>) where <b>h</b> is the height of the BST.</p><br><p>By now you should be aware that this <b>h</b> can be as tall as O(<b>N</b>) in a normal BST as shown in the random &#39;skewed right&#39; example above. If we call <span class="slide-actions" onclick="doButtonAction65()">Insert(FindMax()+1)</span>, i.e. we insert a new integer greater than the current max, we will go from root down to the last leaf and then insert the new integer as the right child of that last leaf in O(<b>N</b>) time — not efficient (note that we only allow up to h=9 in this visualization).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="9-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-9-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<input class="mcq-answer" id="mcq-answer-20" value="88" hidden><p>Quiz: <b>Inserting integers [1,10,2,9,3,8,4,7,5,6] one by one in that order into an initially empty BST will result in a BST of height:</b></p><form><input type="radio" name="mcq-20-choice" value="90"> The height cannot be determined<br><input type="radio" name="mcq-20-choice" value="89"> 8<br><input type="radio" name="mcq-20-choice" value="87"> 10<br><input type="radio" name="mcq-20-choice" value="88"> 9<br></form><button class="mcq-submit" id="submit-20">Submit</button> <span id="answer-status-20"></span><br><br><p>Pro-tip: You can use the &#39;Exploration mode&#39; to verify the answer.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="10">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-10" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>We can remove an integer in BST by performing similar operation as <b>Search(v)</b>.</p><br><p>If <b>v</b> is not found in the BST, we simply do nothing.</p><br><p>If <b>v</b> is found in the BST, we do not report that the existing integer <b>v</b> is found, but instead, we perform one of the three possible removal cases that will be elaborated in three separate slides (we suggest that you try each of them one by one).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="10-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-10-1" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>The first case is the easiest: Vertex <b>v</b> is currently one of the leaf vertex of the BST.</p><br><p>Deletion of a leaf vertex is very easy: We just remove that leaf vertex &mdash; try <span class="slide-actions" onclick="doButtonAction61()">Remove(5)</span> on the example BST above (second click onwards after the first removal will do nothing &mdash; please refresh this page or go to another slide and return to this slide instead).</p><br><p>This part is clearly O(<b>1</b>) &mdash; on top of the earlier O(<b>h</b>) search-like effort.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="10">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="10-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-10-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>The second case is also not that hard: Vertex <b>v</b> is an (internal/root) vertex of the BST and it has <b>exactly one child</b>. Removing <b>v</b> without doing anything else will disconnect the BST.</p><br><p>Deletion of a vertex with one child is not that hard: We connect that vertex&#39;s only child with that vertex&#39;s parent &mdash; try <span class="slide-actions" onclick="doButtonAction62()">Remove(23)</span> on the example BST above (second click onwards after the first removal will do nothing &mdash; please refresh this page or go to another slide and return to this slide instead).</p><br><p>This part is also clearly O(<b>1</b>) &mdash; on top of the earlier O(<b>h</b>) search-like effort.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="10-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="10-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-10-3" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>The third case is the most complex among the three: Vertex <b>v</b> is an (internal/root) vertex of the BST and it has <b>exactly two children</b>. Removing <b>v</b> without doing anything else will disconnect the BST.</p><br><p>Deletion of a vertex with two children is as follow: We replace that vertex with its successor, and then delete its duplicated successor in its right subtree &mdash; try <span class="slide-actions" onclick="doButtonAction63()">Remove(6)</span> on the example BST above (second click onwards after the first removal will do nothing &mdash; please refresh this page or go to another slide and return to this slide instead).</p><br><p>This part requires O(<b>h</b>) due to the need to find the successor vertex &mdash; on top of the earlier O(<b>h</b>) search-like effort.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="10-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="10-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-10-4" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>This case 3 warrants further discussions:</p><ol><li>Why replacing a vertex <b>B</b> that has two children with its successor <b>C</b> is always a valid strategy?</li><li>Can we replace vertex <b>B</b> that has two children with its predecessor <b>A</b> instead? Why or why not?</li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="10-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="10-5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-10-5" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="10-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="10-6">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-10-6" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p><b>Remove(v)</b> runs in O(<b>h</b>) where <b>h</b> is the height of the BST. Removal case 3 (deletion of a vertex with two children is the &#39;heaviest&#39; but it is not more than O(<b>h</b>)).</p><br><p>As you should have fully understand by now, <b>h</b> can be as tall as O(<b>N</b>) in a normal BST as shown in the random &#39;skewed right&#39; example above. If we call <span class="slide-actions" onclick="doButtonAction66()">Remove(FindMax())</span>, i.e. we remove the current max integer, we will go from root down to the last leaf in O(<b>N</b>) time before removing it &mdash; not efficient.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="10-5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="11">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-11" class="electure-dialog" style="bottom:260px;left:60px;width:500px;">
<p>To make life easier in &#39;Exploration Mode&#39;, you can create a new BST using these options:</p><ol><li><b>Empty</b> BST (you can then insert a few integers one by one),</li><li>The two <b>e-Lecture Examples</b> that you may have seen several times so far,</li><li><b>Random</b> BST (which unlikely to be extremely tall),</li><li><b>Skewed Left/Right</b> BST (tall BST with <b>N</b> vertices and <b>N-1</b> linked-list like edges, to showcase the worst case behavior of BST operations; disabled in AVL Tree mode).</li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="10-6">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="12">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-12" class="electure-dialog" style="top:100px;right:60px;width:500px;">
<p>We are midway through the explanation of this BST module. So far we notice that many basic Table ADT operations run in O(<b>h</b>) and <b>h</b> can be as tall as <b>N-1</b> edges like the &#39;skewed left&#39; example shown — inefficient :(...</p><br><p>So, is there a way to make our BSTs &#39;not that tall&#39;?</p><hr><p>PS: If you want to study how these basic BST operations are implemented in a real program, you can download this <a href="http://www.comp.nus.edu.sg/~stevenha/cs2040c/demos/BSTDemo.cpp" target="_blank"><u>BSTDemo.cpp</u></a>.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="11">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="12-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-12-1" class="electure-dialog" style="top:100px;right:60px;width:500px;">
<p>At this point, we encourage you to press [Esc] or click the X button on the bottom right of this e-Lecture slide to enter the &#39;Exploration Mode&#39; and try various BST operations yourself to strengthen your understanding about this versatile data structure.</p><br><p>When you are ready to continue with the explanation of <b>balanced</b> BST (we use <b>AVL Tree</b> as our example), press [Esc] again or switch the mode back to &#39;e-Lecture Mode&#39; from the top-right corner drop down menu. Then, use the slide selector drop down list to resume from <a href="bstb2fa.html?slide=12-1"><u>this slide 12-1</u></a>.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="12">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="13">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-13" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>We have seen from earlier slides that most of our BST operations except Inorder traversal runs in O(<b>h</b>) where <b>h</b> is the height of the BST that can be as tall as <b>N-1</b>.</p><br><p>We will continue our discussion with the concept of <b>balanced BST</b> so that <b>h</b> = O(log <b>N</b>).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="12-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-13-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>There are several known implementations of balanced BST, too many to be visualized and explained one by one in VisuAlgo.</p><br><p>We focus on <b>AVL Tree</b> (Adelson-Velskii & Landis, 1962) that is named after its inventor: Adelson-Velskii and Landis.</p><br><p>Other balanced BST implementations (more or less as good or slightly better in terms of constant-factor performance) are: Red-Black Tree, B-trees/2-3-4 Tree (Bayer & McCreight, 1972), Splay Tree (Sleator and Tarjan, 1985), Skip Lists (Pugh, 1989), Treaps (Seidel and Aragon, 1996), etc.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-13-2" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>To facilitate AVL Tree implementation, we need to <b>augment</b> &mdash; add more information/attribute to &mdash; each BST vertex.</p><br><p>For each vertex <b>v</b>, we define <b>height(v)</b>: The number of edges on the path from vertex <b>v</b> down to its deepest leaf. This attribute is saved in each vertex so we can access a vertex&#39;s height in O(<b>1</b>) without having to recompute it every time.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-13-3" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>Formally:</p><pre>v.height = -1 (if v is an empty tree)<br>v.height = max(v.left.height, v.right.height) + 1 (otherwise)</pre>The height of the BST is thus: <samp>root.height</samp>.<p></p><br><p>On the example BST above, height(11) = height(32) = height(50) = height(72) = height(99) = 0 (all are leaves). height(29) = 1 as there is 1 edge connecting it to its only leaf 32.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-13-4" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<input class="msq-answer" id="msq-answer-18" value="73,75,77" hidden><p>Quiz: <b>What are the values of height(20), height(65), and height(41) on the BST above?</b></p><input type="checkbox" class="msq-choice" id="msq-18-choice-73"> height(41) = 3<br><input type="checkbox" class="msq-choice" id="msq-18-choice-77"> height(20) = 2<br><input type="checkbox" class="msq-choice" id="msq-18-choice-74"> height(41) = 4<br><input type="checkbox" class="msq-choice" id="msq-18-choice-75"> height(65) = 2<br><input type="checkbox" class="msq-choice" id="msq-18-choice-78"> height(20) = 3<br><input type="checkbox" class="msq-choice" id="msq-18-choice-76"> height(65) = 3<br><button class="msq-submit" id="submit-18">Submit</button> <span id="answer-status-18"></span>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-13-5" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>If we have <b>N</b> elements/items/keys in our BST, the lower bound height <b>h</b> &gt; log<sub>2</sub> <b>N</b> if we can somehow insert the <b>N</b> elements in perfect order so that the BST is perfectly balanced.</p><br><p>See the example shown above for <b>N = 15</b> (a perfect BST which is rarely achievable in real life &mdash; try inserting any other integer and it will not be perfect anymore).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-6">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-13-6" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<pre>N &le; 1 + 2 + 4 + ... + 2<sup>h</sup><br>N &le; 2<sup>0</sup> + 2<sup>1</sup> + 2<sup>2</sup> + … + 2<sup>h</sup><br>N &lt; 2<sup>h+1</sup> (sum of geometric progression)<br>log<sub>2</sub> N &lt; log<sub>2</sub> 2<sup>h+1</sup><br>log<sub>2</sub> N &lt; (h+1) * log<sub>2</sub> 2 (log<sub>2</sub> 2 is 1)<br>h &gt; (log<sub>2</sub> N)-1 (algebraic manipulation)<br>h &gt; log<sub>2</sub> N</pre>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-7">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-13-7" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>If we have <b>N</b> elements/items/keys in our BST, the upper bound height <b>h</b> &lt; <b>N</b> if we insert the elements in ascending order (to get skewed right BST as shown above).</p><br><p>The height of such BST is <samp>h = N-1</samp>, so we have <samp>h &lt; N</samp>.</p><br><p>Discussion: Do you know how to get skewed left BST instead?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-6">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-8">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-13-8" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-7">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-9">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-13-9" class="electure-dialog" style="top:310px;left:50%;margin-left:-250px;width:500px;">
<p>We have seen that most BST operations are in O(<b>h</b>) and combining the lower and upper bounds of <b>h</b>, we have log<sub>2</sub> <b>N</b> &lt; <b>h</b> &lt; <b>N</b>.</p><br><p>There is a dramatic difference between log<sub>2</sub> <b>N</b> and <b>N</b> and we have seen from the discussion of the lower bound that getting perfect BST (at all times) is near impossible...</p><br><p>So can we have BST that has height closer to log<sub>2</sub> <b>N</b>, i.e. <b>c</b> * log<sub>2</sub> <b>N</b>, for a small constant factor <b>c</b>? If we can, then BST operations that run in O(<b>h</b>) actually run in O(log <b>N</b>)...</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-8">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<p>Introducing AVL Tree, invented by two Russian (Soviet) inventors: Georgy Adelson-Velskii and Evgenii Landis, back in 1962.</p><br><p>In AVL Tree, we will later see that its height <b>h</b> &lt; 2 * log <b>N</b> (tighter analysis exist, but we will use easier analysis in VisuAlgo where <b>c = 2</b>). Therefore, most AVL Tree operations run in O(log <b>N</b>) time &mdash; efficient.</p><br><p>Insert(v) and Remove(v) update operations may change the height <b>h</b> of the AVL Tree, but we will see <b>rotation</b> operation(s) to maintain the AVL Tree height to be low.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-9">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-1" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<p>To have efficient performance, we shall not maintain <b>height(v)</b> attribute via the O(<b>N</b>) recursive method every time there is an update (Insert(v)/Remove(v)) operation.</p><br><p>Instead, we compute O(<b>1</b>): <samp>x.height = max(x.left.height, x.right.height) + 1</samp> at the back of our Insert(v)/Remove(v) operation as only the height of vertices along the insertion/removal path may be affected. Thus, only O(<b>h</b>) vertices may change its <b>height(v)</b> attribute and in AVL Tree, <b>h</b> &lt; 2 * log <b>N</b>.</p><br><p>Try <span class="slide-actions" onclick="doButtonAction69()">Insert(37)</span> on the example AVL Tree (ignore the resulting rotation for now, we will come back to it in the next few slides). Notice that only a few vertices along the insertion path: {41,20,29,32} increases their height by +1 and all other vertices will have their heights unchanged.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-2" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<p>Let&#39;s define the following important AVL Tree invariant (property that will never change): A vertex <b>v</b> is said to be <b>height-balanced</b> if <samp>|v.left.height - v.right.height| &le; 1</samp>.</p><br><p>A BST is called height-balanced according to the invariant above if every vertex in the BST is height-balanced. Such BST is called AVL Tree, like the example shown above.</p><br><p>Take a moment to pause here and try inserting a few new random vertices or deleting a few random existing vertices. Will the resulting BST still considered height-balanced?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-3" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<p>Adelson-Velskii and Landis claim that an AVL Tree (a height-balanced BST that satisfies AVL Tree invariant) with <b>N</b> vertices has height <b>h</b> &lt; 2 * log<sub>2</sub> <b>N</b>.</p><br><p>The proof relies on the concept of minimum-size AVL Tree of a certain height <b>h</b>.</p><br><p>Let <b>N<sub>h</sub></b> be the minimum number of vertices in a height-balanced AVL Tree of height <b>h</b>.</p><br><p>The first few values of <b>N<sub>h</sub></b> are <b>N<sub>0</sub> = 1</b> (a single root vertex), <b>N<sub>1</sub> = 2</b> (a root vertex with either one left child or one right child only), <b>N<sub>2</sub> = 4</b>, <b>N<sub>3</sub> = 7</b>, <b>N<sub>4</sub> = 12</b>, <b>N<sub>5</sub> = 20</b> (see the background picture), and so on (see the next two slides).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-4" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<p>We know that for any other AVL Tree of <b>N</b> vertices (not necessarily the minimum-size one), we have <b>N ≥ N<sub>h</sub></b>.</p><br><img src="../img/bst_min_avl1.png" alt="Proof-2"><br><p>In the background picture, we have <b>N<sub>5</sub> = 20</b> vertices but we know that we can squeeze 43 more vertices (up to <b>N = 63</b>) before we have a perfect binary tree of height <b>h = 5</b>.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-5" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<pre>N<sub>h</sub> = 1 + N<sub>h-1</sub> + N<sub>h-2</sub> (formula for minimum-size AVL tree of height h)<br>N<sub>h</sub> &gt; 1 + 2*N<sub>h-2</sub> (as N<sub>h-1</sub> > N<sub>h-2</sub>)<br>N<sub>h</sub> &gt; 2*N<sub>h-2</sub> (obviously)<br>N<sub>h</sub> &gt; 4*N<sub>h-4</sub> (recursive)<br>N<sub>h</sub> &gt; 8*N<sub>h-6</sub> (another recursive step)<br>... (we can only do this h/2 times, assuming initial h is even)<br>N<sub>h</sub> &gt; 2<sup>h/2</sup>*N<sub>0</sub> (we reach base case)<br>N<sub>h</sub> &gt; 2<sup>h/2</sup> (as N<sub>0</sub> = 1)</pre><img style="width: 100%" src="../img/bst_min_avl2.png" alt="Proof-3">
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-6">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-6" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<pre>N &ge; N<sub>h</sub> &gt; 2<sup>h/2</sup> (combining the previous two slides)<br>N &gt; 2<sup>h/2</sup><br>log<sub>2</sub>(N) &gt; log<sub>2</sub>(2<sup>h/2</sup>) (log<sub>2</sub> on both sides)<br>log<sub>2</sub>(N) &gt; h/2 (formula simplification)<br>2 * log<sub>2</sub>(N) &gt; h or h &lt; 2 * log<sub>2</sub>(N)<br>h = O(log(N)) (the final conclusion)</pre><img src="../img/bst_min_avl3.png" alt="Proof-4">
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-7">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-7" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<p>Look at the example BST again. See that all vertices are height-balanced, an AVL Tree.</p><br><p>To quickly detect if a vertex <b>v</b> is height balanced or not, we modify the AVL Tree invariant (that has absolute function inside) into: <samp>bf(v) = v.left.height - v.right.height</samp>.</p><br><p>Now try <span class="slide-actions" onclick="doButtonAction69()">Insert(37)</span> on the example AVL Tree again. A few vertices along the insertion path: {41,20,29,32} increases their height by +1. Vertices {29,20} will no longer be height-balanced after this insertion (and will be rotated later &mdash; discussed in the next few slides), i.e. bf(29) = -2 and bf(20) = -2 too. We need to restore the balance.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-6">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-8">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-8" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<img src="../img/tree_rotation.png" alt="Tree Rotation" width="500"><br><p>See the picture above. Calling <b>rotateRight(Q)</b> on the left picture will produce the right picture. Calling <b>rotateLeft(P)</b> on the right picture will produce the left picture again.</p><br><p><b>rotateRight(T)</b>/<b>rotateLeft(T)</b> can only be called if <b>T</b> has a left/right child, respectively.</p><br><p>Tree Rotation <b>preserves</b> BST property. Before rotation, P &le; B &le; Q. After rotation, notice that subtree rooted at B (if it exists) changes parent, but P &le; B &le; Q does not change.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-7">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-9">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-9" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<pre>BSTVertex rotateLeft(BSTVertex T) // pre-req: T.right != null<br>  BSTVertex w = T.right // rotateRight is the mirror copy of this<br>  w.parent = T.parent // this method is hard to get right for newbie<br>  T.parent = w<br>  T.right = w.left<br>  if (w.left != null) w.left.parent = T<br>  w.left = T<br>  // update the height of T and then w here<br>  return w</pre>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-8">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-10">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-10" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<img src="../img/four_cases.png" alt="Four Cases" width="500"><br><p>Basically, there are only these four imbalance cases. We use Tree Rotation(s) to deal with each of them.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-9">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-11">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-11" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<ol><li>Just insert <b>v</b> as in normal BST,</li><li>Walk up the AVL Tree from the insertion point back to the root and at every step, we update the height and balance factor of the affected vertices:<ol type="a"><li>Stop at the <b>first</b> vertex that is out-of-balance (+2 or -2), if any,</li><li>Use <b>one</b> of the four tree rotation cases to rebalance it again, e.g. try <span class="slide-actions" onclick="doButtonAction69()">Insert(37)</span> on the example above and notice by calling <b>rotateLeft(29)</b> once, we fix the imbalance issue.</li></ol></li></ol><p>Discussion: Is there other tree rotation cases for Insert(v) operation of AVL Tree?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-10">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-12">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-12" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-11">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-13">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-13" class="electure-dialog" style="top:350px;left:50%;margin-left:-250px;width:500px;">
<ol><li>Just remove <b>v</b> as in normal BST (one of the three removal cases),</li><li>Walk up the AVL Tree from the deletion point back to the root and at every step, we update the height and balance factor of the affected vertices:<ol><li>Now for <b>every</b> vertex that is out-of-balance (+2 or -2), we use <b>one</b> of the four tree rotation cases to rebalance <b>them</b> (can be more than one) again.</li></ol></li></ol><p>The main difference compared to Insert(v) in AVL tree is that we may trigger one of the four possible rebalancing cases <b>several times</b>, but not more than <b>h</b> = O(log <b>N</b>) times :O, try <span class="slide-actions" onclick="doButtonAction68()">Remove(7)</span> on the example above to see two chain reactions <b>rotateRight(6)</b> and then <b>rotateRight(16)+rotateLeft(8)</b> combo.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-12">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-14">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-14" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-13">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="15">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-15" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>We will end this module with a few more interesting things about BST and balanced BST (especially AVL Tree).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-14">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="15-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-15-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="15">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="15-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-15-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="15-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="15-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-15-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>For a few more interesting questions about this data structure, please practice on <a href="https://visualgo.net/training?diff=Medium&amp;n=7&amp;tl=0&amp;module=bst,avl"><u>BST/AVL</u></a> training module (no login is required).</p><br><p>However, for registered users, you should login and then go to the <a href="https://visualgo.net/training"><u>Main Training Page</u></a> to officially clear this module and such achievement will be recorded in your user account.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="15-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="15-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-15-4" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>We also have a few programming problems that somewhat requires the usage of this <b>balanced</b> BST (like AVL Tree) data structure: <a href="https://open.kattis.com/problems/compoundwords" title="" target="_blank"><u>Kattis - compoundwords</u></a> and <a href="https://open.kattis.com/problems/baconeggsandspam" title="" target="_blank"><u>Kattis - baconeggsandspam</u></a>.</p><br><p>Try them to consolidate and improve your understanding about this data structure. You are allowed to use C++ STL map/set, Java TreeMap/TreeSet, or OCaml <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Map.html" target="_blank"><u>Map</u></a>/<a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Set.html" target="_blank"><u>Set</u></a> if that simplifies your implementation (Note that Python doesn&#39;t have built-in bBST implementation).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="15-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="15-5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-15-5" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="15-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99" class="electure-dialog" style="right:150px;bottom:335px;width:500px;">
<p>As the action is being carried out, each step will be described in the status panel.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="15-5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-1" class="electure-dialog" style="right:170px;bottom:275px;width:180px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-2" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-120px;width:260px;">
<p>Control the animation with the player controls! Keyboard shortcuts are:<br></p><div style="margin-top: 8px;"><strong>Spacebar:</strong> play/pause/replay</div><strong>Left/right arrows:</strong> step backward/step forward<br><strong>-/+:</strong> decrease/increase speed<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-3" class="electure-dialog" style="top:70px;right:60px;width:300px;">
<p>Return to &#39;Exploration Mode&#39; to start exploring!</p><br><p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99-2">Trước đó <u>PgUp</u></div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="actions" class="panel">
<p id="create">Tạo</p>
<p id="search">Tìm kiếm(v)</p>
<p id="insert">Chèn(v)</p>
<p id="remove">Di chuyển(v)</p>
<p id="predsucc">Liền trước/sau(v)</p>
<p id="inorder" onclick="inorderTraversal()">Duyệt trung thứ tự</p>
</div>
<div id="actions-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide actions panel" /></div>
<div id="actions-extras">
<div class="create action-menu-pullout">
<div id="create-empty" class="execAction new-menu-option coloured-menu-option" onClick="empty()"><p>Trống</p></div>
<div id="create-example1" class="execAction new-menu-option coloured-menu-option" onClick="example(1)"><p>Unbalanced Example</p></div>
<div id="create-example2" class="execAction new-menu-option coloured-menu-option" onClick="example(2)"><p>Balanced Example</p></div>
<div id="create-random" class="execAction new-menu-option coloured-menu-option" onClick="random()"><p>Ngẫu nhiên</p></div>
<div id="create-skewed-left" class="execAction new-menu-option coloured-menu-option" onClick="skewed('left')"><p>Nghiêng trái</p></div>
<div id="create-skewed-right" class="execAction new-menu-option coloured-menu-option" onClick="skewed('right')"><p>Nghiêng phải</p></div>
<div id="create-err" class="err"></div>
</div>
<div class="search action-menu-pullout">
<div id="find-min" class="execAction new-menu-option coloured-menu-option" onClick="findMinMax(true)"><p>Tìm Giá Trị Nhỏ Nhất</p></div>
<div id="find-max" class="execAction new-menu-option coloured-menu-option" onClick="findMinMax(false)"><p>Tìm Giá Trị Lớn Nhất</p></div>
<div id="search-input" class="new-menu-option">v = <input type="number" id="v-search" title="Enter an Integer" autocomplete="off" min=0 max=99 value=7></div>
<div id="search-go" class="execAction coloured-menu-option" onclick="searchVertex()"><p>Go</p></div>
<div id="search-err" class="err"></div>
</div>
<div class="insert action-menu-pullout">
<div id="insert-input" class="new-menu-option">v = <input type="text" id="v-insert" title="Enter an Integer or comma-separated array of Integers" autocomplete="off" value="1,77"></div>
<div id="insert-go" class="execAction coloured-menu-option" onclick="insertVertex()"><p>Go</p></div>
<div id="insert-err" class="err"></div>
</div>
<div class="remove action-menu-pullout">
<div id="remove-input" class="new-menu-option">v = <input type="text" id="v-remove" title="Enter an Integer or comma-separated array of Integers" autocomplete="off" value="1,77"></div>
<div id="remove-go" class="execAction coloured-menu-option" onclick="removeVertex()"><p>Go</p></div>
<div id="remove-err" class="err"></div>
</div>
<div class="predsucc action-menu-pullout">
<div id="predsucc-input" class="new-menu-option">v = <input type="number" id="v-predsucc" title="Enter an Integer" autocomplete="off" min=0 max=99 value=15></div>
<div id="predsucc-pred-go" class="execAction coloured-menu-option" onclick="predsucc(true)"><p>Tìm phần tử liền trước<br></p></div>
<div id="predsucc-succ-go" class="execAction coloured-menu-option" onclick="predsucc(false)"><p>Tìm phần tử liền sau</p></div>
<div id="predsucc-err" class="err"></div>
</div>
<div class="inorder action-menu-pullout"></div>
</div>
<div id="bottom-bar">
<a id="trigger-about">Về</a>
<a id="trigger-team">Nhóm</a>
<a id="trigger-terms">Điều khoản sử dụng</a>
</div>
<div id="about" class="overlays">
<h4>Về</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
VisuAlgo được lên ý tưởng vào năm 2011 bởi tiến sĩ Steven Halim như là một công cụ để giúp những sinh viên của ông ấy có thể hiểu rõ hơn về các cấu trúc dữ liệu và thuật toán, bằng cách cho phép họ tự học những nội dung cơ bản nhất với tiến độ phù hợp với riêng họ.<br>VisuAlgo chứa rất nhiều thuật toán nâng cao đã được thảo luận trong cuốn sách của Tiến sĩ Steven Halim (&#39;Competitive Programming&#39;, đồng tác giả với anh trai của ông ấy, tiến sĩ Felix Halim) và hơn thế nữa. Hiện tại, một số mô phỏng/hiệu ứng hoạt hình của các thuật toán nâng cao này chỉ có thể tìm thấy ở VisuAlgo.<div>Mặc dù được thiết kế đặc biệt cho những sinh viên đại học quốc gia Singapore (phải học rất nhiều môn học về cấu trúc dữ liệu và thuật toán - ví dụ: CS1010, CS1020, CS2010, CS2020, CS3230, and CS3230), như những người ủng hộ việc học trực tuyến, chúng tôi hi vọng rằng những người quan tâm tới cấu trúc dữ liệu và thuật toán trên toàn thế giới cũng có thể thấy những mô tả này là hữu dụng.<br>Ngay từ đầu, VisuAlgo không được thiết kế để làm việc tốt trên những màn hình cảm ứng nhỏ (ví dụ như smartphones) do việc mô phỏng các thuật toán phức tạp cần rất nhiều điểm ảnh và cử chỉ nhấp và kéo để tương tác. Độ phân giải màn ảnh nhỏ nhất cho trải nghiệm người dùng chấp nhận được là 1024x768 và chỉ có duy nhất trang đích là tương đối thân thiện với bản di động.</div><div>VisuAlgo là một dự án liên tục và nhiều mô phỏng phức tạp vẫn đang được phát triển.<br>Cải tiến thú vị nhất là tạo và duyệt câu hỏi tự động (hệ thống câu hỏi trực tuyến) cho phép sinh viên kiểm tra kiến thức cơ bản về các cấu trúc dữ liệu và thuật toán. Các câu hỏi được tạo ngẫu nhiên thông qua những quy luật và câu trả lời của sinh viên sẽ được chấm điểm tự động và ngay lập tức dựa trên việc nộp bài tới server chấm điểm của chúng tôi. Hệ thống câu hỏi trực tuyến này, khi mà nó được chấp nhận bởi nhiều giảng viên CS trên toàn thế giới, sẽ xóa bỏ mặt kĩ thuật các câu hỏi về cấu trúc dữ liệu và thuật toán cơ bản khỏi các kỳ thi khoa học máy tính điển hình tại rất nhiều trường đại học. Bằng cách đặt một tiêu chí chấm điểm nhỏ (nhưng khác 0) vào việc vượt qua các câu hỏi trực tuyến, giảng viên CS có thể làm tăng (một cách đáng kể) sự thành thạo của những sinh viên trên những câu hỏi cơ bản này khi họ một lượng vô số các câu hỏi thực tế cho sự luyện tập cái mà có thể được kiểm chứng ngay lập tức trước khi họ làm câu hỏi trực tuyến. Hiện tại, chế độ hướng dẫn bao gồm các câu hỏi cho 12 module mô phỏng. Chúng tôi sẽ sớm thêm vào 8 module mô phỏng còn lại để cho tất cả các module mô phỏng ở VisuAlgo đều có phần câu hỏi trực tuyến.<br>Một cải tiến hấp dẫn khác là việc quốc tế hóa các dự án nhánh của VisuAlgo. Chúng tôi muốn chuẩn bị cơ sở dữ liệu các thuật ngữ CS cho các văn bản tiếng Anh đã từng xuất hiện trên hệ thống VisuAlgo. Đây là một nhiệm vụ lớn và cần điện toán đám đông. Một khi hệ thống đã sẵn sàng, chúng tôi sẽ mời người dùng VisuAlgo đóng góp, đặc biệt là khi bạn không phải là người nói tiếng Anh bản ngữ. Hiện tại, chúng tôi cũng đang viết những ghi chú về VisuAlgo bằng những ngôn ngữ khác nhau.<br></div>
<a href="https://weibo.com/p/230418436e9ee80102v4rk" target='_blank'><u>zh</u></a>, <a href='https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689' target='_blank'><u>id</u></a>, <a href="https://blog.naver.com/visualgo_nus" target='_blank'><u>kr</u></a>, <a href='https://www.facebook.com/groups/163215593699283/permalink/824003417620494/' target='_blank'><u>vn</u></a>, <a href='http://pantip.com/topic/32736343' target='_blank'><u>th</u></a>.</p>
</div>
</div>
<div id="team" class="overlays">
<h4>Nhóm</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
<p>
<strong><span style='line-height: 150%;'>Trưởng dự án và cố vấn (từ tháng 7/2011 đến nay)</span></strong><br>
<a href='http://www.comp.nus.edu.sg/~stevenha/' target='_blank'>Dr Steven Halim</a>, Senior Lecturer, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href='http://felix-halim.net/' target='_blank'>Dr Felix Halim</a>, Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style='line-height: 150%;'>Những nhà nghiên cứu sinh viên 1 (Jul 2011-Apr 2012)</span></strong><br>
Koh Zi Chun, <a href='http://roticv.rantx.com/' target='_blank'>Victor Loh Bo Huai</a>
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 1 (Jul 2012-Dec 2013)</span></strong><br>
Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 2 (Jun 2013-Apr 2014)</span></strong><br>
<a href='http://www.rosemarietan.com/' target='_blank'>Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style='line-height: 150%;'>Những nhà nghiên cứu sinh viên 2 (May 2014-Jul 2014)</span></strong><br>
Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 3 (Jun 2014-Apr 2015)</span></strong><br>
Erin Teo Yi Ling, Wang Zi
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 4 (Jun 2016-Dec 2017)</span></strong><br>
Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir
</p>
<p>
List of translators who have contributed &ge;100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style='line-height: 150%;'>Lời cảm ơn</span></strong><br>
This project is made possible by the generous <a href="http://www.cdtl.nus.edu.sg/teg/" target="_blank">Teaching Enhancement Grant</a> from NUS Centre for Development of Teaching and Learning (CDTL).
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Điều khoản sử dụng</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
VisuAlgo miễn phí đối với cộng đồng Khoa học Máy tính trên toàn thế giới. Nếu bạn yêu thích VisuAlgo, khoản chi phí duy nhất mà chúng tôi muốn bạn chi trả chính là hãy nói cho những <b>sinh viên/ giảng viên ngành khoa học máy tính</b> mà bạn biết<b> về sự tồn tại của VisuAlgo</b> =) thông qua Facebook, Twitter, trang web về khóa học, blog review, email , v.v &amp; v.v. Nếu bạn là một<b> sinh viên/ giảng viên</b> ngành cấu trúc dữ liệu và thuật toán, bạn được phép sử dụng website này một cách trực tiếp trong các lớp học của bạn. Nếu bạn lấy những ảnh chụp màn hình (videos) từ website này, bạn có thể sử dụng chúng ở bất kỳ đâu, miễn là có dẫn nguồn URL của website này (http://visualgo.net) và/hoặc liệt kê các công bố ở dưới như là tài liệu tham khảo. Tuy nhiên, bạn <b>KHÔNG</b> được phép tải xuống các tập tin VisuAlgo (phía máy trạm) và lưu trữ nó ở website riêng của bạn vì nó được coi là <b>đạo ý tưởng</b> .Hiện tại, chúng tôi <b>KHÔNG</b> cho phép những người khác chia nhỏ dự án này và tạo ra những phiên bản khác của VisuAlgo. Việc sử dụng bản sao ngoại tuyến của VisuAlgo (phía máy trạm) cho mục đích cá nhân của bạn thì có thể chấp nhận được.<br>Lưu ý rằng hệ thống câu hỏi trực tuyến của VisuAlgo có phần dữ liệu phía máy chủ rất lớn và không dễ dàng để lưu lại mã kịch bản phía máy chủ và cơ sở dữ liệu một cách cục bộ. Hiện tại, mọi người chỉ có thể sử dụng "chế độ đào tạo" để truy cập hệ thống câu hỏi trực tuyến này. Chế độ kiểm tra hiện là môi trường có kiểm soát hơn cho việc sử dụng những câu hỏi được tạo ngẫu nhiên này và tự động kiểm duyệt cho kỳ thi <b>thật sự</b> tại Đại học Quốc gia Singapore<span style="white-space: normal;">.</span> Những giảng viên quan tâm tới khoa học máy tính có thể liên hệ với Steven nếu muốn trải nghiệm "chế độ kiểm tra"<br><b>Danh sách phát hành</b><br>Dự án này đươc trình bày một cách vắn tắt ở Hội thảo CLI tại ACM ICPC World Finals 2012 (Warsaw, Ba Lan) và tại Hội nghị IOI 2012 (Sirmione-Montichiari, Italy). Bạn có thể nhấn vào link này để đọc bài viết năm 2012 của chúng tôi về hệ thống này (nó không được gọi là VisuAlgo vào năm 2012)<br>Dự án này được hoàn thiện hầu hết bởi những cựu sinh viên của tôi. Báo cáo cuối cùng gần đây nhất là của: <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/erin-report.pdf" target="_blank">Erin</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/wangzi-report.pdf" target="_blank">Wang Zi</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/rose-report.pdf" target="_blank">Rose</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/ivan-report.pdf" target="_blank">Ivan</a>.<br><b>Báo cáo lỗi hoặc đề xuất tính năng mới</b><br>VisuAlgo là một dự án chưa hoàn thiện. Tiến sĩ Steven Halim vẫn đang tiếp tục phát triển VisuAlgo một cách tích cực/ Nếu bạn đang sử dụng VisuAlgo và phát hiện ra lỗi ở bất kỳ trang mô phỏng/ công cụ câu hỏi trực tuyến nào của chúng tôi hoặc nếu bạn muốn đề xuất những tính năng mới, hãy liên lạc với Tiến sĩ Steven Halim. Địa chỉ liên lạc của ông ấy là stevenhalim@gmail.com<br>
</div>
</div>

<script src="../js/jquery-3.3.1.min.js"></script>
<script>
      var PHP_DOMAIN = "";

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        //setTimeout(function() {
          if (retval) { // mode == "exploration" && // now not only for exploration mode, but check if this opens other problems
            $('#current-action').show();
            $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
            $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
            triggerRightPanels();
            isPlaying = true;
          }
        //}, 500);
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; i++) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.right-links').css('background', surpriseColour);
        $('#login-go').css('background', surpriseColour);

        $('.colour').css("color", surpriseColour); // name
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
          // temporary quick fix for Google Chrome Aug 2016 issue...
          setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 100); // force resize/redraw...
          setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        });

        // overlays stuffs
        $('#trigger-about').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#about').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('#trigger-team').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#team').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('#trigger-terms').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#termsofuse').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('.close-overlay').click(function() {
          $('.overlays').fadeOut(function() {
            $('#dark-overlay').fadeOut();
          });
        });

        $('#dark-overlay').click(function() {
          $('.overlays').fadeOut();
          $('#dark-overlay').fadeOut();
        });

        $.get('/isloggedin', function(data) {
          var isLoggedIn = data['isloggedin'] == '1';
          var element;
          if (isLoggedIn) {
            // element = '<a onclick="verifyLogout()">Đăng Xuất<div><br></div></a>';
            element = '<a href="https://visualgo.net/profile">Profile</a>'; 
          }
          else {
            element = '<a href="https://visualgo.net/login">Đăng nhập</a>'
          }
          $('#useraccount').html(element);
        });
      });

      function verifyLogout() {
        // Steven's remarks: use a better 'confirm' than the default :(
        var doesLogout = confirm('Are you sure to logout?');
        if (doesLogout == true) {
          window.location = "https://visualgo.net/logout";
        }
      }

      function checkLogin() {
        $.get('/checklogin', function(data) {
          var url = data['url'];
          window.location.href = '/' + url;
        });
      }

      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','../../www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-1566631-4', 'auto');
      ga('send', 'pageview');
    </script>

<script src="../js/jquery-ui.min.js"></script>

<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.3.js"></script>
<script src="../js/visualgo_print.js"></script>
<script src="../js/graph_library.js"></script>
<script>
      function runSlide(slide) {
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 1 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 2 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 3 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-1') {
          $("#e-lecture").html("slide " + slide + " (" + 5 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-2') {
          $("#e-lecture").html("slide " + slide + " (" + 6 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-3') {
          $("#e-lecture").html("slide " + slide + " (" + 7 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-4') {
          $("#e-lecture").html("slide " + slide + " (" + 9 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-5') {
          $("#e-lecture").html("slide " + slide + " (" + 10 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-6') {
          $("#e-lecture").html("slide " + slide + " (" + 11 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-7') {
          $("#e-lecture").html("slide " + slide + " (" + 12 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-8') {
          $("#e-lecture").html("slide " + slide + " (" + 14 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-9') {
          $("#e-lecture").html("slide " + slide + " (" + 15 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-10') {
          $("#e-lecture").html("slide " + slide + " (" + 16 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 18 + "%)");
          example(1);
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-1') {
          $("#e-lecture").html("slide " + slide + " (" + 19 + "%)");
          example(1);
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-2') {
          $("#e-lecture").html("slide " + slide + " (" + 20 + "%)");
          example(1);
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5') {
          $("#e-lecture").html("slide " + slide + " (" + 22 + "%)");
          $("#search").addClass("menu-highlighted");
$("#predsucc").addClass("menu-highlighted");
$("#inorder").addClass("menu-highlighted");
$("#insert").addClass("menu-highlighted");
$("#remove").addClass("menu-highlighted");
$("#create").addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-1') {
          $("#e-lecture").html("slide " + slide + " (" + 23 + "%)");
          
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-2') {
          $("#e-lecture").html("slide " + slide + " (" + 24 + "%)");
          $("#insert").addClass("menu-highlighted");
$("#remove").addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6') {
          $("#e-lecture").html("slide " + slide + " (" + 25 + "%)");
          $("#search").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6-1') {
          $("#e-lecture").html("slide " + slide + " (" + 27 + "%)");
          $("#search").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6-2') {
          $("#e-lecture").html("slide " + slide + " (" + 28 + "%)");
          $("#search").click().addClass("menu-highlighted");
skewed('right');
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7') {
          $("#e-lecture").html("slide " + slide + " (" + 29 + "%)");
          $("#predsucc").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-1') {
          $("#e-lecture").html("slide " + slide + " (" + 31 + "%)");
          $("#predsucc").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-2') {
          $("#e-lecture").html("slide " + slide + " (" + 32 + "%)");
          $("#predsucc").click().addClass("menu-highlighted");
skewed('right');
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '8') {
          $("#e-lecture").html("slide " + slide + " (" + 33 + "%)");
          $("#inorder").addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '8-1') {
          $("#e-lecture").html("slide " + slide + " (" + 35 + "%)");
          $("#inorder").addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '8-2') {
          $("#e-lecture").html("slide " + slide + " (" + 36 + "%)");
          $("#inorder").addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '8-3') {
          $("#e-lecture").html("slide " + slide + " (" + 37 + "%)");
          $("#inorder").addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9') {
          $("#e-lecture").html("slide " + slide + " (" + 38 + "%)");
          $("#insert").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9-1') {
          $("#e-lecture").html("slide " + slide + " (" + 40 + "%)");
          $("#insert").click().addClass("menu-highlighted");
skewed('right');
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9-2') {
          $("#e-lecture").html("slide " + slide + " (" + 41 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '10') {
          $("#e-lecture").html("slide " + slide + " (" + 42 + "%)");
          $("#remove").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '10-1') {
          $("#e-lecture").html("slide " + slide + " (" + 44 + "%)");
          $("#remove").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '10-2') {
          $("#e-lecture").html("slide " + slide + " (" + 45 + "%)");
          $("#remove").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '10-3') {
          $("#e-lecture").html("slide " + slide + " (" + 46 + "%)");
          $("#remove").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '10-4') {
          $("#e-lecture").html("slide " + slide + " (" + 48 + "%)");
          $("#remove").click().addClass("menu-highlighted");
example(1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '10-5') {
          $("#e-lecture").html("slide " + slide + " (" + 49 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '10-6') {
          $("#e-lecture").html("slide " + slide + " (" + 50 + "%)");
          $("#remove").click().addClass("menu-highlighted");
skewed('right');
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '11') {
          $("#e-lecture").html("slide " + slide + " (" + 51 + "%)");
          $("#create").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '12') {
          $("#e-lecture").html("slide " + slide + " (" + 53 + "%)");
          skewed('left');
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '12-1') {
          $("#e-lecture").html("slide " + slide + " (" + 54 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13') {
          $("#e-lecture").html("slide " + slide + " (" + 55 + "%)");
          $("#title-BST").click();
skewed('right');
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-1') {
          $("#e-lecture").html("slide " + slide + " (" + 57 + "%)");
          $("#title-AVL").click();
example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-2') {
          $("#e-lecture").html("slide " + slide + " (" + 58 + "%)");
          
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-3') {
          $("#e-lecture").html("slide " + slide + " (" + 59 + "%)");
          example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-4') {
          $("#e-lecture").html("slide " + slide + " (" + 61 + "%)");
          example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-5') {
          $("#e-lecture").html("slide " + slide + " (" + 62 + "%)");
          example(3);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-6') {
          $("#e-lecture").html("slide " + slide + " (" + 63 + "%)");
          example(3);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-7') {
          $("#e-lecture").html("slide " + slide + " (" + 64 + "%)");
          $("#title-BST").click();
skewed('right');
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-8') {
          $("#e-lecture").html("slide " + slide + " (" + 66 + "%)");
          
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-9') {
          $("#e-lecture").html("slide " + slide + " (" + 67 + "%)");
          $("#title-AVL").click();
example(3);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14') {
          $("#e-lecture").html("slide " + slide + " (" + 68 + "%)");
          $("#title-AVL").click();
example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-1') {
          $("#e-lecture").html("slide " + slide + " (" + 70 + "%)");
          $("#title-AVL").click();
example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-2') {
          $("#e-lecture").html("slide " + slide + " (" + 71 + "%)");
          $("#title-AVL").click();
example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-3') {
          $("#e-lecture").html("slide " + slide + " (" + 72 + "%)");
          $("#title-AVL").click();
example(5);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-4') {
          $("#e-lecture").html("slide " + slide + " (" + 74 + "%)");
          $("#title-AVL").click();
example(5);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-5') {
          $("#e-lecture").html("slide " + slide + " (" + 75 + "%)");
          $("#title-AVL").click();
example(5);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-6') {
          $("#e-lecture").html("slide " + slide + " (" + 76 + "%)");
          $("#title-AVL").click();
example(5);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-7') {
          $("#e-lecture").html("slide " + slide + " (" + 77 + "%)");
          $("#title-AVL").click();
example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-8') {
          $("#e-lecture").html("slide " + slide + " (" + 79 + "%)");
          
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-9') {
          $("#e-lecture").html("slide " + slide + " (" + 80 + "%)");
          
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-10') {
          $("#e-lecture").html("slide " + slide + " (" + 81 + "%)");
          
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-11') {
          $("#e-lecture").html("slide " + slide + " (" + 83 + "%)");
          $("#title-AVL").click();
example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-12') {
          $("#e-lecture").html("slide " + slide + " (" + 84 + "%)");
          $("#title-AVL").click();
example(2);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-13') {
          $("#e-lecture").html("slide " + slide + " (" + 85 + "%)");
          $("#title-AVL").click();
example(4);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-14') {
          $("#e-lecture").html("slide " + slide + " (" + 87 + "%)");
          $("#title-AVL").click();
example(5);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '15') {
          $("#e-lecture").html("slide " + slide + " (" + 88 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '15-1') {
          $("#e-lecture").html("slide " + slide + " (" + 89 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '15-2') {
          $("#e-lecture").html("slide " + slide + " (" + 90 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '15-3') {
          $("#e-lecture").html("slide " + slide + " (" + 92 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '15-4') {
          $("#e-lecture").html("slide " + slide + " (" + 93 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '15-5') {
          $("#e-lecture").html("slide " + slide + " (" + 94 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99') {
          $("#e-lecture").html("slide " + slide + " (" + 96 + "%)");
          
          hideEntireActionsPanel();
 
          showStatusPanel();
          showCodetracePanel();
      
        }
        if (slide == '99-1') {
          $("#e-lecture").html("slide " + slide + " (" + 97 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99-2') {
          $("#e-lecture").html("slide " + slide + " (" + 98 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99-3') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };

      function pushState(slideValue) {
        var url = '/vi/bst';
        if (typeof slideValue != 'undefined' && slideValue != null) url += '?slide=' + slideValue;
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5); 
        $('#overlay').show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      $(function() {
        var slide = getUrlParameter('slide');
        
        $.get('/hasvisited' + '/bst', function(data) {
          var hasVisited = data['hasvisited'] == '1';
          if (!hasVisited) {
            var postData = {
              '_token': 'iVivZ7KRPe6XK7pbuGtOoEjljE1xyBVNhLKNFuF8',
              'page': '/bst'.substring(1),
            };

            $.post("/visitpage", postData, function(data) {
              // non critical request...
            });

            if (typeof slide != undefined && slide != null) {
              cur_slide = slide;
            }

            $("#mode-menu a").trigger("click");
          }
          else {
            if (typeof slide != undefined && slide != null) {
              cur_slide = slide;
              $('#mode-menu a').click();
            }    
          }
        }).fail(function() {
          if (typeof slide != undefined && slide != null) {
            cur_slide = slide;
            $('#mode-menu a').click();
          }
        });

        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
      
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
      
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
      
        $('#electure-3-1 .electure-next').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
        $('#electure-3-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
      
        $('#electure-3-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
        $('#electure-3-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
      
        $('#electure-3-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
        $('#electure-3-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
      
        $('#electure-3-4 .electure-next').click(function() {
          hidePopup();
          runSlide('3-5');
          pushState('3-5');
        });
        $('#electure-3-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
      
        $('#electure-3-5 .electure-next').click(function() {
          hidePopup();
          runSlide('3-6');
          pushState('3-6');
        });
        $('#electure-3-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
      
        $('#electure-3-6 .electure-next').click(function() {
          hidePopup();
          runSlide('3-7');
          pushState('3-7');
        });
        $('#electure-3-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-5');
          pushState('3-5');
        });
      
        $('#electure-3-7 .electure-next').click(function() {
          hidePopup();
          runSlide('3-8');
          pushState('3-8');
        });
        $('#electure-3-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-6');
          pushState('3-6');
        });
      
        $('#electure-3-8 .electure-next').click(function() {
          hidePopup();
          runSlide('3-9');
          pushState('3-9');
        });
        $('#electure-3-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-7');
          pushState('3-7');
        });
      
        $('#electure-3-9 .electure-next').click(function() {
          hidePopup();
          runSlide('3-10');
          pushState('3-10');
        });
        $('#electure-3-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-8');
          pushState('3-8');
        });
      
        $('#electure-3-10 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-9');
          pushState('3-9');
        });
      
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-10');
          pushState('3-10');
        });
      
        $('#electure-4-1 .electure-next').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
      
        $('#electure-4-2 .electure-next').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-4-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
      
        $('#electure-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
        $('#electure-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
      
        $('#electure-5-1 .electure-next').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
        $('#electure-5-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
      
        $('#electure-5-2 .electure-next').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-5-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
      
        $('#electure-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
      
        $('#electure-6-1 .electure-next').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-6-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
      
        $('#electure-6-2 .electure-next').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-6-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
      
        $('#electure-7 .electure-next').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
      
        $('#electure-7-1 .electure-next').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
        $('#electure-7-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
      
        $('#electure-7-2 .electure-next').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
        $('#electure-7-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
      
        $('#electure-8 .electure-next').click(function() {
          hidePopup();
          runSlide('8-1');
          pushState('8-1');
        });
        $('#electure-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
      
        $('#electure-8-1 .electure-next').click(function() {
          hidePopup();
          runSlide('8-2');
          pushState('8-2');
        });
        $('#electure-8-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
      
        $('#electure-8-2 .electure-next').click(function() {
          hidePopup();
          runSlide('8-3');
          pushState('8-3');
        });
        $('#electure-8-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-1');
          pushState('8-1');
        });
      
        $('#electure-8-3 .electure-next').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
        $('#electure-8-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-2');
          pushState('8-2');
        });
      
        $('#electure-9 .electure-next').click(function() {
          hidePopup();
          runSlide('9-1');
          pushState('9-1');
        });
        $('#electure-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('8-3');
          pushState('8-3');
        });
      
        $('#electure-9-1 .electure-next').click(function() {
          hidePopup();
          runSlide('9-2');
          pushState('9-2');
        });
        $('#electure-9-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
      
        $('#electure-9-2 .electure-next').click(function() {
          hidePopup();
          runSlide('10');
          pushState('10');
        });
        $('#electure-9-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-1');
          pushState('9-1');
        });
      
        $('#electure-10 .electure-next').click(function() {
          hidePopup();
          runSlide('10-1');
          pushState('10-1');
        });
        $('#electure-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-2');
          pushState('9-2');
        });
      
        $('#electure-10-1 .electure-next').click(function() {
          hidePopup();
          runSlide('10-2');
          pushState('10-2');
        });
        $('#electure-10-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('10');
          pushState('10');
        });
      
        $('#electure-10-2 .electure-next').click(function() {
          hidePopup();
          runSlide('10-3');
          pushState('10-3');
        });
        $('#electure-10-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-1');
          pushState('10-1');
        });
      
        $('#electure-10-3 .electure-next').click(function() {
          hidePopup();
          runSlide('10-4');
          pushState('10-4');
        });
        $('#electure-10-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-2');
          pushState('10-2');
        });
      
        $('#electure-10-4 .electure-next').click(function() {
          hidePopup();
          runSlide('10-5');
          pushState('10-5');
        });
        $('#electure-10-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-3');
          pushState('10-3');
        });
      
        $('#electure-10-5 .electure-next').click(function() {
          hidePopup();
          runSlide('10-6');
          pushState('10-6');
        });
        $('#electure-10-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-4');
          pushState('10-4');
        });
      
        $('#electure-10-6 .electure-next').click(function() {
          hidePopup();
          runSlide('11');
          pushState('11');
        });
        $('#electure-10-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-5');
          pushState('10-5');
        });
      
        $('#electure-11 .electure-next').click(function() {
          hidePopup();
          runSlide('12');
          pushState('12');
        });
        $('#electure-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('10-6');
          pushState('10-6');
        });
      
        $('#electure-12 .electure-next').click(function() {
          hidePopup();
          runSlide('12-1');
          pushState('12-1');
        });
        $('#electure-12 .electure-prev').click(function() {
          hidePopup();
          runSlide('11');
          pushState('11');
        });
      
        $('#electure-12-1 .electure-next').click(function() {
          hidePopup();
          runSlide('13');
          pushState('13');
        });
        $('#electure-12-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('12');
          pushState('12');
        });
      
        $('#electure-13 .electure-next').click(function() {
          hidePopup();
          runSlide('13-1');
          pushState('13-1');
        });
        $('#electure-13 .electure-prev').click(function() {
          hidePopup();
          runSlide('12-1');
          pushState('12-1');
        });
      
        $('#electure-13-1 .electure-next').click(function() {
          hidePopup();
          runSlide('13-2');
          pushState('13-2');
        });
        $('#electure-13-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('13');
          pushState('13');
        });
      
        $('#electure-13-2 .electure-next').click(function() {
          hidePopup();
          runSlide('13-3');
          pushState('13-3');
        });
        $('#electure-13-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-1');
          pushState('13-1');
        });
      
        $('#electure-13-3 .electure-next').click(function() {
          hidePopup();
          runSlide('13-4');
          pushState('13-4');
        });
        $('#electure-13-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-2');
          pushState('13-2');
        });
      
        $('#electure-13-4 .electure-next').click(function() {
          hidePopup();
          runSlide('13-5');
          pushState('13-5');
        });
        $('#electure-13-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-3');
          pushState('13-3');
        });
      
        $('#electure-13-5 .electure-next').click(function() {
          hidePopup();
          runSlide('13-6');
          pushState('13-6');
        });
        $('#electure-13-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-4');
          pushState('13-4');
        });
      
        $('#electure-13-6 .electure-next').click(function() {
          hidePopup();
          runSlide('13-7');
          pushState('13-7');
        });
        $('#electure-13-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-5');
          pushState('13-5');
        });
      
        $('#electure-13-7 .electure-next').click(function() {
          hidePopup();
          runSlide('13-8');
          pushState('13-8');
        });
        $('#electure-13-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-6');
          pushState('13-6');
        });
      
        $('#electure-13-8 .electure-next').click(function() {
          hidePopup();
          runSlide('13-9');
          pushState('13-9');
        });
        $('#electure-13-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-7');
          pushState('13-7');
        });
      
        $('#electure-13-9 .electure-next').click(function() {
          hidePopup();
          runSlide('14');
          pushState('14');
        });
        $('#electure-13-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-8');
          pushState('13-8');
        });
      
        $('#electure-14 .electure-next').click(function() {
          hidePopup();
          runSlide('14-1');
          pushState('14-1');
        });
        $('#electure-14 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-9');
          pushState('13-9');
        });
      
        $('#electure-14-1 .electure-next').click(function() {
          hidePopup();
          runSlide('14-2');
          pushState('14-2');
        });
        $('#electure-14-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('14');
          pushState('14');
        });
      
        $('#electure-14-2 .electure-next').click(function() {
          hidePopup();
          runSlide('14-3');
          pushState('14-3');
        });
        $('#electure-14-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-1');
          pushState('14-1');
        });
      
        $('#electure-14-3 .electure-next').click(function() {
          hidePopup();
          runSlide('14-4');
          pushState('14-4');
        });
        $('#electure-14-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-2');
          pushState('14-2');
        });
      
        $('#electure-14-4 .electure-next').click(function() {
          hidePopup();
          runSlide('14-5');
          pushState('14-5');
        });
        $('#electure-14-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-3');
          pushState('14-3');
        });
      
        $('#electure-14-5 .electure-next').click(function() {
          hidePopup();
          runSlide('14-6');
          pushState('14-6');
        });
        $('#electure-14-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-4');
          pushState('14-4');
        });
      
        $('#electure-14-6 .electure-next').click(function() {
          hidePopup();
          runSlide('14-7');
          pushState('14-7');
        });
        $('#electure-14-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-5');
          pushState('14-5');
        });
      
        $('#electure-14-7 .electure-next').click(function() {
          hidePopup();
          runSlide('14-8');
          pushState('14-8');
        });
        $('#electure-14-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-6');
          pushState('14-6');
        });
      
        $('#electure-14-8 .electure-next').click(function() {
          hidePopup();
          runSlide('14-9');
          pushState('14-9');
        });
        $('#electure-14-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-7');
          pushState('14-7');
        });
      
        $('#electure-14-9 .electure-next').click(function() {
          hidePopup();
          runSlide('14-10');
          pushState('14-10');
        });
        $('#electure-14-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-8');
          pushState('14-8');
        });
      
        $('#electure-14-10 .electure-next').click(function() {
          hidePopup();
          runSlide('14-11');
          pushState('14-11');
        });
        $('#electure-14-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-9');
          pushState('14-9');
        });
      
        $('#electure-14-11 .electure-next').click(function() {
          hidePopup();
          runSlide('14-12');
          pushState('14-12');
        });
        $('#electure-14-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-10');
          pushState('14-10');
        });
      
        $('#electure-14-12 .electure-next').click(function() {
          hidePopup();
          runSlide('14-13');
          pushState('14-13');
        });
        $('#electure-14-12 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-11');
          pushState('14-11');
        });
      
        $('#electure-14-13 .electure-next').click(function() {
          hidePopup();
          runSlide('14-14');
          pushState('14-14');
        });
        $('#electure-14-13 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-12');
          pushState('14-12');
        });
      
        $('#electure-14-14 .electure-next').click(function() {
          hidePopup();
          runSlide('15');
          pushState('15');
        });
        $('#electure-14-14 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-13');
          pushState('14-13');
        });
      
        $('#electure-15 .electure-next').click(function() {
          hidePopup();
          runSlide('15-1');
          pushState('15-1');
        });
        $('#electure-15 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-14');
          pushState('14-14');
        });
      
        $('#electure-15-1 .electure-next').click(function() {
          hidePopup();
          runSlide('15-2');
          pushState('15-2');
        });
        $('#electure-15-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('15');
          pushState('15');
        });
      
        $('#electure-15-2 .electure-next').click(function() {
          hidePopup();
          runSlide('15-3');
          pushState('15-3');
        });
        $('#electure-15-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('15-1');
          pushState('15-1');
        });
      
        $('#electure-15-3 .electure-next').click(function() {
          hidePopup();
          runSlide('15-4');
          pushState('15-4');
        });
        $('#electure-15-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('15-2');
          pushState('15-2');
        });
      
        $('#electure-15-4 .electure-next').click(function() {
          hidePopup();
          runSlide('15-5');
          pushState('15-5');
        });
        $('#electure-15-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('15-3');
          pushState('15-3');
        });
      
        $('#electure-15-5 .electure-next').click(function() {
          hidePopup();
          runSlide('99');
          pushState('99');
        });
        $('#electure-15-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('15-4');
          pushState('15-4');
        });
      
        $('#electure-99 .electure-next').click(function() {
          hidePopup();
          runSlide('99-1');
          pushState('99-1');
        });
        $('#electure-99 .electure-prev').click(function() {
          hidePopup();
          runSlide('15-5');
          pushState('15-5');
        });
      
        $('#electure-99-1 .electure-next').click(function() {
          hidePopup();
          runSlide('99-2');
          pushState('99-2');
        });
        $('#electure-99-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('99');
          pushState('99');
        });
      
        $('#electure-99-2 .electure-next').click(function() {
          hidePopup();
          runSlide('99-3');
          pushState('99-3');
        });
        $('#electure-99-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('99-1');
          pushState('99-1');
        });
      
        $('#electure-99-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('99-2');
          pushState('99-2');
        });
      
 

        // temporary quick fix for Google Chrome Aug 2016 issue..., put at last part so that everything else has been loaded
        // setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 500);
        // setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        // I turn it off on 14 June 2018, seems 'ok'?
      });

      function doButtonAction1() {
        CUSTOM_ACTION('search', 7);
      }
      function doButtonAction2() {
        CUSTOM_ACTION('search', 15);
      }
      function doButtonAction3() {
        CUSTOM_ACTION('search', 21);
      }
      function doButtonAction4() {
        $("#v-search").val(64);
mode = "exploration"; 
cur_slide = 1;
$(".tutorial-dialog#tutorial-4").fadeOut(100);
searchVertex(function() {
  mode = "tutorial"; 
  $(".tutorial-dialog#tutorial-4").fadeIn(100);
});
      }
      function doButtonAction5() {
        CUSTOM_ACTION('search', 100);
      }
      function doButtonAction6() {
        CUSTOM_ACTION('successor', 23);
      }
      function doButtonAction52() {
        CUSTOM_ACTION('findmin');
      }
      function doButtonAction53() {
        CUSTOM_ACTION('findmax');
      }
      function doButtonAction54() {
        CUSTOM_ACTION('successor', 7);
      }
      function doButtonAction55() {
        CUSTOM_ACTION('successor', 71);
      }
      function doButtonAction56() {
        CUSTOM_ACTION('predecessor', 6);
      }
      function doButtonAction57() {
        CUSTOM_ACTION('predecessor', 50);
      }
      function doButtonAction58() {
        CUSTOM_ACTION('predecessor', 4);
      }
      function doButtonAction59() {
        CUSTOM_ACTION('inorder');
      }
      function doButtonAction60() {
        CUSTOM_ACTION('insert', 60);
      }
      function doButtonAction61() {
        CUSTOM_ACTION('remove', 5);
      }
      function doButtonAction62() {
        CUSTOM_ACTION('remove', 23);
      }
      function doButtonAction63() {
        CUSTOM_ACTION('remove', 6);
      }
      function doButtonAction64() {
        CUSTOM_ACTION('successor_max');
      }
      function doButtonAction65() {
        CUSTOM_ACTION('insert_max_plus_1');
      }
      function doButtonAction66() {
        CUSTOM_ACTION('remove_max');
      }
      function doButtonAction68() {
        CUSTOM_ACTION('remove', 7);
      }
      function doButtonAction69() {
        CUSTOM_ACTION('insert', 37);
$(this).hide();
      }

      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();  
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url.html) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}
    </script>
<script type="text/javascript">
// BST Widget, also includes AVL tree
// original author: Ivan Reinaldo, then maintained by Steven Halim

var BST = function() {
  var self = this;
  var gw = new GraphWidget();
  var isAVL = false;

  var valueRange = [1, 100]; // Range of valid values of BST vertexes allowed
  var maxHeightAllowed = 9; // max 9 edges (10 vertices)

  var initialArray = [15, 6, 23, 4, 7, 71, 5, 50];
  var initialAvlArray = [15, 6, 50, 4, 7, 23, 71, 5];

  /*
   * iBST: Internal representation of BST in this object
   * The keys are the text of the nodes, and the value is the attributes of the corresponding node encapsulated in a JS object, which are:
   * - "parent": text of the parent node. If the node is root node, the value is null.
   * - "leftChild": text of the left child. No child -> null
   * - "rightChild": text of the right child. No child -> null
   * - "cx": X-coordinate of center of the node
   * - "cy": Y-coordinate of center of the node
   * - "height": height of the node. Height of root is 0
   * - "vertexClassNumber": Vertex class number of the corresponding node
   *
   * In addition, there is a key called "root" in iBST, containing the text of the root node.
   * If BST is empty, root is null.
   */

  var iBST = {};
  var amountVertex = 0;
  iBST["root"] = null;

  if (isAVL) init(initialAvlArray);
  else       init(initialArray);

  this.getGraphWidget = function() { return gw; };

  function dummyInit() {
    iBST["root"] = 15;
    iBST[15] = {
      "parent": null,
      "leftChild": 6,
      "rightChild": 23,
      "vertexClassNumber": 0
    };
    iBST[6] = {
      "parent": 15,
      "leftChild": 4,
      "rightChild": 7,
      "vertexClassNumber": 1
    };
    iBST[23] = {
      "parent": 15,
      "leftChild": null,
      "rightChild": 71,
      "vertexClassNumber": 2
    };
    iBST[4] = {
      "parent": 6,
      "leftChild": null,
      "rightChild": 5,
      "vertexClassNumber": 3
    };
    iBST[7] = {
      "parent": 6,
      "leftChild": null,
      "rightChild": null,
      "vertexClassNumber": 4
    };
    iBST[71] = {
      "parent": 23,
      "leftChild": 50,
      "rightChild": null,
      "vertexClassNumber": 5
    };
    iBST[5] = {
      "parent": 4,
      "leftChild": null,
      "rightChild": null,
      "vertexClassNumber": 6
    };
    iBST[50] = {
      "parent": 71,
      "leftChild": null,
      "rightChild": null,
      "vertexClassNumber": 7
    };

    var key;
    recalculatePosition();

    for (key in iBST) {
      if (key == "root")
        continue;

      var cur = iBST[key];
      gw.addVertex(cur["cx"], cur["cy"], key, cur["vertexClassNumber"], true);
    }

    for (key in iBST) {
      if (key == "root")
        continue;

      var cur = iBST[key];
      var parentVertex = iBST[cur["parent"]];
      if (cur["parent"] == null)
        continue;

      gw.addEdge(parentVertex["vertexClassNumber"], cur["vertexClassNumber"], cur["vertexClassNumber"], EDGE_TYPE_UDE, 1, true);
    }

    amountVertex = 8;
  }

  this.generate = function(array) { init(array); };

  this.generateEmpty = function() {
    var vertexAmt = 0;
    var initArr = [];
    init(initArr);
    return true;
  };

  this.generateExample = function(id) {
    if (isAVL && (id == 1)) {
      $('#create-err').html("AVL trees are balanced. This example is not balanced."); 
      return false;
    }
    var vertexAmt = 8; // for id == 1
    var initArr = [15,6,23,4,7,71,5,50];
    if (id == 2) {
      vertexAmt = 10;
      initArr = [41,20,65,11,29,50,91,32,72,99];
    }
    else if (id == 3) {
      vertexAmt = 15;
      initArr = [8,4,12,2,6,10,14,1,3,5,7,9,11,13,15];
    }
    else if (id == 4) {
      vertexAmt = 12;
      initArr = [8,6,16,3,7,13,19,2,11,15,18,10];
    }
    else if (id == 5) {
      vertexAmt = 20;
      initArr = [13,8,18,5,11,16,20,3,7,10,12,15,17,19,2,4,6,9,14,1];
    }
    init(initArr);
    return true;
  }

  this.generateRandom = function() {
    var vertexAmt = Math.floor((Math.random()*7 + 5));
    var initArr = [];

    while (initArr.length < vertexAmt) {
      var random = Math.floor(1 + Math.random()*99);
      if ($.inArray(random, initArr) < 0)
        initArr.push(random);
    }

    if (isAVL) {
      var initArrAvl = [];

      function recursion(startVal, endVal) {
        var total = startVal + endVal + 1;
        if (total < 1)
          return;
        if (startVal > endVal)
          return;
        if (total == 1)
          initArrAvl.push(initArr[startVal]);
        else if (total % 2 != 0) {
          initArrAvl.push(initArr[parseInt(total/2)]);
          recursion(startVal, parseInt(total/2) - 1);
          recursion(parseInt(total/2) + 1, endVal);
        }
        else {
          initArrAvl.push(initArr[parseInt(total/2) - 1]);
          recursion(startVal, parseInt(total/2) - 2);
          recursion(parseInt(total/2), endVal);
        }
      }

      function sortNumber(a, b) { return a-b; }
      initArr.sort(sortNumber);
      recursion(0, initArr.length-1);
      init(initArrAvl);
    }
    else
      init(initArr);

    return true;
  }

  this.generateSkewed = function(side) {
    if (isAVL) {
      $('#create-err').html('Cây AVL nói chung không nghiêng. Hãy thử với BST.');
      return false;
    }
    else {
      var vertexAmt = Math.floor(5 + Math.random()*5); // [5..9] vertices (allow +1 for one more right/left extreme insertion)
      var initArr = new Array();
      while (initArr.length < vertexAmt) {
        var random = Math.floor(1 + Math.random()*99); // value [1..99]
        if ($.inArray(random, initArr) < 0)
          initArr.push(random);
      }
      if (side == "left") {
        initArr.sort(function(a, b) {
          return b-a;
        });
      }
      else if (side == "right") {
        initArr.sort(function(a, b) {
          return a-b;
        });
      }
      init(initArr);
      return true;
    }
  };

  this.isAVL = function(bool) {
    if (typeof bool != 'boolean') return;

    if (bool != isAVL) {
      clearScreen();
      if (bool)
        init(initialAvlArray);
      else
        init(initialArray);
      isAVL = bool;
    }
  };

  this.getIsAVL = function() {
    return isAVL;
  };

  this.getRandomInBST = function() {
    var arr = new Array();
    for (var key in iBST) {
      if (key == "root") continue;
      arr.push(key);
    }
    return parseInt(arr[Math.floor(Math.random()*arr.length)]);
  }

  this.getRandomNotInBST = function() {
    var arr = new Array();
    for (var key in iBST) {
      if (key == "root") continue;
      arr.push(parseInt(key));
    }
    var candidate = 1 + Math.floor(Math.random()*99); // [1..99]
    while ($.inArray(candidate, arr) > 0)
      candidate = 1 + Math.floor(Math.random()*99);
    return candidate;
  }

  this.search = function(val, callback) {
    var sl = [], vertexTraversed = {}, edgeTraversed = {}, cur = iBST["root"], cs, currentVertexClass, key, ans;

    cs = createState(iBST);
    //cs["status"] = "The current BST";  //status_search_0
    cs["status"] = 'Cây BST hiện tại.';
    cs["lineNo"] = 0;
    sl.push(cs);

    while (cur != val && cur != null) {
      cs = createState(iBST, vertexTraversed, edgeTraversed);
      currentVertexClass = iBST[cur]["vertexClassNumber"];
      cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
      vertexTraversed[cur] = true;
      //cs["status"] = "Comparing " + cur + " with " + val + "."; //status_search_1
      cs["status"] = 'Đang so sánh {cur} với {val}.'.replace("{cur}", cur).replace("{val}", val);
      cs["lineNo"] = 3;
      sl.push(cs);

      if (parseInt(val) > parseInt(cur)) {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        //cs["status"] = cur + " is smaller than " + val + "."; //status_search_2
        cs["status"] = '{cur} nhỏ hơn {val}.'.replace("{cur}", cur).replace("{val}", val);
        cs["lineNo"] = 5;
        sl.push(cs);

        cur = iBST[cur]["rightChild"];
        if (cur == null) {
          cs = createState(iBST, vertexTraversed, edgeTraversed);
          //cs["status"] = "Value " + val + " is not in the BST."; //status_search_3
          cs["status"] = 'Giá trị {val} không có trong cây BST.'.replace("{val}", val);
          cs["lineNo"] = [1, 2];
          sl.push(cs);
          break;
        }

        cs = createState(iBST, vertexTraversed, edgeTraversed);
        var edgeHighlighted = iBST[cur]["vertexClassNumber"];
        edgeTraversed[edgeHighlighted] = true;
        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
        //cs["status"] = "So search on the right."; //status_search_4
        cs["status"] = 'Do đó, tìm kiếm phía bên phải.';
        cs["lineNo"] = 6;
        sl.push(cs);
      }
      else {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        //cs["status"] = cur + " is greater than " + val + "."; //status_search_5
        cs["status"] = '{cur} lớn hơn {val}.'.replace("{cur}", cur).replace("{val}", val);
        cs["lineNo"] = 7;
        sl.push(cs);

        cur = iBST[cur]["leftChild"];
        if (cur == null) {
          cs = createState(iBST, vertexTraversed, edgeTraversed);
          //cs["status"] = "Value " + val + " is not in the BST.";  //status_search_6
          cs["status"] = 'Giá trị {val} không có trong cây BST.'.replace("{val}", val);
          cs["lineNo"] = [1, 2];
          sl.push(cs);
          break;
        }

        cs = createState(iBST, vertexTraversed, edgeTraversed);
        var edgeHighlighted = iBST[cur]["vertexClassNumber"];
        edgeTraversed[edgeHighlighted] = true;
        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
        //cs["status"] = "So search on the left.";  //status_search_7
        cs["status"] = 'Do đó, tìm kiếm phía bên trái.';
        cs["lineNo"] = 7;
        sl.push(cs);
      }
    }

    if (cur != null) {
      cs = createState(iBST, vertexTraversed, edgeTraversed);
      currentVertexClass = iBST[cur]["vertexClassNumber"];
      cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
      //cs["status"] = "Found value " + val + ".";  //status_search_8
      cs["status"] = 'Đã tìm thấy giá trị {val}.'.replace("{val}", val);
      cs["lineNo"] = 4;
      sl.push(cs);
    }

    gw.startAnimation(sl, callback);
    populatePseudocode(4);
    return true;
  }

  this.findMax = function() {
    var ans = -1;
    for (key in iBST) {
      if (key == "root") continue;
      ans = Math.max(ans, key);
    }
    return ans;
  }

  this.findMinMax = function(isMin, callback) {
    var sl = [], vertexTraversed = {}, edgeTraversed = {}, cur = iBST["root"], cs, key, ans;

    cs = createState(iBST);
    //cs["status"] = "The current BST"; //status_minmax_0
    cs["status"] = 'Cây BST hiện tại';
    cs["lineNo"] = 0;
    sl.push(cs);

    if (cur == null) {
      cs = createState(iBST);
      if (isMin) {
        //cs["status"] = "Tree is empty, there is no minimum value."; //status_minmax_1
        cs["status"] = 'Cây rỗng, không có giá trị nhỏ nhất.';
      }
      else {
        //cs["status"] = "Tree is empty, there is no maximum value."; //status_minmax_2
        cs["status"] = 'Cây rỗng, không có giá trị lớn nhất.';
      }
      cs["lineNo"] = 1;
      sl.push(cs);
      gw.startAnimation(sl, callback);
      return true;
    }

    while (cur != null) {
      cs = createState(iBST, vertexTraversed, edgeTraversed);
      key = iBST[cur]["vertexClassNumber"];
      cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
      vertexTraversed[cur] = true;
      if (( isMin && (iBST[cur]["leftChild"] != null)) ||
          (!isMin && (iBST[cur]["rightChild"] != null))) {
        if (isMin) {
          //cs["status"] = cur + " is not the minimum value as it has a left child.";  //status_minmax_3
          cs["status"] = '{cur} không phải giá trị nhỏ nhất vì nó có con trái.'.replace("{cur}", cur);
        }
        else {
          //cs["status"] = cur + " is not the maximum value as it has a right child.";  //status_minmax_4
          cs["status"] = '{cur} không phải giá trị lớn nhất vì nó có con phải.'.replace("{cur}", cur);
        }
        cs["lineNo"] = 2;
      }
      else {
        ans = cur;
        if (isMin) {
          //cs["status"] = "Minimum value found!";  //status_minmax_5
          cs["status"] = 'Đã tìm thấy giá trị nhỏ nhất!';
        }
        else {
          //cs["status"] = "Maximum value found!";  //status_minmax_6
          cs["status"] = 'Đã tìm thấy giá trị lớn nhất!';
        }

        cs["lineNo"] = 4;
      }
      cur = (isMin ? iBST[cur]["leftChild"] : iBST[cur]["rightChild"]);
      sl.push(cs);

      if (cur == null) break;

      cs = createState(iBST, vertexTraversed, edgeTraversed);
      var edgeHighlighted = iBST[cur]["vertexClassNumber"];
      edgeTraversed[edgeHighlighted] = true;
      cs["el"][edgeHighlighted]["animateHighlighted"] = true;
      cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
      if (isMin) {
        //cs["status"] = "Go left to check for smaller value..."; //status_minmax_7
        cs["status"] = 'Đi sang trái để kiểm tra với giá trị nhỏ hơn.';
      }
      else {
        //cs["status"] = "Go right to check for larger value..."; //status_minmax_8
        cs["status"] = 'Đi sang phải để kiểm tra với giá trị lớn hơn.';
      }

      cs["lineNo"] = 3;
      sl.push(cs);
    }

    cs = createState(iBST);
    if (isMin) {
      //cs["status"] = "Find Min has ended.<br>The minimum value is " + ans + ".";  //status_minmax_9
      cs["status"] = 'Tìm Min kết thúc.<div>Giá trị nhỏ nhất là {ans}.</div>'.replace("{ans}", ans);
    }
    else {
      //cs["status"] = "Find Max has ended.<br>The maximum value is " + ans + ".";  //status_minmax_10
      cs["status"] = 'Tìm Max kết thúc.<div>Giá trị lớn nhất là {ans}.</div>'.replace("{ans}", ans);
    }

    cs["lineNo"] = 0;
    sl.push(cs);

    populatePseudocode(isMin ? 2 : 1);
    gw.startAnimation(sl, callback);
    return true;
  }

  this.findPredSucc = function(val, isPred, callback) {
    var sl = [], vertexTraversed = {}, edgeTraversed = {}, cur = iBST["root"], cs, key, currentVertexClass;
    cur = val = parseInt(val);

    if (val == null || val == undefined || isNaN(val)) {
      $('#predsucc-err').html('Hãy điền một giá trị hợp lệ!');
      return false;invalidval
    }

    if (iBST[val] == null) {
      $('#predsucc-err').html('Hãy điền một giá trị nằm trong cây BST!');
      return false;
    }

    key = iBST[val]["vertexClassNumber"];
    cs = createState(iBST);
    //cs["status"] = "The current BST.";  //status_predsucc_0
    cs["status"] = 'Cây BST hiện tại.';
    cs["lineNo"] = 0;
    sl.push(cs);

    if (( isPred && (iBST[val]["leftChild"] != null)) ||
        (!isPred && (iBST[val]["rightChild"] != null))) {
      var subTreeRoot = (isPred ? iBST[val]["leftChild"] : iBST[val]["rightChild"]);
      var subTreeRootKey = iBST[subTreeRoot]["vertexClassNumber"];

      edgeTraversed[subTreeRootKey] = true;

      cs = createState(iBST, vertexTraversed, edgeTraversed);
      cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
      cs["el"][subTreeRootKey]["animateHighlighted"] = true;
      if (isPred) {
        //cs["status"] = "This vertex has a left child, so go left.";  //status_predsucc_1
        cs["status"] = 'Đỉnh này có con trái, đi sang trái.';
      } else {
        //cs["status"] = "This vertex has a right child, so go right.";  //status_predsucc_2
        cs["status"] = 'Đỉnh này có con phải, đi sang phải.';
      }

      cs["lineNo"] = 1;
      sl.push(cs);

      cs = createState(iBST, vertexTraversed, edgeTraversed);
      cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][subTreeRootKey]["state"] = VERTEX_HIGHLIGHTED;
      if (isPred) {
        //cs["status"] = "Check whether the left child has a right child."; //status_predsucc_3
        cs["status"] = 'Kiểm tra rằng nút con trái có con phải hay không.';
      } else {
        //cs["status"] = "Check whether the right child has a left child."; //status_predsucc_4
        cs["status"] = 'Kiểm tra rằng nút con phải có con trái hay không.';
      }
      cs["lineNo"] = 1;
      sl.push(cs);

      if (( isPred && (iBST[subTreeRoot]["rightChild"] != null)) ||
          (!isPred && (iBST[subTreeRoot]["leftChild"] != null))) {
        cur = subTreeRoot;
        currentVertexClass = iBST[cur]["vertexClassNumber"];

        cs = createState(iBST, vertexTraversed, edgeTraversed);
        cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][subTreeRootKey]["state"] = VERTEX_HIGHLIGHTED;
        if (isPred) {
          //cs["status"] = "Right child found! Go to the right."; //status_predsucc_5
          cs["status"] = 'Đã tìm thấy nút con phải! Đi sang phải.';
        } else {
          //cs["status"] = "Left child found! Go to the left."; //status_predsucc_6
          cs["status"] = 'Đã tìm thấy nút con trái! Đi sang trái.';
        }
        cs["lineNo"] = 1;
        sl.push(cs);

        while (( isPred && (iBST[cur]["rightChild"] != null)) ||
               (!isPred && (iBST[cur]["leftChild"] != null))) {
          cs = createState(iBST, vertexTraversed, edgeTraversed);
          cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
          cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
          vertexTraversed[cur] = true;
          if (isPred) {
            //cs["status"] = cur + " is not the predecessor vertex as it has a right child."; //status_predsucc_7
            cs["status"] = '{cur} không phải là đỉnh liền trước vì nó có con phải.'.replace("{cur}", cur);
          } else {
            //cs["status"] = cur + " is not the successor vertex as it has a left child.";  //status_predsucc_8
            cs["status"] = '{cur} không phải là đỉnh liền sau vì nó có con trái.'.replace("{cur}", cur);
          }
          cs["lineNo"] = 1;
          sl.push(cs);

          cur = (isPred ? iBST[cur]["rightChild"] : iBST[cur]["leftChild"]);
          currentVertexClass = iBST[cur]["vertexClassNumber"];

          cs = createState(iBST, vertexTraversed, edgeTraversed);
          var edgeHighlighted = currentVertexClass;
          edgeTraversed[edgeHighlighted] = true;
          cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
          cs["el"][edgeHighlighted]["animateHighlighted"] = true;
          cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
          if (isPred) {
            //cs["status"] = "Go right to check for larger value."; //status_predsucc_9
            cs["status"] = 'Đi sang phải để kiểm tra với giá trị lớn hơn.';
          } else {
            //cs["status"] = "Go left to check for smaller value."; //status_predsucc_10
            cs["status"] = 'Đi sang trái để kiểm tra với giá trị nhỏ hơn.';
          }
          cs["lineNo"] = 1;
          sl.push(cs);
        }

        ans = cur;

        cs = createState(iBST, vertexTraversed, edgeTraversed);
        cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
        if (isPred) {
          //cs["status"] = "Predecessor found!<br>The predecessor of " + val + " is " + ans + ".";  //status_predsucc_11
          cs["status"] = 'Đã tìm thấy nút liền trước!<div>Nút liền trước của {val} là {ans}.</div>'.replace("{ans}", ans).replace("{val}", val);
        } else {
          //cs["status"] = "Successor found!<br>The successor of " + val + " is " + ans + ".";  //status_predsucc_12
          cs["status"] = 'Đã tìm thấy nút liền sau!<div>Nút liền sau của {val} là {ans}.</div>'.replace("{ans}", ans).replace("{val}", val);
        }
        cs["vl"][key]["extratext"] = "value";
        cs["vl"][currentVertexClass]["extratext"] = "its " + (isPred ? "predecessor" : "successor");
        cs["lineNo"] = 1;
        sl.push(cs);
      }
      else {
        ans = subTreeRoot;

        cs = createState(iBST, vertexTraversed, edgeTraversed);
        cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][subTreeRootKey]["state"] = VERTEX_HIGHLIGHTED;
        if (isPred) {
          //cs["status"] = "No right child found, so this vertex is the predecessor.<br>The predecessor of " + val + " is " + ans + ".";  //status_predsucc_13
          cs["status"] = 'Không tìm thấy con phải, do đó đỉnh này là nút liền trước.<div>Nút liền trước của {val} là {ans}.</div>'.replace("{ans}", ans).replace("{val}", val);
        } else {
          //cs["status"] = "No left child found, so this vertex is the successor.<br>The successor of " + val + " is " + ans + "."; //status_predsucc_14
          cs["status"] = 'Không tìm thấy con trái, do đó đỉnh này là nút liền sau.<div>Nút liền sau của {val} là {ans}.</div>'.replace("{ans}", ans).replace("{val}", val);
        }
        cs["vl"][key]["extratext"] = "value";
        cs["vl"][subTreeRootKey]["extratext"] = "its " + (isPred ? "predecessor" : "successor");
        cs["lineNo"] = 1;
        sl.push(cs);
      }
    }
    else {
      currentVertexClass = iBST[cur]["vertexClassNumber"];

      edgeTraversed[currentVertexClass] = true;

      cs = createState(iBST, vertexTraversed, edgeTraversed);
      cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
      cs["el"][currentVertexClass]["state"] = EDGE_HIGHLIGHTED;
      if (isPred) {
        //cs["status"] = "No left child found, so check the parent..";  //status_predsucc_15
        cs["status"] = 'Không tìm thấy nút con trái, kiểm tra nút cha..';
      } else {
        //cs["status"] = "No right child found, so check the parent.."; //status_predsucc_16
        cs["status"] = 'Không tìm thấy nút con phải, kiểm tra nút cha..';
      }
      cs["lineNo"] = [2, 3];
      sl.push(cs);

      cur = iBST[cur]["parent"];
      currentVertexClass = iBST[cur]["vertexClassNumber"];

      while (true) {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
        vertexTraversed[cur] = true;
        if (( isPred && (cur > val)) ||
            (!isPred && (cur < val))) {
          if (isPred) {
            //cs["status"] = cur + " is not the predecessor vertex as " + val + " is part of the left sub-tree";  //status_predsucc_17
            cs["status"] = '{cur} không phải là đỉnh liền trước vì {val} nằm trong cây con bên trái'.replace("{cur}", cur).replace("{val}", val);
          } else {
            //cs["status"] = cur + " is not the successor vertex as " + val + " is part of the right sub-tree"; //status_predsucc_18
            cs["status"] = '{cur} không phải là đỉnh liền sau vì {val} nằm trong cây con bên phải'.replace("{cur}", cur).replace("{val}", val);
          }
          cs["lineNo"] = 4;
          sl.push(cs);
        }
        else {
          ans = cur;
          if (isPred) {
            //cs["status"] = "Predecessor found!<br>The predecessor of " + val + " is " + ans + ".";  //status_predsucc_19
            cs["status"] = 'Đã tìm thấy nút liền trước!<div>Nút liền trước của {val} là {ans}.</div>'.replace("{ans}", ans).replace("{val}", val);
          } else {
            //cs["status"] = "Successor found!<br>The successor of " + val + " is " + ans + ".";  //status_predsucc_20
            cs["status"] = 'Đã tìm thấy nút liền sau!<div>Nút liền sau của {val} là {ans}.</div>'.replace("{ans}", ans).replace("{val}", val);
          }
          cs["vl"][key]["extratext"] = "value";
          cs["vl"][currentVertexClass]["extratext"] = "its " + (isPred ? "predecessor" : "successor");
          cs["lineNo"] = 7;
          sl.push(cs);
          break;
        }

        cs = createState(iBST, vertexTraversed, edgeTraversed);
        var edgeHighlighted = currentVertexClass;
        if (cur != iBST["root"])
          edgeTraversed[edgeHighlighted] = true;
        cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
        if (cur != iBST["root"])
          cs["el"][edgeHighlighted]["state"] = EDGE_HIGHLIGHTED;
        //cs["status"] = "Go up to check for smaller value."; //status_predsucc_21
        cs["status"] = 'Đi lên để kiểm tra với giá trị nhỏ hơn.';
        cs["lineNo"] = 5;
        sl.push(cs);

        cur = iBST[cur]["parent"];
        if (cur == null) break;

        currentVertexClass = iBST[cur]["vertexClassNumber"];
      }

      if (cur == null) {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
        if (isPred) {
          //cs["status"] = "Parent is null, so " + val + " has no predecessor.";  //status_predsucc_22
          cs["status"] = 'Nút cha là rỗng, do đó {val} không có nút liền trước.'.replace("{val}", val);
        } else {
          //cs["status"] = "Parent is null, so " + val + " has no successor.";  //status_predsucc_23
          cs["status"] = 'Nút cha là rỗng, do đó {val} không có nút liền sau.'.replace("{val}", val);
        }
        cs["lineNo"] = 6;
        sl.push(cs);

        ans = null;
      }
    }

    gw.startAnimation(sl, callback);
    populatePseudocode(isPred ? 9 : 8);
    return true;
  }

  this.inorderTraversal = function(callback) {
    var sl = [], vertexTraversed = {}, edgeTraversed = {}, cur = iBST["root"], cs, key;
    var vertexHighlighted = {};

    cs = createState(iBST);
    //cs["status"] = "The current BST.";  //status_inorder_0
    cs["status"] = 'Cây BST hiện tại.';
    cs["lineNo"] = 0;
    sl.push(cs);

    if (iBST["root"] == null) {
      cs = createState(iBST);
      //cs["status"] = "The Binary Search Tree is empty.<br>Return empty result.";  //status_inorder_1
      cs["status"] = 'Cây Nhị Phân Tìm Kiếm rỗng.<div>Trả lại kết quả rỗng.</div>';
      cs["lineNo"] = [1, 2];
      sl.push(cs);
      return true;
    }
    else {
      key = iBST[iBST["root"]]["vertexClassNumber"];

      cs = createState(iBST);
      cs["vl"][key]["state"] = VERTEX_TRAVERSED;
      cs["vl"][key]["extratext"] = "root";
      //cs["status"] = "The root " + iBST["root"] + " is not null.";  //status_inorder_2
      cs["status"] = 'Gốc {root} khác <b>null</b>.'.replace("{root}", iBST["root"]);
      cs["lineNo"] = 1;
      sl.push(cs);

      cs = createState(iBST);
      cs["vl"][key]["state"] = VERTEX_TRAVERSED;
      cs["vl"][key]["extratext"] = "root";
      //cs["status"] = "So recurse and check left child of " + iBST["root"] + ".";  //status_inorder_3
      cs["status"] = 'Do đó, quay lại và kiểm tra con trái của {root}.'.replace("{root}", iBST["root"]);
      cs["lineNo"] = 3;
      sl.push(cs);

      inorderTraversalRecursion(iBST["root"]);
    }

    cs = createState(iBST, vertexTraversed, edgeTraversed);
    inorderHighlightVertex(key);
    //cs["status"] = "In-order traversal of the whole BST is complete.";  //status_inorder_4
    cs["status"] = 'Duyệt trung thứ tự toàn bộ BST đã hoàn tất.';
    cs["vl"][key]["extratext"] = "root";
    cs["lineNo"] = 0;
    sl.push(cs);

    gw.startAnimation(sl, callback);

    function inorderTraversalRecursion(cur) {
      var curLeft = iBST[cur]["leftChild"], curRight = iBST[cur]["rightChild"];
      var key = iBST[cur]["vertexClassNumber"];

      if (curLeft == null) {
        vertexTraversed[cur] = true;
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        inorderHighlightVertex(key);
        //cs["status"] = "The left child of vertex with value " + cur + " is empty.<br>Return empty.";  //status_inorder_5
        cs["status"] = 'Nút con trái của đỉnh với giá trị {cur} là rỗng.<br><div>Trả lại kết quả rỗng.</div>'.replace("{cur}", cur);
        cs["lineNo"] = [1, 2];
        sl.push(cs);
      }
      else {
        var curLeftClass = iBST[curLeft]["vertexClassNumber"];

        vertexTraversed[cur] = true;
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        inorderHighlightVertex(key);
        //cs["status"] = "The left child of vertex with value " + cur + " is " + curLeft + " (not null).";  //status_inorder_6
        cs["status"] = 'Nút con trái của đỉnh với giá trị {cur} là {curLeft} (khác <b>null</b>).<br>'.replace("{cur}", cur).replace("{curLeft}", curLeft);
        cs["lineNo"] = 1;
        sl.push(cs);
        edgeTraversed[curLeftClass] = true;
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        cs["el"][curLeftClass]["animateHighlighted"] = true;
        inorderHighlightVertex(key);
        //cs["status"] = "So recurse and check left child of vertex with value " + curLeft + ".";//status_inorder_7
        cs["status"] = 'Do đó, quay lại và kiểm tra con trái của đỉnh với giá trị {curLeft}.'.replace("{curLeft}", curLeft);
        cs["lineNo"] = 3;
        sl.push(cs);
        inorderTraversalRecursion(curLeft);
      }

      cs = createState(iBST, vertexTraversed, edgeTraversed);
      vertexHighlighted[key] = true;
      inorderHighlightVertex(key);
      //cs["status"] = "Visit vertex with value " + cur + ".<br>And preparing to visit the right child of this vertex.";  //status_inorder_8
      cs["status"] = 'Duyệt đỉnh với giá trị {cur}.<div>Và đang chuẩn bị để duyệt nút con phải của đỉnh này.</div>'.replace("{cur}", cur);
      cs["lineNo"] = 4;
      sl.push(cs);

      if (curRight == null) {
        vertexTraversed[cur] = true;
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        inorderHighlightVertex(key);
        //cs["status"] = "The right child of vertex with value " + cur + " is empty.<br>Return empty.<br>"; //status_inorder_9
        cs["status"] = 'Nút con phải của đỉnh với giá trị {cur} là rỗng.<br><div>Trả lại kết quả rỗng.</div>'.replace("{cur}", cur);
        cs["lineNo"] = [1, 2];
        sl.push(cs);
      }
      else {
        var curRightClass = iBST[curRight]["vertexClassNumber"];

        cs = createState(iBST, vertexTraversed, edgeTraversed);
        inorderHighlightVertex(key);
        //cs["status"] = "The right child of vertex with value " + cur + " is " + curRight + " (not null).";  //status_inorder_10
        cs["status"] = 'Nút con phải của đỉnh với giá trị {cur} là {curRight} (khác <b>null</b>).'.replace("{cur}", cur).replace("{curRight}", curRight);
        cs["lineNo"] = 1;
        sl.push(cs);
        edgeTraversed[curRightClass] = true;
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        cs["el"][curRightClass]["animateHighlighted"] = true;
        inorderHighlightVertex(key);
        cs["status"] = 'Do đó, quay lại và kiểm tra con phải của đỉnh với giá trị {curRight}.'.replace("{curRight}", curRight);
        cs["lineNo"] = 3;
        sl.push(cs);
        inorderTraversalRecursion(curRight);
      }

      cs = createState(iBST, vertexTraversed, edgeTraversed);
      if (cur != iBST["root"])
        cs["el"][key]["state"] = EDGE_HIGHLIGHTED;
      inorderHighlightVertex(key);

      //cs["status"] = "In-order traversal of " + cur + " is complete.";  //status_inorder_12
      cs["status"] = 'Duyệt trung thứ tự của {cur} đã hoàn tất.'.replace("{cur}", cur);
      cs["lineNo"] = 0;
      sl.push(cs);
    }

    function inorderHighlightVertex(curkey) {
      for (var key in vertexHighlighted) cs["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
      for (var key in vertexHighlighted) cs["vl"][key]["extratext"] = "";
      cs["vl"][curkey]["extratext"] = "^";
    }
    populatePseudocode(3);
    return true;
  }

  this.insertArr = function(vertexTextArr, callback) {
    var sl = [], vertexTraversed = {}, edgeTraversed = {}, cur = iBST["root"], cs, key, currentVertexClass, i;

    cs = createState(iBST);
    //cs["status"] = "The current BST.";  //status_insert_0
    cs["status"] = 'Cây BST hiện tại.';
    cs["lineNo"] = 0;
    sl.push(cs);

    // Check whether input is array
    if (Object.prototype.toString.call(vertexTextArr) != '[object Array]') {
      $('#insert-err').html('Hãy điền một số nguyên hoặc một dãy số nguyên được ngăn cách bởi dấu phảy!');
      return false;
    }

    // Loop through all array values and...
    var tempiBST = deepCopy(iBST); // Use this to simulate internal insertion

    for (i = 0; i < vertexTextArr.length; i++) {
      var vt = parseInt(vertexTextArr[i]);

      // 1. Check whether value is number
      if (isNaN(vt)) {
        $('#insert-err').html('Hãy điền một số nguyên hoặc một dãy số nguyên được ngăn cách bởi dấu phảy!');
        return false;
      }

      // 2. No duplicates allowed. Also works if more than one similar value are inserted
      if (tempiBST[vt] != null) {
        $('#insert-err').html('Không được phép có hai phần tử trùng nhau!');
        if (typeof callback == 'function') callback();
        return false;
      }

      // 3. Check range
      if (parseInt(vt) < valueRange[0] || parseInt(vt) > valueRange[1]) {
        $('#insert-err').html('Rất tiếc, chỉ có thể chèn các giá trị từ {range1} đến {range2}.'.replace("{range1}", valueRange[0]).replace("{range2}", valueRange[1]));
        return false;
      }

      // 4. Insert the node into temporary internal structure and check for height
      var parentVertex = tempiBST["root"];
      var heightCounter = 0;

      if (parentVertex == null) {
        tempiBST["root"] = parseInt(vt);
        tempiBST[vt] = {
          "parent": null,
          "leftChild": null,
          "rightChild": null
        };
      }
      else {
        while (true) {
          heightCounter++;
          if (parentVertex < vt) {
            if (tempiBST[parentVertex]["rightChild"] == null)
              break;
            parentVertex = tempiBST[parentVertex]["rightChild"];
          }
          else {
            if (tempiBST[parentVertex]["leftChild"] == null)
              break;
            parentVertex = tempiBST[parentVertex]["leftChild"];
          }
        }

        if (parentVertex < vt)
          tempiBST[parentVertex]["rightChild"] = vt;
        else
          tempiBST[parentVertex]["leftChild"] = vt;

        tempiBST[vt] = {
          "parent": parentVertex,
          "leftChild": null,
          "rightChild": null
        }
      }

      heightCounter++; // New vertex added will add new height

      if (heightCounter > maxHeightAllowed+1) {
        $('#insert-err').html('Rất tiếc, mô phỏng chỉ hỗ trợ cây có độ cao tối đa là {maxHeight}.'.replace("{maxHeight}", maxHeightAllowed));
        if (typeof callback == 'function') callback();
        return false;
      }
    }

    function checkNewHeight() {
      var parentVertex = tempiBST["root"];
      var heightCounter = 0;

      while (parentVertex != null) {
        if (parentVertex < parseInt(val))
          parentVertex = tempiBST[parentVertex]["rightChild"];
        else
          parentVertex = tempiBST[parentVertex]["leftChild"];
        heightCounter++;
      }

      heightCounter++; // New vertex added will add new height

      if (heightCounter > maxHeightAllowed+1)
        return false;
      return true;
    }

    for (i = 0; i < vertexTextArr.length; i++) {
      var val = parseInt(vertexTextArr[i]);

      // Re-initialization
      vertexTraversed = {};
      edgeTraversed = {};
      cur = iBST["root"];
      cs = createState(iBST);

      // Find parent
      while (cur != val && cur != null) {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        currentVertexClass = iBST[cur]["vertexClassNumber"];

        cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        vertexTraversed[cur] = true;

        //cs["status"] = "Comparing " + val + " with " + cur; //status_insert_1
        cs["status"] = 'Đang so sánh {val} với {cur}'.replace("{val}", val).replace("{cur}", cur);
        if (!isAVL) cs["lineNo"] = 3;
        else        cs["lineNo"] = 1;

        sl.push(cs);

        var nextVertex;
        if (parseInt(val) > parseInt(cur))
          nextVertex = iBST[cur]["rightChild"];
        else
          nextVertex = iBST[cur]["leftChild"];

        if (nextVertex == null)
          break;
        else
          cur = nextVertex;

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        var edgeHighlighted = iBST[cur]["vertexClassNumber"];
        edgeTraversed[edgeHighlighted] = true;

        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;

        if (parseInt(val) > parseInt(iBST[cur]["parent"])) {
          //cs["status"] = val + " is larger than " + iBST[cur]["parent"] + ", so go right."; //status_insert_2
          cs["status"] = '{val} lớn hơn {parent}, vì vậy đi sang phải.'.replace("{val}", val).replace("{parent}", iBST[cur]["parent"]);
          if (!isAVL) cs["lineNo"] = 5;
          else        cs["lineNo"] = 1;
        }
        else {
          //cs["status"] = val + " is smaller than " + iBST[cur]["parent"] + ", so go left."; //status_insert_3
          cs["status"] = '{val} nhỏ hơn {parent}, vì vậy đi sang trái.'.replace("{val}", val).replace("{parent}", iBST[cur]["parent"]);
          if (!isAVL) cs["lineNo"] = 4;
          else        cs["lineNo"] = 1;
        }

        sl.push(cs);
      }

      // Begin insertion
      // First, update internal representation
      iBST[parseInt(val)] = {
        "leftChild": null,
        "rightChild": null,
        "vertexClassNumber": amountVertex
      };

      if (cur != null) {
        iBST[parseInt(val)]["parent"] = cur;
        if (cur < parseInt(val))
          iBST[cur]["rightChild"] = parseInt(val);
        else
          iBST[cur]["leftChild"] = parseInt(val);
      }

      else {
        iBST[parseInt(val)]["parent"] = null;
        iBST["root"] = parseInt(val);
      }

      amountVertex++;
      recalculatePosition();

      // Then, draw edge
      var newNodeVertexClass = iBST[parseInt(val)]["vertexClassNumber"];

      if (cur != null) {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        cs["vl"][newNodeVertexClass]["state"] = OBJ_HIDDEN;

        cs["el"][newNodeVertexClass]["state"] = EDGE_TRAVERSED;
        cs["el"][newNodeVertexClass]["animateHighlighted"] = true;

        //cs["status"] = "Location found!<br>Inserting " + val + "."; //status_insert_4
        cs["status"] = 'Đã tìm thấy vị trí!<div>Đang chèn {val}.</div>'.replace("{val}", val);
        cs["lineNo"] = 1;

        sl.push(cs);

        edgeTraversed[newNodeVertexClass] = true;
      }

      // Lastly, draw vertex
      cs = createState(iBST, vertexTraversed, edgeTraversed);
      cs["vl"][newNodeVertexClass]["state"] = EDGE_HIGHLIGHTED;

      //cs["status"] = val + " has been inserted!"  //status_insert_5
      cs["status"] = '{val} đã được chèn vào!'.replace("{val}", val);
      if (!isAVL) cs["lineNo"] = 2;
      else        cs["lineNo"] = 1;
      sl.push(cs);

      // End State
      cs = createState(iBST);
      //cs["status"] = "Insert " + val + " has been completed." //status_insert_6
      cs["status"] = 'Việc chèn {val} đã hoàn tất.'.replace("{val}", val);
      if (isAVL) cs["lineNo"] = 1;
      sl.push(cs);

      if (isAVL) {
        recalculateBalanceFactor();

        var vertexCheckBf = iBST[val]["parent"];
        while (vertexCheckBf != null) {
          var vertexCheckBfClass = iBST[vertexCheckBf]["vertexClassNumber"];
          var bf = iBST[vertexCheckBf]["balanceFactor"];

          cs = createState(iBST);
          cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
          //cs["status"] = "Balance factor of " + vertexCheckBf + " is " + bf + ".";  //status_insert_7
          cs["status"] = 'Hệ số cân bằng của {<span style="white-space: normal;">vertexCheckBf</span>} là {bf}.'.replace("{vertexCheckBf}", vertexCheckBf).replace("{bf}", bf);
          cs["lineNo"] = 2;
          sl.push(cs);

          if (bf == 2) {
            var vertexCheckBfLeft = iBST[vertexCheckBf]["leftChild"];
            var vertexCheckBfLeftClass = iBST[vertexCheckBfLeft]["vertexClassNumber"];
            var bfLeft = iBST[vertexCheckBfLeft]["balanceFactor"];

            cs = createState(iBST);
            cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
            cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
            //cs["status"] = "And balance factor of " + vertexCheckBfLeft + " is " + bfLeft + ".";  //status_insert_8
            cs["status"] = 'Và hệ số cân bằng của {<span style="white-space: normal;">vertexCheckBf</span>} là {bf}.'.replace("{vertexCheckBf}", vertexCheckBfLeft).replace("{bf}", bfLeft);
            cs["lineNo"] = 2;
            sl.push(cs);

            if (bfLeft == 1 || bfLeft == 0) {
              rotateRight(vertexCheckBf);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfLeft)
                cs["el"][vertexCheckBfLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate right " + vertexCheckBf + "."; //status_insert_9
              cs["status"] = 'Xoay phải {<span style="white-space: normal;">vertexCheckBf</span>}.'.replace("{vertexCheckBf}", vertexCheckBf);
              cs["lineNo"] = 3;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfLeft)
                cs["el"][vertexCheckBfLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_insert_10
              cs["status"] = 'Bố trí lại cây<br>';
              cs["lineNo"] = 3;
              sl.push(cs);
            }
            else if (bfLeft == -1) {
              var vertexCheckBfLeftRight = iBST[vertexCheckBfLeft]["rightChild"];
              var vertexCheckBfLeftRightClass = iBST[vertexCheckBfLeftRight]["vertexClassNumber"];

              rotateLeft(vertexCheckBfLeft);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfLeftClass]["state"] = EDGE_HIGHLIGHTED;
              cs["el"][vertexCheckBfLeftRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate left " + vertexCheckBfLeft + ".";  //status_insert_11
              cs["status"] = 'Xoay trái {<span style="white-space: normal;">vertexCheckBf</span>}.'.replace("{vertexCheckBf}", vertexCheckBfLeft);
              cs["lineNo"] = 4;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfLeftClass]["state"] = EDGE_HIGHLIGHTED;
              cs["el"][vertexCheckBfLeftRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_insert_10
              cs["status"] = 'Bố trí lại cây<br>';
              cs["lineNo"] = 4;
              sl.push(cs);

              rotateRight(vertexCheckBf);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfLeftRight)
                cs["el"][vertexCheckBfLeftRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate right " + vertexCheckBf + "."; //status_insert_9
              cs["status"] = 'Xoay phải {<span style="white-space: normal;">vertexCheckBf</span>}.'.replace("{vertexCheckBf}", vertexCheckBf);
              cs["lineNo"] = 4;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfLeftRight)
                cs["el"][vertexCheckBfLeftRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_insert_10
              cs["status"] = 'Bố trí lại cây<br>';
              cs["lineNo"] = 4;
              sl.push(cs);
            }
          }
          else if (bf == -2) {
            var vertexCheckBfRight = iBST[vertexCheckBf]["rightChild"];
            var vertexCheckBfRightClass = iBST[vertexCheckBfRight]["vertexClassNumber"];
            var bfRight = iBST[vertexCheckBfRight]["balanceFactor"];

            cs = createState(iBST);
            cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
            cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
            //cs["status"] = "And balance factor of " + vertexCheckBfRight + " is " + bfRight + ".";  //status_insert_8
            cs["status"] = 'Và hệ số cân bằng của {<span style="white-space: normal;">vertexCheckBf</span>} là {bf}.'.replace("{vertexCheckBf}", vertexCheckBfRight).replace("{bf}", bfRight);
            cs["lineNo"] = 2;
            sl.push(cs);

            if (bfRight == 1) {
              var vertexCheckBfRightLeft = iBST[vertexCheckBfRight]["leftChild"];
              var vertexCheckBfRightLeftClass = iBST[vertexCheckBfRightLeft]["vertexClassNumber"];

              rotateRight(vertexCheckBfRight);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfRightClass]["state"] = EDGE_HIGHLIGHTED;
              cs["el"][vertexCheckBfRightLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate right " + vertexCheckBfRight + ".";  //status_insert_9
              cs["status"] = 'Xoay phải {<span style="white-space: normal;">vertexCheckBf</span>}.'.replace("{vertexCheckBf}", vertexCheckBfRight);
              cs["lineNo"] = 6;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfRightClass]["state"] = EDGE_HIGHLIGHTED;
              cs["el"][vertexCheckBfRightLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_insert_10
              cs["status"] = 'Bố trí lại cây<br>';
              cs["lineNo"] = 6;
              sl.push(cs);

              rotateLeft(vertexCheckBf);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfRightLeft)
                cs["el"][vertexCheckBfRightLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate left " + vertexCheckBf + ".";  //status_insert_11
              cs["status"] = 'Xoay trái {<span style="white-space: normal;">vertexCheckBf</span>}.'.replace("{vertexCheckBf}", vertexCheckBf);
              cs["lineNo"] = 6;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfRightLeft)
                cs["el"][vertexCheckBfRightLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_insert_10
              cs["status"] = 'Bố trí lại cây<br>';
              cs["lineNo"] = 6;
              sl.push(cs);
            }
            else if (bfRight == -1 || bfRight == 0) {
              rotateLeft(vertexCheckBf);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfRight)
                cs["el"][vertexCheckBfRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate left " + vertexCheckBf + ".";  //status_insert_11
              cs["status"] = 'Xoay trái {<span style="white-space: normal;">vertexCheckBf</span>}.'.replace("{vertexCheckBf}", vertexCheckBf);
              cs["lineNo"] = 5;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);

              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfRight)
                cs["el"][vertexCheckBfRightClass]["state"] = EDGE_HIGHLIGHTED;
              cs["status"] = "Relayout the tree.";  //status_insert_10
              cs["status"] = 'Bố trí lại cây<br>';
              cs["lineNo"] = 5;
              sl.push(cs);
            }
          }

          if (vertexCheckBf != iBST["root"]) {
            cs = createState(iBST);
            cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
            //cs["status"] = "Check the parent vertex.";  //status_insert_12
            cs["status"] = 'Kiểm tra đỉnh cha.';
            cs["lineNo"] = 2;
            sl.push(cs);
          }

          vertexCheckBf = iBST[vertexCheckBf]["parent"];
        }

        cs = createState(iBST);
        //cs["status"] = "The tree is now balanced."; //status_insert_13
        cs["status"] = 'Cây đã cân bằng.';
        cs["lineNo"] = 7;
        sl.push(cs);
      }
    }

    gw.startAnimation(sl, callback);
    if (isAVL) populatePseudocode(6);
    else       populatePseudocode(0);
    return true;
  }

  this.removeArr = function(vertexTextArr, callback) {
    var sl = [];
    var vertexTraversed = {};
    var edgeTraversed = {};
    var cur = iBST["root"];
    var cs = createState(iBST);
    var currentVertexClass;
    var key;
    var i;

    //cs["status"] = "The current BST"; //status_remove_0
    cs["status"] = 'Cây BST hiện tại';
    cs["lineNo"] = 0;
    sl.push(cs);

    if (Object.prototype.toString.call(vertexTextArr) != '[object Array]') {
      $('#remove-err').html('Hãy điền một số nguyên hoặc một dãy số nguyên được ngăn cách bởi dấu phảy!');
      return false;
    }

    // Loop through all array values and...
    for (i = 0; i < vertexTextArr.length; i++) {
      var vt = parseInt(vertexTextArr[i]);

      // Check whether value is number
      if (isNaN(vt)) {
        $('#remove-err').html('Hãy điền một số nguyên hoặc một dãy số nguyên được ngăn cách bởi dấu phảy!');
        return false;
      }
      // Other checks not required
    }

    for (i = 0; i < vertexTextArr.length; i++) {
      var val = parseInt(vertexTextArr[i]);
      var vertexCheckBf;

      // Re-initialization
      vertexTraversed = {};
      edgeTraversed = {};
      cur = iBST["root"];
      cs = createState(iBST);

      // Find vertex
      while (cur != val && cur != null) {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        currentVertexClass = iBST[cur]["vertexClassNumber"];

        cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        vertexTraversed[cur] = true;

        //cs["status"] = "Searching for node " + val + " to remove";  //status_remove_1
        cs["status"] = 'Đang tìm kiếm nút {val} để xóa'.replace("{val}", val);
        cs["lineNo"] = 1;
        sl.push(cs);

        if (parseInt(val) > parseInt(cur))
          cur = iBST[cur]["rightChild"];
        else
          cur = iBST[cur]["leftChild"];

        if (cur == null) break;

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        var edgeHighlighted = iBST[cur]["vertexClassNumber"];
        edgeTraversed[edgeHighlighted] = true;

        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;

        //cs["status"] = "Searching for node " + val + " to remove";  //status_remove_1
        cs["status"] = 'Đang tìm kiếm nút {val} để xóa'.replace("{val}", val);
        cs["lineNo"] = 1;
        sl.push(cs);
      }

      if (cur != null) {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        currentVertexClass = iBST[cur]["vertexClassNumber"];

        cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        //cs["status"] = "Searching for node " + val + " to remove";  //status_remove_1
        cs["status"] = 'Đang tìm kiếm nút {val} để xóa'.replace("{val}", val);
        cs["lineNo"] = 1;
        sl.push(cs);
      }
      // Vertex is not inside the tree
      else {
        cs = createState(iBST);
        //cs["status"] = "Node " + val + " is not in the BST";  //status_remove_2
        cs["status"] = 'Nút {val} không có trong cây BST.'.replace("{val}", val);
        cs["lineNo"] = 0; //Node {val} is not in the BST
        sl.push(cs);
        continue;
      }

      // Vertex found; begin deletion
      // Case 1: no child
      if (iBST[cur]["leftChild"] == null && iBST[cur]["rightChild"] == null) {
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        //cs["status"] = "Node " + val + " has no children. It is a leaf."; //status_remove_3
        cs["status"] = 'Nút {val} không có nút con. Đây là nút lá.'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 2;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        var parentVertex = iBST[cur]["parent"];

        if (parentVertex != null) {
          if (parseInt(parentVertex) < parseInt(cur))
            iBST[parentVertex]["rightChild"] = null;
          else
            iBST[parentVertex]["leftChild"] = null;
        }
        else
          iBST["root"] = null;

        currentVertexClass = iBST[cur]["vertexClassNumber"];
        delete iBST[cur];
        delete vertexTraversed[cur];
        delete edgeTraversed[currentVertexClass];

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        //cs["status"] = "Remove leaf " + val;  //status_remove_4
        cs["status"] = 'Xóa lá {val}'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 3;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        vertexCheckBf = parentVertex;
      }
      // Case 2: One child
      else if (iBST[cur]["leftChild"] == null) { // Only right child
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        //cs["status"] = "Node " + val + " has a right child only"; //status_remove_5
        cs["status"] = 'Nút {val} chỉ có nút con phải'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 4;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        var parentVertex = iBST[cur]["parent"];
        var rightChildVertex = iBST[cur]["rightChild"];

        if (parentVertex != null) {
          if (parseInt(parentVertex) < parseInt(cur))
            iBST[parentVertex]["rightChild"] = rightChildVertex;
          else
            iBST[parentVertex]["leftChild"] = rightChildVertex;
        }
        else
          iBST["root"] = rightChildVertex;

        iBST[rightChildVertex]["parent"] = parentVertex;

        currentVertexClass = iBST[cur]["vertexClassNumber"];
        rightChildVertexClass = iBST[rightChildVertex]["vertexClassNumber"];
        delete iBST[cur];
        delete vertexTraversed[cur];
        delete edgeTraversed[currentVertexClass];

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        cs["vl"][rightChildVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        if (parentVertex != null)
          cs["el"][rightChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

        //cs["status"] = "Delete node " + val + " and connect its parent to its right child"; //status_remove_6
        cs["status"] = 'Xóa nút {val} và nối nút cha với nút con phải của nó'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 5;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        recalculatePosition();

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        cs["vl"][rightChildVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        if (parentVertex != null)
          cs["el"][rightChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

        //cs["status"] = "Re-layout the tree";  //status_remove_7
        cs["status"] = 'Bố trí lại cây';
        if (!isAVL) cs["lineNo"] = 5;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        vertexCheckBf = rightChildVertex;
      }
      else if (iBST[cur]["rightChild"] == null) { // Only left child
        cs = createState(iBST, vertexTraversed, edgeTraversed);
        //cs["status"] = "Node " + val + " has a left child only";  //status_remove_8
        cs["status"] = 'Nút {val} chỉ có nút con trái'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 4;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        var parentVertex = iBST[cur]["parent"];
        var leftChildVertex = iBST[cur]["leftChild"];

        if (parentVertex != null) {
          if (parseInt(parentVertex) < parseInt(cur))
            iBST[parentVertex]["rightChild"] = leftChildVertex;
          else
            iBST[parentVertex]["leftChild"] = leftChildVertex;
        }
        else
          iBST["root"] = leftChildVertex;

        iBST[leftChildVertex]["parent"] = parentVertex;

        currentVertexClass = iBST[cur]["vertexClassNumber"];
        leftChildVertexClass = iBST[leftChildVertex]["vertexClassNumber"];
        delete iBST[cur];
        delete vertexTraversed[cur];
        delete edgeTraversed[currentVertexClass];

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        cs["vl"][leftChildVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        if (parentVertex != null)
          cs["el"][leftChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

        //cs["status"] = "Delete node " + val + " and connect its parent to its left child";  //status_remove_9
        cs["status"] = 'Xóa nút {val} và nối nút cha với nút con trái của nó.'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 5;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        recalculatePosition();

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        cs["vl"][leftChildVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        if (parentVertex != null)
          cs["el"][leftChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

        //cs["status"] = "Re-layout the tree";  //status_remove_7
        cs["status"] = 'Bố trí lại cây';
        if (!isAVL) cs["lineNo"] = 5;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        vertexCheckBf = leftChildVertex;
      }
      else { // Case 3: two children
        var parentVertex = iBST[cur]["parent"];
        var leftChildVertex = iBST[cur]["leftChild"];
        var rightChildVertex = iBST[cur]["rightChild"];
        var successorVertex = iBST[cur]["rightChild"];
        var successorVertexClass = iBST[successorVertex]["vertexClassNumber"];

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        cs["el"][successorVertexClass]["state"] = EDGE_TRAVERSED;
        cs["el"][successorVertexClass]["animateHighlighted"] = true;

        //cs["status"] = "Finding successor of " + val; //status_remove_10
        cs["status"] = 'Đang tìm nút liền sau của {val}'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 6;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        edgeTraversed[successorVertexClass] = true;
        vertexTraversed[successorVertex] = true;

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][successorVertexClass]["state"] = VERTEX_HIGHLIGHTED;

        //cs["status"] = "Finding successor of " + val; //status_remove_10
        cs["status"] = 'Đang tìm nút liền sau của {val}'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 6;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        while (iBST[successorVertex]["leftChild"] != null) {
          successorVertex = iBST[successorVertex]["leftChild"];
          successorVertexClass = iBST[successorVertex]["vertexClassNumber"];

          cs = createState(iBST, vertexTraversed, edgeTraversed);

          cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;

          cs["el"][successorVertexClass]["state"] = EDGE_TRAVERSED;
          cs["el"][successorVertexClass]["animateHighlighted"] = true;

          //cs["status"] = "Finding successor of " + val; //status_remove_10
          cs["status"] = 'Đang tìm nút liền sau của {val}'.replace("{val}", val);
          if (!isAVL) cs["lineNo"] = 6;
          else        cs["lineNo"] = 1;
          sl.push(cs);

          edgeTraversed[successorVertexClass] = true;
          vertexTraversed[successorVertex] = true;

          cs = createState(iBST, vertexTraversed, edgeTraversed);

          cs["vl"][currentVertexClass]["state"] = VERTEX_HIGHLIGHTED;
          cs["vl"][successorVertexClass]["state"] = VERTEX_HIGHLIGHTED;

          //cs["status"] = "Finding successor of " + val; //status_remove_10
          cs["status"] = 'Đang tìm nút liền sau của {val}'.replace("{val}", val);
          if (!isAVL) cs["lineNo"] = 6;
          else        cs["lineNo"] = 1;
          sl.push(cs);
        }

        var successorParentVertex = iBST[successorVertex]["parent"]
        var successorRightChildVertex = iBST[successorVertex]["rightChild"];

        // Update internal representation
        if (parentVertex != null) {
          if (parseInt(parentVertex) < parseInt(cur))
            iBST[parentVertex]["rightChild"] = successorVertex;
          else
            iBST[parentVertex]["leftChild"] = successorVertex;
        }
        else
          iBST["root"] = successorVertex;

        iBST[successorVertex]["parent"] = parentVertex;
        iBST[successorVertex]["leftChild"] = leftChildVertex;

        iBST[leftChildVertex]["parent"] = successorVertex;

        if (successorVertex != rightChildVertex) {
          iBST[successorVertex]["rightChild"] = rightChildVertex;
          iBST[rightChildVertex]["parent"] = successorVertex;

          if (successorRightChildVertex != null) {
            if (parseInt(successorParentVertex) < parseInt(successorVertex))
              iBST[successorParentVertex]["rightChild"] = successorRightChildVertex;
            else
              iBST[successorParentVertex]["leftChild"] = successorRightChildVertex;
            iBST[successorRightChildVertex]["parent"] = successorParentVertex;
          }
          else {
            if (parseInt(successorParentVertex) < parseInt(successorVertex))
              iBST[successorParentVertex]["rightChild"] = null;
            else
              iBST[successorParentVertex]["leftChild"] = null;
          }
        }

        delete iBST[cur];
        delete vertexTraversed[cur];
        delete edgeTraversed[currentVertexClass];

        if (parentVertex == null)
          delete edgeTraversed[successorVertexClass];

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        var leftChildVertexClass = iBST[leftChildVertex]["vertexClassNumber"];

        cs["vl"][successorVertexClass]["state"] = VERTEX_HIGHLIGHTED;
        cs["el"][leftChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

        if (parentVertex != null) {
          var parentVertexClass = iBST[parentVertex]["vertexClassNumber"];
          cs["el"][successorVertexClass]["state"] = EDGE_HIGHLIGHTED;
        }

        if (successorVertex != rightChildVertex) {
          var rightChildVertexClass = iBST[rightChildVertex]["vertexClassNumber"];
          cs["el"][rightChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

          if (successorRightChildVertex != null) {
            var successorRightChildVertexClass = iBST[successorRightChildVertex]["vertexClassNumber"];
            cs["el"][successorRightChildVertexClass]["state"] = EDGE_HIGHLIGHTED;
          }
        }

        //cs["status"] = "Replace node " + val + " with its successor"; //status_remove_11
        cs["status"] = 'Thay thế nút {val} với nút liền sau nó'.replace("{val}", val);
        if (!isAVL) cs["lineNo"] = 6;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        recalculatePosition();

        cs = createState(iBST, vertexTraversed, edgeTraversed);

        leftChildVertexClass = iBST[leftChildVertex]["vertexClassNumber"];

        cs["vl"][successorVertexClass]["state"] = VERTEX_HIGHLIGHTED;
        cs["el"][leftChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

        if (parentVertex != null) {
          var parentVertexClass = iBST[parentVertex]["vertexClassNumber"];
          cs["el"][successorVertexClass]["state"] = EDGE_HIGHLIGHTED;
        }

        if (successorVertex != rightChildVertex) {
          var rightChildVertexClass = iBST[rightChildVertex]["vertexClassNumber"];
          cs["el"][rightChildVertexClass]["state"] = EDGE_HIGHLIGHTED;

          if (successorRightChildVertex != null) {
            var successorRightChildVertexClass = iBST[successorRightChildVertex]["vertexClassNumber"];
            cs["el"][successorRightChildVertexClass]["state"] = EDGE_HIGHLIGHTED;
          }
        }

        //cs["status"] = "Re-layout the tree";  //status_remove_7
        cs["status"] = 'Bố trí lại cây';
        if (!isAVL) cs["lineNo"] = 6;
        else        cs["lineNo"] = 1;
        sl.push(cs);

        vertexCheckBf = successorVertex;
        if (successorVertex != rightChildVertex)
          vertexCheckBf = successorParentVertex;
      }

      cs = createState(iBST);
      //cs["status"] = "Removal of " + val + " completed";  //status_remove_12
      cs["status"] = 'Việc xóa {val} đã hoàn tất'.replace("{val}", val);
      if (!isAVL) cs["lineNo"] = 0;
      else        cs["lineNo"] = 1;
      sl.push(cs);

      if (isAVL) {
        recalculateBalanceFactor();
        // console.log(iBST);

        while (vertexCheckBf != null) {
          var vertexCheckBfClass = iBST[vertexCheckBf]["vertexClassNumber"];

          var bf = iBST[vertexCheckBf]["balanceFactor"];

          cs = createState(iBST);
          cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
          //cs["status"] = "Balance factor of " + vertexCheckBf + " is " + bf + ".";  //status_remove_13
          cs["status"] = 'Hệ số cân bằng của {<span style="white-space: normal;">vertexCheckBf</span>} là {bf}.'.replace("{vertexCheckBf}", vertexCheckBf).replace("{bf}", bf);
          cs["lineNo"] = 2;
          sl.push(cs);

          if (bf == 2) {
            var vertexCheckBfLeft = iBST[vertexCheckBf]["leftChild"];
            var vertexCheckBfLeftClass = iBST[vertexCheckBfLeft]["vertexClassNumber"];
            var bfLeft = iBST[vertexCheckBfLeft]["balanceFactor"];

            cs = createState(iBST);
            cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
            cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
            //cs["status"] = "And balance factor of " + vertexCheckBfLeft + " is " + bfLeft + ".";  //status_remove_14
            cs["status"] = 'Và hệ số cân bằng của {<span style="white-space: normal;">vertexCheckBf</span>} là {bf}.'.replace("{vertexCheckBfLeft}", vertexCheckBf).replace("{bfLeft}", bf);
            cs["lineNo"] = 2;
            sl.push(cs);

            if (bfLeft == 1 || bfLeft == 0) {
              rotateRight(vertexCheckBf);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfLeft)
                cs["el"][vertexCheckBfLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate right " + vertexCheckBf + "."; //status_remove_15
              cs["status"] = 'Xoay phải {<span style="white-space: normal;">vertexCheckBf</span>}.<br>'.replace("{vertexCheckBf}", vertexCheckBf);
              cs["lineNo"] = 3;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfLeft)
                cs["el"][vertexCheckBfLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_remove_7
              cs["status"] = 'Bố trí lại cây';
              cs["lineNo"] = 3;
              sl.push(cs);
            }
            else if (bfLeft == -1) {
              var vertexCheckBfLeftRight = iBST[vertexCheckBfLeft]["rightChild"];
              var vertexCheckBfLeftRightClass = iBST[vertexCheckBfLeftRight]["vertexClassNumber"];

              rotateLeft(vertexCheckBfLeft);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfLeftClass]["state"] = EDGE_HIGHLIGHTED;
              cs["el"][vertexCheckBfLeftRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate left " + vertexCheckBfLeft + ".";  //status_remove_16
              cs["status"] = 'Xoay trái {<span style="white-space: normal;">vertexCheckBf</span>}.'.replace("{vertexCheckBf}", vertexCheckBfLeft);
              cs["lineNo"] = 4;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfLeftClass]["state"] = EDGE_HIGHLIGHTED;
              cs["el"][vertexCheckBfLeftRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_remove_7
              cs["status"] = 'Bố trí lại cây';
              cs["lineNo"] = 4;
              sl.push(cs);

              rotateRight(vertexCheckBf);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfLeftRight)
                cs["el"][vertexCheckBfLeftRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate right " + vertexCheckBf + "."; //status_remove_15
              cs["status"] = 'Xoay phải {<span style="white-space: normal;">vertexCheckBf</span>}.<br>'.replace("{vertexCheckBf}", vertexCheckBf);
              cs["lineNo"] = 4;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfLeftRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfLeftRight)
                cs["el"][vertexCheckBfLeftRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_remove_7
              cs["status"] = 'Bố trí lại cây';
              cs["lineNo"] = 4;
              sl.push(cs);
            }
          }
          else if (bf == -2) {
            var vertexCheckBfRight = iBST[vertexCheckBf]["rightChild"];
            var vertexCheckBfRightClass = iBST[vertexCheckBfRight]["vertexClassNumber"];
            var bfRight = iBST[vertexCheckBfRight]["balanceFactor"];

            cs = createState(iBST);
            cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
            cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
            //cs["status"] = "And balance factor of " + vertexCheckBfRight + " is " + bfRight + ".";  //status_remove_14
            cs["status"] = 'Và hệ số cân bằng của {<span style="white-space: normal;">vertexCheckBf</span>} là {bf}.'.replace("{vertexCheckBf}", vertexCheckBfRight).replace("{bf}", bfRight);
            cs["lineNo"] = 2;
            sl.push(cs);

            if (bfRight == 1) {
              var vertexCheckBfRightLeft = iBST[vertexCheckBfRight]["leftChild"];
              var vertexCheckBfRightLeftClass = iBST[vertexCheckBfRightLeft]["vertexClassNumber"];

              rotateRight(vertexCheckBfRight);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfRightClass]["state"] = EDGE_HIGHLIGHTED;
              cs["el"][vertexCheckBfRightLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate right " + vertexCheckBfRight + ".";  //status_remove_15
              cs["status"] = 'Xoay phải {<span style="white-space: normal;">vertexCheckBf</span>}.<br>'.replace("{vertexCheckBf}", vertexCheckBfRight);
              cs["lineNo"] = 6;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfRightClass]["state"] = EDGE_HIGHLIGHTED;
              cs["el"][vertexCheckBfRightLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_remove_7
              cs["status"] = 'Bố trí lại cây';
              cs["lineNo"] = 6;
              sl.push(cs);

              rotateLeft(vertexCheckBf);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfRightLeft)
                cs["el"][vertexCheckBfRightLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate left " + vertexCheckBf + ".";  //status_remove_16
              cs["status"] = 'Xoay trái {<span style="white-space: normal;">vertexCheckBf</span>}.'.replace("{vertexCheckBf}", vertexCheckBf);
              cs["lineNo"] = 6;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightLeftClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfRightLeft)
                cs["el"][vertexCheckBfRightLeftClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_remove_7
              cs["status"] = 'Bố trí lại cây';
              cs["lineNo"] = 6;
              sl.push(cs);
            }
            else if (bfRight == -1 || bfRight == 0) {
              rotateLeft(vertexCheckBf);

              cs = createState(iBST);
              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfRight)
                cs["el"][vertexCheckBfRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Rotate left " + vertexCheckBf + ".";  //status_remove_16
              cs["status"] = 'Xoay trái {<span style="white-space: normal;">vertexCheckBf</span>}.'.replace("{vertexCheckBf}", vertexCheckBf);
              cs["lineNo"] = 5;
              sl.push(cs);

              recalculatePosition();

              cs = createState(iBST);

              cs["vl"][vertexCheckBfClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["vl"][vertexCheckBfRightClass]["state"] = VERTEX_HIGHLIGHTED;
              cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
              if (iBST["root"] != vertexCheckBfRight)
                cs["el"][vertexCheckBfRightClass]["state"] = EDGE_HIGHLIGHTED;
              //cs["status"] = "Relayout the tree.";  //status_remove_7
              cs["status"] = 'Bố trí lại cây';
              cs["lineNo"] = 5;
              sl.push(cs);
            }
          }

          if (vertexCheckBf != iBST["root"]) {
            cs = createState(iBST);
            cs["el"][vertexCheckBfClass]["state"] = EDGE_HIGHLIGHTED;
            //cs["status"] = "Check the parent vertex...";  //status_remove_17
            cs["status"] = 'Kiểm tra đỉnh cha.';
            cs["lineNo"] = 2;
            sl.push(cs);
          }

          vertexCheckBf = iBST[vertexCheckBf]["parent"];
        }

        cs = createState(iBST);
        cs["status"] = 'Cây đã cân bằng.';
        cs["lineNo"] = 7;
        sl.push(cs);
      }
    }

    gw.startAnimation(sl, callback);
    if (isAVL) populatePseudocode(7);
    else       populatePseudocode(5);
    return true;
  };

  function init(initArr) {
    var i;

    clearScreen();

    for (i = 0; i < initArr.length; i++) {
      var parentVertex = iBST["root"];
      var newVertex = parseInt(initArr[i]);

      if (parentVertex == null) {
        iBST["root"] = parseInt(newVertex);
        iBST[newVertex] = {
          "parent": null,
          "leftChild": null,
          "rightChild": null,
          "vertexClassNumber": amountVertex
        };
      }
      else {
        while (true) {
          if (parentVertex < newVertex) {
            if (iBST[parentVertex]["rightChild"] == null) break;
            parentVertex = iBST[parentVertex]["rightChild"];
          }
          else {
            if (iBST[parentVertex]["leftChild"] == null) break;
            parentVertex = iBST[parentVertex]["leftChild"];
          }
        }

        if (parentVertex < newVertex)
          iBST[parentVertex]["rightChild"] = newVertex;
        else
          iBST[parentVertex]["leftChild"] = newVertex;

        iBST[newVertex] = {
          "parent": parentVertex,
          "leftChild": null,
          "rightChild": null,
          "vertexClassNumber": amountVertex
        }
      }

      amountVertex++;
    }

    recalculatePosition();

    for (key in iBST) {
      if (key == "root") continue;
      gw.addVertex(iBST[key]["cx"], iBST[key]["cy"], key, iBST[key]["vertexClassNumber"], true);
    }

    for (key in iBST) {
      if (key == "root") continue;
      if (key == iBST["root"]) continue;
      var parentVertex = iBST[key]["parent"];
      gw.addEdge(iBST[parentVertex]["vertexClassNumber"], iBST[key]["vertexClassNumber"], iBST[key]["vertexClassNumber"], EDGE_TYPE_UDE, 1, true);
    }
  }

  function clearScreen() {
    var key;

    for (key in iBST) {
      if (key == "root") continue;
      gw.removeEdge(iBST[key]["vertexClassNumber"]);
    }

    for (key in iBST) {
      if (key == "root") continue;
      gw.removeVertex(iBST[key]["vertexClassNumber"]);
    }

    iBST = {};
    iBST["root"] = null;
    amountVertex = 0;
  }

  // Pseudocode for rotateLeft:
  /*
   * BSTVertex rotateLeft(BSTVertex T) // pre-req: T.right != null
   * BSTVertex w = T.right
   * w.parent = T.parent
   * T.parent = w
   * T.right = w.left
   * if (w.left != null) w.left.parent = T
   * w.left = T
   * // Update the height of T and then w
   * return w
   */

  function rotateLeft(val) {
    // Refer to pseudocode

    var t = parseInt(val);
    var w = iBST[t]["rightChild"];

    iBST[w]["parent"] = iBST[t]["parent"];
    if (iBST[t]["parent"] != null) {
      if (iBST[t]["parent"] < t) {
        var tParent = iBST[t]["parent"];
        iBST[tParent]["rightChild"] = w;
      }
      else {
        var tParent = iBST[t]["parent"];
        iBST[tParent]["leftChild"] = w;
      }
    }

    iBST[t]["parent"] = w;
    iBST[t]["rightChild"] = iBST[w]["leftChild"];
    if (iBST[w]["leftChild"] != null)
      iBST[iBST[w]["leftChild"]]["parent"] = t;
    iBST[w]["leftChild"] = t;

    if (t == iBST["root"])
      iBST["root"] = w;

    recalculateBalanceFactor();
  }

  function rotateRight(val) {
    // Refer to pseudocode

    var t = parseInt(val);
    var w = iBST[t]["leftChild"];

    iBST[w]["parent"] = iBST[t]["parent"];
    if (iBST[t]["parent"] != null) {
      if (iBST[t]["parent"] < t) {
        var tParent = iBST[t]["parent"];
        iBST[tParent]["rightChild"] = w;
      }
      else {
        var tParent = iBST[t]["parent"];
        iBST[tParent]["leftChild"] = w;
      }
    }

    iBST[t]["parent"] = w;
    iBST[t]["leftChild"] = iBST[w]["rightChild"];
    if (iBST[w]["rightChild"] != null)
      iBST[iBST[w]["rightChild"]]["parent"] = t;
    iBST[w]["rightChild"] = t;

    if (t == iBST["root"])
      iBST["root"] = w;

    recalculateBalanceFactor();
  }

  /*
   * iBSTObject: a JS object with the same structure of iBST. This means the BST doen't have to be the BST stored in this class
   * vertexTraversed: JS object with the vertexes of the BST which are to be marked as traversed as the key
   * edgeTraversed: JS object with the edges of the BST which are to be marked as traversed as the key
   */

  function createState(iBSTObject, vertexTraversed, edgeTraversed) {
    if (vertexTraversed == null || vertexTraversed == undefined || !(vertexTraversed instanceof Object))
      vertexTraversed = {};
    if (edgeTraversed == null || edgeTraversed == undefined || !(edgeTraversed instanceof Object))
      edgeTraversed = {};

    var state = {
      "vl": {},
      "el": {}
    };

    var key;
    var vertexClass;

    // something may be inconsistent during remove (AVL?), generates mini D3 error..., hunt for that bug
    for (key in iBSTObject) {
      if (key == "root") continue;

      vertexClass = iBSTObject[key]["vertexClassNumber"]

      state["vl"][vertexClass] = {};
      state["vl"][vertexClass]["cx"] = iBSTObject[key]["cx"];
      state["vl"][vertexClass]["cy"] = iBSTObject[key]["cy"];
      state["vl"][vertexClass]["text"] = key;
      state["vl"][vertexClass]["state"] = VERTEX_DEFAULT;

      if (iBSTObject[key]["parent"] == null) continue;

      parentChildEdgeId = iBSTObject[key]["vertexClassNumber"];

      state["el"][parentChildEdgeId] = {};
      state["el"][parentChildEdgeId]["vertexA"] = iBSTObject[iBSTObject[key]["parent"]]["vertexClassNumber"];
      state["el"][parentChildEdgeId]["vertexB"] = iBSTObject[key]["vertexClassNumber"];
      state["el"][parentChildEdgeId]["type"] = EDGE_TYPE_UDE;
      state["el"][parentChildEdgeId]["weight"] = 1;
      state["el"][parentChildEdgeId]["state"] = EDGE_DEFAULT;
      state["el"][parentChildEdgeId]["animateHighlighted"] = false;
    }

    for (key in vertexTraversed) {
      vertexClass = iBSTObject[key]["vertexClassNumber"];
      state["vl"][vertexClass]["state"] = VERTEX_TRAVERSED;
    }

    for (key in edgeTraversed) {
      state["el"][key]["state"] = EDGE_TRAVERSED;
    }

    return state;
  }

  function recalculatePosition() {
    calcHeight(iBST["root"], 0);
    updatePosition(iBST["root"]);

    function calcHeight(cur, currentHeight) {
      if (cur == null) return;
      iBST[cur]["height"] = currentHeight;
      calcHeight(iBST[cur]["leftChild"], currentHeight+1);
      calcHeight(iBST[cur]["rightChild"], currentHeight+1);
    }

    function updatePosition(cur) {
      if (cur == null) return;

      if (cur == iBST["root"])
        iBST[cur]["cx"] = MAIN_SVG_WIDTH/2;
      else {
        var i;
        var xAxisOffset = MAIN_SVG_WIDTH/2-16;
        var parentVertex = iBST[cur]["parent"]
        for (i = 0; i < iBST[cur]["height"]; i++) xAxisOffset /= 2;

        if (parseInt(cur) > parseInt(parentVertex))
          iBST[cur]["cx"] = iBST[parentVertex]["cx"]+xAxisOffset;
        else
          iBST[cur]["cx"] = iBST[parentVertex]["cx"]-xAxisOffset;
      }

      iBST[cur]["cy"] = 50 + 50*iBST[cur]["height"];
      updatePosition(iBST[cur]["leftChild"]);
      updatePosition(iBST[cur]["rightChild"]);
    }
  }

  function recalculateBalanceFactor() {
    balanceFactorRecursion(iBST["root"]);

    function balanceFactorRecursion(val) {
      if (val == null) return -1;

      var balanceFactorHeightLeft = balanceFactorRecursion(iBST[val]["leftChild"]);
      var balanceFactorHeightRight = balanceFactorRecursion(iBST[val]["rightChild"]);

      iBST[val]["balanceFactorHeight"] = Math.max(balanceFactorHeightLeft, balanceFactorHeightRight) + 1;
      iBST[val]["balanceFactor"] = balanceFactorHeightLeft - balanceFactorHeightRight;

      return iBST[val]["balanceFactorHeight"];
    }
  }

  // 1: Max
  // 2: Min
  function populatePseudocode(act) {
    switch (act) {
      case 1: // findMinMax
      case 2:
        //$('#code1').html('if this is null return empty'); // code_minmax_1
        $('#code1').html('nếu <b>this</b> là <b>null, return</b> rỗng');
        if (act == 1) {
          //$('#code2').html('if right != null'); // code_max_2
          //$('#code3').html('&nbsp&nbspgo right'); // code_max_3
          $('#code2').html('nếu <b>right != null</b>');
          $('#code3').html('&nbsp;&nbsp;sang phải');
        }
        else {
          //$('#code2').html('if left != null');  // code_min_2
          //$('#code3').html('&nbsp;&nbsp;go left');  // code_min_3
          $('#code2').html('nếu <b>left != null</b>');
          $('#code3').html('&nbsp;&nbsp;sang trái');
        }
        //$('#code4').html('else return this key'); // code_minmax_4
        $('#code4').html('ngược lại, <b>return this key</b>');
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 4: // search
        //$('#code1').html('if this == null');  //code_search_1
        $('#code1').html('nếu <b>this == null</b>');
        //$('#code2').html('&nbsp;&nbsp;return null');  //code_search_2
        $('#code2').html('<b>&nbsp;&nbsp;return null</b>');
        //$('#code3').html('else if this key == search value'); //code_search_3
        $('#code3').html('ngược lại, nếu giá trị của đỉnh này == giá trị tìm kiếm');
        //$('#code4').html('&nbsp;&nbsp;return this');  //code_search_4
        $('#code4').html('<b>&nbsp;&nbsp;return this</b>');
        //$('#code5').html('else if this key < search value');  //code_search_5
        $('#code5').html('else if key của đỉnh này &lt; giá tìm cần tìm');
        //$('#code6').html('&nbsp;&nbsp;search right'); //code_search_6
        $('#code6').html('  tìm bên phải');
        //$('#code7').html('else search left'); //code_search_7
        $('#code7').html('else tìm bên trái');
        break;
      case 0: // Insert
        //$('#code1').html('if insertion point is found');  //code_insert_1
        $('#code1').html('if không tìm thấy vị trí chèn vào');
        //$('#code2').html('&nbsp;&nbsp;create new vertex');  //code_insert_2
        $('#code2').html('  tạo đỉnh mới');
        //$('#code3').html('if value to be inserted < this key'); //code_insert_3
        $('#code3').html('if giá trị chèn vào &lt; key của đỉnh này');
        //$('#code4').html('&nbsp;&nbsp;go left');  //code_insert_4
        $('#code4').html('  đi sang trái ');
        //$('#code5').html('else go right');  //code_insert_5
        $('#code5').html('else đi sang phải');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 5: // remove
        //$('#code1').html('search for v'); //code_remove_1
        $('#code1').html('tìm v');
        //$('#code2').html('if v is a leaf'); //code_remove_2
        $('#code2').html('if v là lá');
        //$('#code3').html('&nbsp;&nbsp;delete leaf v');  //code_remove_3
        $('#code3').html('  xóa lá v');
        //$('#code4').html('else if v has 1 child');  //code_remove_4
        $('#code4').html('else if v có 1 con');
        //$('#code5').html('&nbsp;&nbsp;bypass v'); //code_remove_5
        $('#code5').html('  bỏ qua v');
        //$('#code6').html('else replace v with successor');  //code_remove_6
        $('#code6').html('else thay thế v với số đứng sau');
        $('#code7').html('');
        break;
      case 6: // insert with rotations
      case 7: // remove with rotations
        if (act == 6) {
          //$('#code1').html('insert v'); //code_insert_avl_1
          $('#code1').html('chèn v');
        } else {
          //$('#code1').html('remove v'); //code_remove_avl_1
          $('#code1').html('xóa v');
        }
        //$('#code2').html('check balance factor of this and its children');  //code_avl_2
        $('#code2').html('Kiểm tra giá trị cân bằng của đỉnh này và các đỉnh con');
        //$('#code3').html('&nbsp;&nbsp;case1: this.rotateRight');  //code_avl_3
        $('#code3').html('  trường hợp 1: this.rotateRight');
        //$('#code4').html('&nbsp;&nbsp;case2: this.left.rotateLeft, this.rotateRight');  //code_avl_4
        $('#code4').html('  trường hợp 2: this.left.rotateLeft, this.rotateRight');
        //$('#code5').html('&nbsp;&nbsp;case3: this.rotateLeft'); //code_avl_5
        $('#code5').html('  trường hợp 3: this.rotateLeft');
        //$('#code6').html('&nbsp;&nbsp;case4: this.right.rotateRight, this.rotateLeft'); //code_avl_6
        $('#code6').html('  trường hợp 4: this.right.rotateRight, this.rotateLeft');
        //$('#code7').html('&nbsp;&nbsp;this is balanced'); //code_avl_7
        $('#code7').html('  đỉnh này đã cân bằng');
        break;
      case 8: // successor
      case 9: // predecessor
        if (act == 8) {
          //$('#code1').html('if this.right != null return findMin(this.right)'); //code_successor_1
          //$('#code4').html('&nbsp;&nbsp;while(p != null && T == p.right)'); //code_successor_4
          $('#code1').html('nếu <b>this.right != null</b>, <b>return findMin(this.right)</b>');
          $('#code4').html('<b>&nbsp;&nbsp;while(p != null &amp;&amp; T == p.right)</b>');
        }
        else {
          //$('#code1').html('if this.left != null return findMax(this.left)'); //code_predecessor_1
          //$('#code4').html('&nbsp;&nbsp;while(p != null && T == p.left)');  //code_predecessor_4
          $('#code1').html('nếu <b>this.left != null</b>, <b>return findMax(this.left)</b>');
          $('#code4').html('<b>&nbsp;&nbsp;while(p != null &amp;&amp; T == p.left)</b>');
        }
        //$('#code2').html('else'); //code_predsucc_2
        $('#code2').html('ngược lại');
        //$('#code3').html('&nbsp;&nbsp;p = this.parent, T = this');  //code_predsucc_3
        $('#code3').html('<b>&nbsp;&nbsp;p = this.parent, T = this</b>');
        //$('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;T = p, p = T.parent');  //code_predsucc_5
        $('#code5').html('<b>&nbsp;&nbsp;&nbsp;&nbsp;T = p, p = T.parent</b>');
        //$('#code6').html('&nbsp;&nbsp;if p is null return -1'); //code_predsucc_6
        $('#code6').html('&nbsp;&nbsp;nếu <b>p</b> là <b>null</b>, <b>return -1</b>');
        //$('#code7').html('&nbsp;&nbsp;else return p');  //code_predsucc_7
        $('#code7').html('&nbsp;&nbsp;ngược lại <b>return p</b>');
        break;
      case 3: // inorder traversal
        //$('#code1').html('if this is null');  //code_inorder_1
        $('#code1').html('nếu đỉnh này là null');
        //$('#code2').html('&nbsp;&nbsp;return'); //code_inorder_2
        $('#code2').html('&nbsp;&nbsp;<b>return</b>');
        //$('#code3').html('inOrder(left)');  //code_inorder_3
        $('#code3').html('inOrder(đỉnh trái)');
        //$('#code4').html('visit this, then inOrder(right)');  //code_inorder_4
        $('#code4').html('thăm đỉnh này, sau đó inOrder(phải).');
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
    }
  }
}



// BSTaction.js
var actionsWidth = 150;
var statusCodetraceWidth = 420;

var isCreateOpen = false, isSearchOpen = false, isInsertOpen = false, isRemoveOpen = false, isPredSuccOpen = false, isInorderOpen = false;

function openCreate() {
  if (!isCreateOpen) {
    $('.create').fadeIn('fast');
    isCreateOpen = true;
  }
}

function closeCreate() {
  if (isCreateOpen) {
    $('.create').fadeOut('fast');
    $('#create-err').html("");
    isCreateOpen = false;
  }
}

function openSearch() {
  if (!isSearchOpen) {
    $('.search').fadeIn('fast');
    isSearchOpen = true;
  }
}

function closeSearch() {
  if (isSearchOpen) {
    $('.search').fadeOut('fast');
    $('#search-err').html("");
    isSearchOpen = false;
  }
}

function openInsert() {
  if (!isInsertOpen) {
    $('.insert').fadeIn('fast');
    isInsertOpen = true;
  }
}

function closeInsert() {
  if (isInsertOpen) {
    $('.insert').fadeOut('fast');
    $('#insert-err').html("");
    isInsertOpen = false;
  }
}

function openRemove() {
  if (!isRemoveOpen) {
    $('.remove').fadeIn('fast');
    isRemoveOpen = true;
  }
}

function closeRemove() {
  if (isRemoveOpen) {
    $('.remove').fadeOut('fast');
    $('#remove-err').html("");
    isRemoveOpen = false;
  }
}

function openPredSucc() {
  if (!isPredSuccOpen) {
    $('.predsucc').fadeIn('fast');
    isPredSuccOpen = true;
  }
}

function closePredSucc() {
  if (isPredSuccOpen) {
    $('.predsucc').fadeOut('fast');
    $('#predsucc-err').html("");
    isPredSuccOpen = false;
  }
}

function openInorder() {
  if (!isInorderOpen) {
    $('.inorder').fadeIn('fast');
    isInorderOpen = true;
  }
}

function closeInorder() {
  if (isInorderOpen) {
    $('.inorder').fadeOut('fast');
    isInorderOpen = false;
  }
}

function hideEntireActionsPanel() {
  closeCreate();
  closeSearch();
  closeInsert();
  closeRemove();
  closePredSucc();
  closeInorder();
  hideActionsPanel();
}


// local
var bw, gw;

$(function() {
  $('#play').hide();
  bw = new BST();
  gw = bw.getGraphWidget();
  bw.generateRandom();

  var bstMode = getQueryVariable("mode");
  if (bstMode.length > 0)
    $('#title-' + bstMode).click();
  var createBST = getQueryVariable("create");
  if (createBST.length > 0) {
    var newBST = createBST.split(",");
    bw.generate(newBST);
  }

  $('#create').click(function() {
    openCreate();
    closeSearch();
    closeInsert();
    closeRemove();
    closePredSucc();
    closeInorder();
  });
  $('#search').click(function() {
    closeCreate();
    openSearch();
    closeInsert();
    closeRemove();
    closePredSucc();
    closeInorder();
  });
  $('#insert').click(function() {
    closeCreate();
    closeSearch();
    openInsert();
    closeRemove();
    closePredSucc();
    closeInorder();
  });
  $('#remove').click(function() {
    closeCreate();
    closeSearch();
    closeInsert();
    openRemove();
    closePredSucc();
    closeInorder();
  });
  $('#predsucc').click(function() {
    closeCreate();
    closeSearch();
    closeInsert();
    closeRemove();
    openPredSucc();
    closeInorder();
  });
  $('#inorder').click(function() {
    closeCreate();
    closeSearch();
    closeInsert();
    closeRemove();
    closePredSucc();
    openInorder();
  });
});

// title changing
$('#title-BST').click(function() {
  if (isPlaying) stop();
  showActionsPanel();
  hideStatusPanel();
  hideCodetracePanel();
  bw.isAVL(false);
});

$('#title-AVL').click(function() {
  if (isPlaying) stop();
  showActionsPanel();
  hideStatusPanel();
  hideCodetracePanel();
  bw.isAVL(true);
});

function empty() {
  if (isPlaying) stop();
  setTimeout(function() {
    if (bw.generateEmpty()) { // (mode == "exploration") && 
      $('#progress-bar').slider("option", "max", 0);
      closeCreate();
      isPlaying = false;
    }
  }, 500);
}

function example(id) {
  if (isPlaying) stop();
  setTimeout(function() {
    if (bw.generateExample(id)) { // (mode == "exploration") && 
      $('#progress-bar').slider("option", "max", 0);
      closeCreate();
      isPlaying = false;
    }
  }, 500);
}

function random() {
  if (isPlaying) stop();
  setTimeout(function() {
    if (bw.generateRandom()) { // (mode == "exploration") &&  
      $('#progress-bar').slider("option", "max", 0);
      closeCreate();
      isPlaying = false;
    }
  }, 500);
}

function skewed(side) {
  if (isPlaying) stop();
  setTimeout(function() {
    if (bw.generateSkewed(side)) { // (mode == "exploration") && 
      $('#progress-bar').slider("option", "max", 0);
      closeCreate();
      isPlaying = false;
    }
  }, 500);
}

function findMinMax(isMin, callback) {
  if (isPlaying) stop();
  commonAction(bw.findMinMax(isMin, callback), (isMin ? "Tìm Giá Trị Nhỏ Nhất" : "Tìm Giá Trị Lớn Nhất"));
}

function searchVertex(callback) {
  if (isPlaying) stop();
  var input = $('#v-search').val();
  commonAction(bw.search(input, callback), "Tìm kiếm " + input);
  setTimeout(function() {
    if (Math.random() >= 0.5) $("#v-search").val(bw.getRandomInBST()); // 50% an existing value
    else                      $("#v-search").val(bw.getRandomNotInBST()); // 50% a NON existing value
  }, 500);
}

function insertVertex(callback) {
  if (isPlaying) stop();
  var input = $('#v-insert').val();
  commonAction(bw.insertArr(input.split(","), callback), "Chèn " + input);
  setTimeout(function() { $("#v-insert").val(bw.getRandomNotInBST()); }, 500); // randomized for next click, a NON existing value in BST
}

function removeVertex(callback) {
  if (isPlaying) stop();
  var input = $('#v-remove').val();
  commonAction(bw.removeArr(input.split(","), callback), "Di chuyển " + input);
  setTimeout(function() { $("#v-remove").val(bw.getRandomInBST()); }, 500); // randomized for next click, an existing value in BST
}

function predsucc(isPred, callback) {
  if (isPlaying) stop();
  var input = $('#v-predsucc').val();
  commonAction(bw.findPredSucc(input.split(","), isPred, callback), (isPred ? "Số đứng trước(" : "Số đứng sau(") + input + ")");
  setTimeout(function() { $("#v-predsucc").val(bw.getRandomInBST()); }, 500);
}

function inorderTraversal(callback) {
  // if (mode != "exploration") return;
  if (isPlaying) stop();
  commonAction(bw.inorderTraversal(callback), "Duyệt trung thứ tự");
}

// Implement these functions in each visualisation
var userGraph = {
  'vl': {},
  'el': {},
};

// This function will be called before entering E-Lecture Mode
function ENTER_LECTURE_MODE() {
  //if (bw) userGraph = bw.getGraph();
}

// This function will be called before returning to Explore Mode
function ENTER_EXPLORE_MODE() {
  //loadGraph(userGraph);
}

// Lecture action functions
function CUSTOM_ACTION(action, data, mode) {
  if (action == 'search') {
    hideSlide(function() {
      $('#v-search').val(data); // force
      searchVertex(showSlide);
    });
  }
  else if (action == 'findmin') {
    hideSlide(function() {
      findMinMax(true, showSlide);
    });
  }
  else if (action == 'findmax') {
    hideSlide(function() {
      findMinMax(false, showSlide);
    });
  }
  else if (action == 'successor') {
    hideSlide(function() {
      $('#v-predsucc').val(data); // force
      predsucc(false, showSlide);
    });
  }
  else if (action == 'successor_max') {
    hideSlide(function() {
      $('#v-predsucc').val(bw.findMax()); // force the max
      predsucc(false, showSlide);
    });
  }
  else if (action == 'predecessor') {
    hideSlide(function() {
      $('#v-predsucc').val(data); // force
      predsucc(true, showSlide);
    });
  }
  else if (action == 'inorder') {
    hideSlide(function() {
      inorderTraversal(showSlide);
    });
  }
  else if (action == 'insert') {
    hideSlide(function() {
      $('#v-insert').val(data); // force
      insertVertex(showSlide);
    });
  }
  else if (action == 'insert_max_plus_1') {
    hideSlide(function() {
      $('#v-insert').val(bw.findMax()+1); // force the max plus 1
      insertVertex(showSlide);
    });
  }
  else if (action == 'remove') {
    hideSlide(function() {
      $('#v-remove').val(data); // force
      removeVertex(showSlide);
    });
  }
  else if (action == 'remove_max') {
    hideSlide(function() {
      $('#v-remove').val(bw.findMax()); // force the max
      removeVertex(showSlide);
    });
  }
}
</script>
</body>

<!-- Mirrored from visualgo.net/vi/bst?slide=3-5 by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 26 Nov 2020 06:40:30 GMT -->
</html>
