<!DOCTYPE html>
<html lang="vi">

<!-- Mirrored from visualgo.net/vi/list?slide=3-7 by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 26 Nov 2020 06:40:23 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="description" content="Linked List is a data structure consisting of a group of vertices (nodes) which together represent a sequence. Under the simplest form, each vertex is composed of a data and a reference (link) to the next vertex in the sequence. Try clicking Search(77) for a sample animation on searching a value in a (Singly) Linked List.Linked List and its variations are used as underlying data structure to implement List, Stack, Queue, and Deque ADTs (read this Wikipedia article about ADT if you are not familiar with that term).In this visualization, we discuss (Singly) Linked List (LL) — with a single next pointer — and its two variants: Stack and Queue, and also Doubly Linked List (DLL) — with both next and previous pointers — and its variant: Deque.Click &#39;Next&#39; (on the top right)/press &#39;Page Down&#39; to advance this e-Lecture slide, use the drop down list/press &#39;Space&#39; to jump to a specific slide, or Click &#39;X&#39; (on the bottom right)/press &#39;Esc&#39; to go to Exploration mode.">
<meta name="keywords" content="Singly Doubly Double Linked List Stack Queue Deque">
 
<meta name="csrf-token" content="iVivZ7KRPe6XK7pbuGtOoEjljE1xyBVNhLKNFuF8">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/list.png">
<title>VisuAlgo - Danh sách liên kết (Đơn, Đôi), Ngăn xếp, Hàng đợi, Hàng đợi hai đầu</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common.css">
<link rel="stylesheet" href="../css/viz-1.0.1.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
      }
      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }
      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
    </style>
<style>
.execAction { padding: 5px 8px; }
.err { padding: 5px 0px; }
#actions-extras input {
  width: 35px;
  padding: 5px 8px 7px;
}

.create { bottom: 146px; }
.search { bottom: 119px; }
.insert { bottom: 92px; }
.remove { bottom: 65px; }

#createfixedsize-input input, #createuserdefined-input input { float:left; }
#createfixedsize-go p, #createuserdefined-go p { float:right; }
#createuserdefined-input input { width: 80px; }

#inserthead-input input, #inserttail-input input, #insertkth-input input { float: left; }
#insertkth-input input { margin-right: 3px; }
#inserthead-go p, #inserttail-go p, #insertkth-go p { float: right; }

#removekth-input input {  float: left; }
#removekth-go p { float: right; }
</style>
<script>
      function changeURL() {
        var URL = window.location.href.split('https://visualgo.net/');
        var val = document.getElementById("Language").value;
        URL[3] = val;
        window.location.assign(URL.join('https://visualgo.net/'));
      }
    </script>
</head>
<body>
<div id="top-bar">
<a href="http://www.comp.nus.edu.sg/~stevenha"><span class="colour" style="border: 1px solid green; border-radius: 25px;">7</span></a>&nbsp;&nbsp;&nbsp;
<a id="home" href="https://visualgo.net/">Visu<span class="colour">Algo</span><span style="font-size: 40%">.net</span></a>
/
<select id="Language" onchange="changeURL()">
<option value="en">en</option>
<option value="zh">zh</option>
<option value="es">es</option>
<option value="pt">pt</option>
<option value="ru">ru</option>
<option value="id">id</option>
<option value="de">de</option>
<option value="bn">bn</option>
<option value="ja">ja</option>
<option value="ko">ko</option>
<option value="vi" selected>vi</option>
</select>
/list
<span class="right-links" id="useraccount">Login</span>
<span id="title">
<a id='title-LL' class='selected-viz'>LL</a>
<a id='title-Stack'>Ngăn xếp</a>
<a id='title-Queue'>Hàng đợi</a>
<a id='title-DLL'>DLL</a>
<a id='title-Deque'>Hàng đợi hai đầu</a>
</span>
<div id="mode-menu">
<div id='mode-button' title='exploration'>Chế độ thăm dò &#9663;</div>
<div id='other-modes'>
<a title='e-Lecture'>Chế độ Bài giảng trực tuyến</a>
</div>
</div>
</div>
<div id="dark-overlay"></div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id='speed-control'>Chậm<div id='speed-input'></div>Nhanh<br></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick=goToBeginning()><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick=stepBackward()><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick=pause()><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick=play()><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick=stepForward()><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick=goToEnd()><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id='viz'></div>
<div id='current-action' class='panel'></div>
<div id='e-lecture' class='panel'></div>
<div id="overlay" hidden></div>
<div id="dropdown-temp-holder" hidden></div>
<div id="electure-1" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Linked List is a data structure consisting of a group of vertices (nodes) which together represent a sequence. Under the simplest form, each vertex is composed of a data and a reference (link) to the next vertex in the sequence. Try clicking <span class="slide-actions" onclick="doButtonAction96()">Search(77)</span> for a sample animation on searching a value in a (Singly) Linked List.</p><br><p>Linked List and its variations are used as underlying data structure to implement List, Stack, Queue, and Deque ADTs (read this <a href="https://en.wikipedia.org/wiki/Abstract_data_type" target="_blank"><u>Wikipedia article about ADT</u></a> if you are not familiar with that term).</p><br><p>In this visualization, we discuss (Singly) Linked List (LL) — with a single next pointer — and its two variants: Stack and Queue, and also Doubly Linked List (DLL) — with both next and previous pointers — and its variant: Deque.</p><br><p>Click &#39;Next&#39; (on the top right)/press &#39;Page Down&#39; to advance this e-Lecture slide, use the drop down list/press &#39;Space&#39; to jump to a specific slide, or Click &#39;X&#39; (on the bottom right)/press &#39;Esc&#39; to go to Exploration mode.</p>
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
Please <a href="https://visualgo.net/login"><u>login</u></a> if you are a repeated visitor or <a href="https://visualgo.net/login"><u>register</u></a> for an (optional) free account first.</p>
<div id='electure-dropdown'>
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. LL, Stack, Queue, DLL, Deque</option>
<option value="1-1">&nbsp;&nbsp;&nbsp;1-1. Five Modes</option>
<option value="2">2. Motivation</option>
<option value="2-1">&nbsp;&nbsp;&nbsp;2-1. List ADT</option>
<option value="2-2">&nbsp;&nbsp;&nbsp;2-2. The Answer</option>
<option value="2-3">&nbsp;&nbsp;&nbsp;2-3. Array Implementation - Part 1</option>
<option value="2-4">&nbsp;&nbsp;&nbsp;2-4. Array Implementation - Part 2</option>
<option value="2-5">&nbsp;&nbsp;&nbsp;2-5. Time Complexity Summary</option>
<option value="2-6">&nbsp;&nbsp;&nbsp;2-6. Fixed Space Issue</option>
<option value="2-7">&nbsp;&nbsp;&nbsp;2-7. Variable Space</option>
<option value="2-8">&nbsp;&nbsp;&nbsp;2-8. Observations</option>
<option value="3">3. Linked List (LL)</option>
<option value="3-1">&nbsp;&nbsp;&nbsp;3-1. Linked List Vertex C++ Implementation</option>
<option value="3-2">&nbsp;&nbsp;&nbsp;3-2. The Answer</option>
<option value="3-3">&nbsp;&nbsp;&nbsp;3-3. Linked List, Additional Data</option>
<option value="3-4">&nbsp;&nbsp;&nbsp;3-4. Variations</option>
<option value="3-5">&nbsp;&nbsp;&nbsp;3-5. Get(i) - Much Slower than Array</option>
<option value="3-6">&nbsp;&nbsp;&nbsp;3-6. Search(v) - Not Better than Array</option>
<option value="3-7">&nbsp;&nbsp;&nbsp;3-7. Insertion - Four Cases</option>
<option value="3-8">&nbsp;&nbsp;&nbsp;3-8. Insert(i, v) - Insert at Head (i = 0)</option>
<option value="3-9">&nbsp;&nbsp;&nbsp;3-9. The Answer</option>
<option value="3-10">&nbsp;&nbsp;&nbsp;3-10. Insert(i, v) - Insert into an Empty List</option>
<option value="3-11">&nbsp;&nbsp;&nbsp;3-11. Insert(i, v) - In Between, i &in; [1..N-1]</option>
<option value="3-12">&nbsp;&nbsp;&nbsp;3-12. Insert(i, v) - Beyond the Tail, i = N</option>
<option value="3-13">&nbsp;&nbsp;&nbsp;3-13. The Answer</option>
<option value="3-14">&nbsp;&nbsp;&nbsp;3-14. Removal - Three Cases</option>
<option value="3-15">&nbsp;&nbsp;&nbsp;3-15. Remove(i) - At Head (i = 0)</option>
<option value="3-16">&nbsp;&nbsp;&nbsp;3-16. The Answer</option>
<option value="3-17">&nbsp;&nbsp;&nbsp;3-17. Remove(i) - In Between, i &in; [1..N-2]</option>
<option value="3-18">&nbsp;&nbsp;&nbsp;3-18. Remove(i) - At Tail (i = N-1) - Part 1</option>
<option value="3-19">&nbsp;&nbsp;&nbsp;3-19. Remove(i) - At Tail (i = N-1) - Part 2</option>
<option value="3-20">&nbsp;&nbsp;&nbsp;3-20. The Answer</option>
<option value="3-21">&nbsp;&nbsp;&nbsp;3-21. Time Complexity Summary</option>
<option value="3-22">&nbsp;&nbsp;&nbsp;3-22. Linked List Applications</option>
<option value="4">4. Stack</option>
<option value="4-1">&nbsp;&nbsp;&nbsp;4-1. The Design Choice</option>
<option value="4-2">&nbsp;&nbsp;&nbsp;4-2. The Answer</option>
<option value="4-3">&nbsp;&nbsp;&nbsp;4-3. Stack Applications</option>
<option value="4-4">&nbsp;&nbsp;&nbsp;4-4. Bracket Matching Problem</option>
<option value="4-5">&nbsp;&nbsp;&nbsp;4-5. O(N) Solution with Stack</option>
<option value="4-6">&nbsp;&nbsp;&nbsp;4-6. Calculating Postfix Expression</option>
<option value="4-7">&nbsp;&nbsp;&nbsp;4-7. O(N) Solution with Stack</option>
<option value="5">5. Queue</option>
<option value="5-1">&nbsp;&nbsp;&nbsp;5-1. Array Implementation Issues - Part 1</option>
<option value="5-2">&nbsp;&nbsp;&nbsp;5-2. Array Implementation Issues - Part 2</option>
<option value="5-3">&nbsp;&nbsp;&nbsp;5-3. Array Implementation Issues - Part 3</option>
<option value="5-4">&nbsp;&nbsp;&nbsp;5-4. Array Implementation Issues - Part 4</option>
<option value="5-5">&nbsp;&nbsp;&nbsp;5-5. Linked List to the Rescue</option>
<option value="5-6">&nbsp;&nbsp;&nbsp;5-6. Queue Application</option>
<option value="6">6. Doubly Linked List (DLL)</option>
<option value="6-1">&nbsp;&nbsp;&nbsp;6-1. Remove(i) - At Tail (i = N-1), Revisited</option>
<option value="6-2">&nbsp;&nbsp;&nbsp;6-2. Constant Factor Extra Step(s) Elsewhere</option>
<option value="7">7. Double-Ended Queue (Deque)</option>
<option value="7-1">&nbsp;&nbsp;&nbsp;7-1. Deque Applications</option>
<option value="8">8. Summary</option>
<option value="9">9. Extras</option>
<option value="9-1">&nbsp;&nbsp;&nbsp;9-1. Potential Discussion Topics</option>
<option value="9-2">&nbsp;&nbsp;&nbsp;9-2. Our Current Answers</option>
<option value="9-3">&nbsp;&nbsp;&nbsp;9-3. C++ STL and Java API Implementations</option>
<option value="9-4">&nbsp;&nbsp;&nbsp;9-4. Python and OCaml Standard Library</option>
<option value="9-5">&nbsp;&nbsp;&nbsp;9-5. Online Quiz</option>
<option value="9-6">&nbsp;&nbsp;&nbsp;9-6. Online Judge Exercises</option>
<option value="99">99. Status Panel</option>
<option value="99-1">&nbsp;&nbsp;&nbsp;99-1. Codetrace Panel</option>
<option value="99-2">&nbsp;&nbsp;&nbsp;99-2. Media Control</option>
<option value="99-3">&nbsp;&nbsp;&nbsp;99-3. Return to &#39;Exploration Mode&#39;</option>
</select>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-next' data-nextid="1-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-1-1" class="electure-dialog" style="top:60px;left:200px;width:500px;">
<p>We decide to group five related modes involving Linked List (LL, Stack, Queue, DLL, Deque) in one single visualization page. To facilitate more diversity, we randomize the selected mode upon loading this direct URL: https://visualgo.net/en/list.</p><br><p>However, you can use the following URL shortcuts to access individual mode directly:</p><ol><li><a href="https://visualgo.net/en/ll"><u>https://visualgo.net/en/ll</u></a>,</li><li><a href="https://visualgo.net/en/stack"><u>https://visualgo.net/en/stack</u></a>,</li><li><a href="https://visualgo.net/en/queue"><u>https://visualgo.net/en/queue</u></a>,</li><li><a href="https://visualgo.net/en/dll"><u>https://visualgo.net/en/dll</u></a>,</li><li><a href="https://visualgo.net/en/deque"><u>https://visualgo.net/en/deque</u></a>.</li></ol>
<hr>
<p>Pro-tip: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b> to advance to the next slide, <b>[PageUp]</b> to go back to the previous slide, <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Linked List data structure is commonly taught in Computer Science (CS) undergraduate courses for a few reasons:</p><ol><li>It is a simple linear data structure,</li><li>It has a range of potential applications as a list ADT e.g. student list, event list, appointment list, etc (albeit there are other more advanced data structures that can do the same (and more) applications better) or as stack/queue/deque ADTs,</li><li>It has interesting corner/special cases to illustrate the need for a good implementation of a data structure,</li><li>It has various customization options and thus usually this Linked List data structure is taught using Object-Oriented Programming (OOP) way.</li></ol>
<hr>
<p>Another pro-tip: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2017). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="1-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>List is a sequence of items/data where positional order matter {a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>N-2</sub>, a<sub>N-1</sub>}.<br>Common List ADT operations are:</p><ol start="0"><li><samp>get(i)</samp> — maybe a trivial operation, return <samp>a<sub>i</sub></samp> (0-based indexing),</li><li><samp>search(v)</samp> — decide if item/data <b>v</b> exists (and report its position/index)<br>or not exist (and usually report a non existing index -1) in the list,</li><li><samp>insert(i, v)</samp> — insert item/data <b>v</b> specifically at position/index <b>i</b> in the list, potentially shifting the items from previous positions: [<b>i</b>..<b>N</b>-1] by one position to their right to make a space,</li><li><samp>remove(i)</samp> — remove item that is specifically at position/index <b>i</b> in the list, potentially shifting the items from previous positions: [<b>i+1</b>..<b>N</b>-1] by one position to their left to close the gap.</li></ol><p>Discussion: What if we want to remove item with specific value <b>v</b> in the list?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>(Compact) Array is a good candidate for implementing the List ADT as it is a simple construct to handle a collection of items.</p><br><p>When we say compact array, we mean an array that has <b>no gap</b>, i.e. if there are <b>N</b> items in the array (that has size <b>M</b>, where <b>M &ge; N</b>), then only index [0..<b>N</b>-1] are occupied and other indices [<b>N</b>..<b>M</b>-1] should remain <b>empty</b>.</p><br><img src="../img/compactarray_illustration.png" width="100%" alt="Compact Array Illustration">
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2-4" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Let the <b>compact</b> array name be <samp>A</samp> with index [0..<b>N</b>-1] occupied with the items of the list.</p><br><p><samp>get(i)</samp>, just return <samp>A[i]</samp>.<br>This simple operation will be unnecessarily complicated if the array is <b>not</b> compact.</p><br><p><samp>search(v)</samp>, we check each index <samp>i</samp> ∈ [0..<b>N</b>-1] one by one to see if <samp>A[i] == v</samp>.<br>This is because <samp>v</samp> (if it exists) can be anywhere in index [0..<b>N</b>-1].</p><br><p><samp>insert(i, v)</samp>, we shift items ∈ [<b>i</b>..<b>N</b>-1] to [<b>i</b>+1..<b>N</b>] (<i>from backwards</i>) and set <samp>A[i] = v</samp>.<br>This is so that <samp>v</samp> is inserted correctly at index <samp>i</samp> and maintain compactness.</p><br><p><samp>remove(i)</samp>, we shift items ∈ [<b>i+1</b>..<b>N</b>-1] to [<b>i</b>..<b>N</b>-2], overwriting the old <samp>A[i]</samp>.<br>This is to maintain compactness.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2-5" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p><samp>get(i)</samp> is very fast: Just one access, O(<b>1</b>).<br>Another CS module: &#39;Computer Organisation&#39; discusses the details on this O(<b>1</b>)<br>performance of this array indexing operation.</p><br><p><samp>search(v)</samp><br>In the best case, <b>v</b> is found at the first position, O(<b>1</b>).<br>In the worst case, <b>v</b> is not found in the list and we require O(<b>N</b>) scan to determine that.</p><br><p><samp>insert(i, v)</samp><br>In the best case, insert at <b>i = N</b>, there is no shifting of element, O(<b>1</b>).<br>In the worst case, insert at <b>i = 0</b>, we shift all <b>N</b> elements, O(<b>N</b>).</p><br><p><samp>remove(i)</samp><br>In the best case, remove at <b>i = N-1</b>, there is no shifting of element, O(<b>1</b>).<br>In the worst case, remove at <b>i = 0</b>, we shift all <b>N</b> elements, O(<b>N</b>).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-6">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2-6" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>The size of the compact array <b>M</b> is not infinite, but a finite number. This poses a problem as the maximum size may not be known in advance in many applications.</p><br><p>If <b>M</b> is too big, then the unused spaces are wasted.<br>If <b>M</b> is too small, then we will run out of space easily.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-7">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2-7" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Solution: Make <b>M</b> a variable. So when the array is full, we create a larger array (usually two times larger) and move the elements from the old array to the new array. Thus, there is no more limits on size other than the (usually large) physical computer memory size.</p><br><p><a href="http://en.cppreference.com/w/cpp/container/vector" target="_blank"><u>C++ STL std::vector</u></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html" target="_blank"><u>Java Vector</u></a>, or <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html" target="_blank"><u>Java ArrayList</u></a> all implement this variable-size array.</p> <br><p>However, the classic array-based issues of space wastage and copying/shifting items overhead are still problematic.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-6">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="2-8">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2-8" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>For fixed-size collections with known max limit of number of items that will ever be needed, i.e. the max size of <b>M</b>, then array is already a reasonably good data structure for List ADT implementation.</p><br><p>For variable-size collections with unknown size <b>M</b> and where dynamic operations such as insert/remove are common, a simple array is actually a poor choice of data structure.</p><br><p>For such applications, there are better data structures. Let&#39;s read on...</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-7">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>We now introduce the Linked List data structure. It uses pointers to allow items/data to be <b>non-contiguous</b> in memory (that is the main difference with a <a href="listec4c.html?slide=2-2"><u>simple array</u></a>). The items are ordered from index 0 to index <b>N</b>-1 by associating item <b>i</b> with its neighbour item <b>i+1</b> through a pointer.</p><br><img src="../img/ll_illustration.png" width="100%" alt="Linked List Illustration">
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2-8">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-1" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>In its basic form, a single vertex (node) in the Linked List has this rough structure:</p><pre>struct Vertex { // we can use either C struct or C++/Java class<br>  int item; // the data is stored here, an integer in this example<br>  Vertex* next; // this pointer tells us where is the next vertex<br>};</pre><p>Using the default example Linked List [22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)] for illustration, we have:<br><b>a<sub>0</sub></b> with its <b>item</b> = 22 and its <b>next</b> = <b>a<sub>1</sub></b>,<br><b>a<sub>1</sub></b> with its <b>item</b> = 2 and its <b>next</b> = <b>a<sub>2</sub></b>,<br>...<br><b>a<sub>6</sub></b> with its <b>item</b> = 89 and its <b>next</b> = <b>null</b>.</p><br><p>Discussion: Which one is better for a C++ implementation of Linked List? struct or class? How about Java implementation?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-2" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-3" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>We also have a few additional data that we remember in this Linked List data structure. We use the default example Linked List [22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)] for illustration.</p><ol><li>The <b>head</b> pointer points to <b>a<sub>0</sub></b> — it is 22, nothing points to the head item,</li><li>The <b>tail</b> pointer points to <b>a<sub>N-1</sub></b> — it is <b>a<sub>6</sub></b> = 89, nothing is after the tail item.</li></ol><p>That&#39;s it, we only add two more extra variables in data structure.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-4" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Note that there are various subtle differences found in many Computer Science textbooks on how to implement a (Singly) Linked List e.g. (use tail pointer or not, circular or not, use dummy head item or not) &mdash; see <a href="listf3ec.html?slide=9-1"><u>this slide</u></a>.</p><br><p>Our version in this visualization (with tail pointer, not circular, without dummy head) may not be 100% the same compared to what you learn in your class but the basic ideas should remain the same.</p><br><p>In this visualization, each vertex has Integer item, but this can easily be changed to any other data type as needed.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-5" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Since we only keep the head and tail pointers, list traversal subroutine is needed to reach positions other than the head (index 0) and the tail (index <b>N</b>-1).</p><br><p>As this sub-routine is so frequently used, we will abstract it out as a function. The code below is written in C++.</p><pre>Vertex* Get(int i) { // returns the vertex<br>  Vertex* ptr = head; // we have to start from head<br>  for (int k = 0; k &lt; i; k++) // advance forward i time(s)<br>    ptr = ptr-&gt;next; // the pointers are pointing to the higher index<br>  return ptr;<br>}</pre><p>It runs in O(<b>N</b>) as <b>i</b> can be as big as index <b>N</b>-2.<br>Compare this with <a href="listad01.html?slide=2-4"><u>array</u></a> where we can access index <b>i</b> in O(<b>1</b>) time.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-6">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-6" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>As we only have direct reference to the first head item and the last tail item, plus the pointers are pointing to the <b>right</b> (higher position/index), we can only access the rest by starting from the head item and hopping through the next pointers. On the default [22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)], we have:</p><p><br></p><p><span class="slide-actions" onclick="doButtonAction96()">Search(77)</span> — found in the example above at position/index 2 (0-based indexing).</p><br><p><span class="slide-actions" onclick="doButtonAction97()">Search(7)</span> — not found in the example above, and this is only known after all <b>N</b> items are examined, so <samp>Search(v)</samp> has O(<b>N</b>) worst case time complexity.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-7">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-7" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>There are more cases than <a href="listad01.html?slide=2-4"><u>array</u></a> version due to the nature of Linked List.</p><br><p>Most CS students who learn Linked List for the first time usually are not aware of all cases until they figure it out themselves when their Linked List code fail.</p><br><p>In this e-Lecture, we directly elaborate all cases.</p><br><p>For <samp>insert(i, v)</samp>, there are four (legal) possibilities, i.e. item <b>v</b> is added to:</p><ol><li>The head (before the current first item) of the linked list, <b>i = 0</b>,</li><li>An empty linked list (which fortunately similar to the previous case),</li><li>The position beyond the last (the current tail) item of the linked list, <b>i = N</b>,</li><li>The other positions of the linked list, <b>i = [1..N-1]</b>.</li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-6">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-8">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-8" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>The (C++) code for insertion at head is simple and efficient, in O(<b>1</b>):</p><pre>Vertex* vtx = new Vertex(); // create new vertex vtx from item v<br>vtx-&gt;item = v;<br>vtx-&gt;next = head; // link this new vertex to the (old) head vertex<br>head = vtx; // the new vertex becomes the new head</pre><p>Try <span class="slide-actions" onclick="doButtonAction100()">InsertHead(50)</span>, which is <samp>insert(0, 50)</samp>, on the example Linked List&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)].</p><br><p>Discussion: What happen if we use <a href="listd82e.html?slide=2-5"><u>array</u></a> implementation for insertion at head of the list?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-7">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-9">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-9" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-8">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-10">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-10" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Empty data structure is a common corner/special case that can often cause unexpected crash if not properly tested. It is legal to insert a new item into a currently empty list, i.e. at index <b>i = 0</b>. Fortunately, the same pseudo-code for insertion at head also works for an empty list so we can just use the same code as in <a href="list1a24.html?slide=3-8"><u>this slide</u></a>&nbsp;(with one minor change, we also need to set tail = head).</p><br><p>Try <span class="slide-actions" onclick="doButtonAction103()">InsertHead(50)</span>, which is <samp>insert(0, 50)</samp>, but on the empty Linked List [].</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-9">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-11">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-11" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>With the Linked List traversal <samp>Get(i)</samp> sub-routine, we can now implement insertion in the middle of the Linked List as follows (in C++):</p><pre>Vertex* pre = Get(i-1); // traverse to (i-1)-th vertex, O(N)<br>aft = pre-&gt;next; // aft cannot be null, think about it<br>Vertex* vtx = new Vertex(); // create new vertex<br>vtx-&gt;item = v;<br>vtx-&gt;next = aft; // link this<br>pre-&gt;next = vtx; // and this</pre><p>Try <span class="slide-actions" onclick="doButtonAction102()">Insert(3, 44)</span> on the example Linked List&nbsp;&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)].</p><br><p>Also try <span class="slide-actions" onclick="doButtonAction104()">Insert(6, 55)</span> on the same example Linked List. This is a corner case: Insert at the position of tail item, shifting the tail to one position to its right.</p><br><p>This operation is slow, O(<b>N</b>), due to the need for traversing the list (e.g. if <b>i</b> close to <b>N</b>-1).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-10">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-12">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-12" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>If we also remember the tail pointer as with the implementation <a href="liste0b3.html?slide=3-3"><u>in this e-Lecture</u></a> (which is advisable as it is just one additional pointer variable), we can perform insertion beyond the tail item (at <b>i = N</b>) efficiently, in O(<b>1</b>):</p><pre>Vertex* vtx = new Vertex(); // this is also a C++ code<br>vtx-&gt;item = v; // create new vertex vtx from item v<br>tail-&gt;next = vtx; // just link this, as tail is the i = (N-1)-th item<br>tail = vtx; // now update the tail pointer</pre><p>Try <span class="slide-actions" onclick="doButtonAction101()">InsertTail(10)</span>, which is <samp>insert(7, 10)</samp>, on the example Linked List&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)]&nbsp;. A common misconception is to say that this is insertion at tail. Insertion at tail element is <samp>insert(N-1, v)</samp>. This insertion <b>beyond</b> the tail is <samp>insert(N, v)</samp>.</p><br><p>Discussion: What happen if we use <a href="listd82e.html?slide=2-5"><u>array</u></a> implementation for insertion beyond the tail of the list?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-11">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-13">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-13" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-12">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-14">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-14" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>For <samp>remove(i)</samp>, there are three (legal) possibilities, i.e. index <b>i</b> is:</p><ol><li>The head (the current first item) of the linked list, <b>i = 0</b>, it affects the head pointer</li><li>The tail of the linked list, <b>i = N-1</b>, it affects the tail pointer</li><li>The other positions of the linked list, <b>i = [1..N-2]</b>.</li></ol><p>Discussion: Compare this slide with <a href="list7ebc.html?slide=3-7"><u>Insertion Cases slide</u></a> to realize the subtle differences. Is removing anything from an already empty Linked List considered &#39;legal&#39;?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-13">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-15">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-15" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>This case is straightforward (written in C++):</p><pre>if (head == NULL) return; // avoid crashing when SLL is empty<br>Vertex* temp = head; // so we can delete it later<br>head = head-&gt;next; // book keeping, update the head pointer<br>delete temp; // which is the old head</pre><p>Try <span class="slide-actions" onclick="doButtonAction105()">RemoveHead()</span> repeatedly on the (shorter) example Linked List&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6 (tail)]. It will continuously working correctly up until the Linked List contains one item where the head = the tail item. We prevent execution if the LL is already empty as it is an illegal case.</p><br><p>Discussion: What happen if we use <a href="listd82e.html?slide=2-5"><u>array</u></a> implementation for removal of head of the list?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-14">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-16">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-16" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-15">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-17">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-17" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>With the Linked List traversal <samp>Get(i)</samp> sub-routine (<a href="liste090.html?slide=3-5"><u>discussed earlier</u></a>), we can now implement removal of the middle item of the Linked List as follows (in C++):</p><pre>Vertex* pre = Get(i-1); // traverse to (i-1)-th vertex, O(N)<br>Vertex* del = pre-&gt;next, aft = del-&gt;next;<br>pre-&gt;next = aft; // bypass del<br>delete del;</pre><p>Try <span class="slide-actions" onclick="doButtonAction107()">Remove(5)</span>, the element at index <b>N-2</b> (as <b>N = 7</b> in the example&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6-&gt;43-&gt;76-&gt;89 (tail)]&nbsp;.<br>This is the worst O(<b>N</b>) case on the example above.</p><br><p>Note that <b>Remove(N-1)</b> is removal at tail that requires us to update the tail pointer, see the next case.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-16">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-18">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-18" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>We can implement the removal of the tail of the Linked List as follows, assuming that the Linked List has more than 1 item (in C++):</p><pre>Vertex* pre = head;<br>temp = head-&gt;next;<br>while (temp-&gt;next != null) // while my neighbor is not the tail<br>  pre = pre-&gt;next, temp = temp-&gt;next;<br>pre-&gt;next = null; // alternatively: pre = Get(N-2), temp = Get(N-1)<br>delete temp; // temp = (old) tail<br>tail = pre; // update tail pointer</pre><p>Try <span class="slide-actions" onclick="doButtonAction106()">RemoveTail()</span> repeatedly on the (shorter) example Linked List&nbsp;[22 (head)-&gt;2-&gt;77-&gt;6 (tail)]. It will continuously working correctly up until the Linked List contains one item where the head = the tail item and we switch to <a href="list05ba.html?slide=3-15"><u>removal at head</u></a> case. We prevent execution if the LL is already empty as it is an illegal case.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-17">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-19">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-19" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Actually, if we also maintain the size of the Linked List <b>N</b> (compare with <a href="liste0b3.html?slide=3-3"><u>this slide</u></a>), we can use the Linked List traversal sub-routine <samp>Get(i)</samp> to implement the removal of the tail of the Linked List this way (in C++):</p><pre>Vertex* pre = Get(N-2); // go to one index just before tail, O(N)<br>pre-&gt;next = null;<br>delete tail;<br>tail = pre; // we have access to old tail</pre><p>Notice that this operation is slow, O(<b>N</b>), just because of the need to update the tail pointer from item <b>N</b>-1 backwards by one unit to item <b>N</b>-2 so that future insertion after tail remains correct... This deficiency will be <a href="list105d.html?slide=6-1"><u>later addressed</u></a> in Doubly Linked List variant.</p><br><p>Discussion: What happen if we use <a href="listd82e.html?slide=2-5"><u>array</u></a> implementation for removal of tail of the list?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-18">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-20">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-20" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-19">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-21">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-21" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p><samp>get(i)</samp> is slow: O(<b>N</b>).<br>In Linked List, we need to perform sequential access from head element.</p><br><p><samp>search(v)</samp><br>In the best case, <b>v</b> is found at the first position, O(<b>1</b>).<br>In the worst case, <b>v</b> is not found in the list and we require O(<b>N</b>) scan to determine that.</p><br><p><samp>insert(i, v)</samp><br>In the best case, insert at <b>i = 0</b> or at <b>i = N</b>, head and tail pointers help, O(<b>1</b>).<br>In the worst case, insert at <b>i = N-1</b>, we need to find the item <b>N</b>-2</b> just before the tail, O(<b>N</b>).</p><br><p><samp>remove(i)</samp><br>In the best case, remove at <b>i = 0</b>, head pointer helps, O(<b>1</b>).<br>In the worst case, remove at <b>i = N-1</b>, due to the need to update the tail pointer, O(<b>N</b>).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-20">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3-22">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3-22" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Pure (Singly) Linked List applications are surprisingly rare as the simpler resizeable compact array (vector) can do the job better, compare the <a href="list78af.html?slide=3-21"><u>Linked List version</u></a> with the <a href="listd82e.html?slide=2-5"><u>compact array version</u></a>.</p><br><p>However, the basic concept of Linked List that allows the vertices to be non-contiguous in memory makes it an excellent resize-able data structure for the next two other Abstract Data Types: <a href="list1438.html?slide=4"><u>Stack</u></a> and <a href="list3254.html?slide=5"><u>Queue</u></a>.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-21">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Stack is a particular kind of Abstract Data Type in which the main operations on the collection are the addition of an item to the collection, known as push, only to the top of the stack and removal of an item, known as pop, only from the top of the stack.</p><br><p>It is known as Last-In-First-Out (LIFO) data structure, e.g. the stack of book below.</p><br><img src="../img/stack_illustration.png" width="100%" alt="Stack Illustration">
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3-22">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>In most implementations and also in this visualization, Stack is basically a <b>protected</b> (Singly) Linked List where we can only peek at the head item, push a new item only to the head (<a href="list2c9d.html?slide=3-9"><u>insert at head</u></a>), e.g. try <span class="slide-actions" onclick="doButtonAction99()">InsertHead(6)</span>, and pop existing item only from the head (<a href="listde91.html?slide=3-14"><u>remove from head</u></a>), e.g. try <span class="slide-actions" onclick="doButtonAction105()">RemoveHead()</span>. All operations are O(1).</p><br><p>In this visualization, we orientate the (Single) Linked List top down, with the head/tail item at the top/bottom, respectively. In the example, we have [2 (top/head)-&gt;7-&gt;5-&gt;3-&gt;1-&gt;9 (bottom/tail)].</p><br><p>Discussion: Can we use vector, a resizeable array, to implement Stack ADT efficiently?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Stack has a few popular textbook applications, e.g.:</p><ol><li>Bracket Matching,</li><li>Postfix Calculator,</li><li>A few other interesting applications that are not shown for pedagogical purposes.</li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-4" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Mathematical expression can get quite convoluted, e.g. <samp>{[x+2]^(2+5)-2}*(y+5)</samp>.</p><br><p>Bracket Matching problem is a problem of checking whether all brackets in the given input are matched correctly, i.e. ( with ), [ with ] and { with }, and so on.</p><br><p>Bracket Matching is equally useful for checking the legality of a source code.</p><br><p>Discussion: It turns out that we can use Stack&#39;s LIFO behavior to solve this problem.<br>The question is how?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-5" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-6">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-6" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Postfix expression is a mathematical expression in: <samp>operand1 operand2 operator</samp> format which is different from what human is most comfortable at, the Infix expression: <samp>operand1 operator operand2</samp>.</p><br><p>For example, expression <samp>2 3 + 4 *</samp> is the Postfix version of <samp>(2+3)*4</samp>.</p><br><p>In Postfix expression, we do not need brackets.</p><br><p>Discussion: It turns out that we can also use Stack to solve this problem efficiently.<br>The question is how?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-7">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-7" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-6">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Queue is another Abstract Data Type in which the items in the collection are kept <b>in order</b> and the main operations on the collection are the addition of items to the back position (enqueue) and removal of items from the front position (dequeue).</p><br><p>It is known as <b>First-In-First-Out (FIFO)</b> data structure as the first item to be enqueued will eventually be the first item to be dequeued, as in real life queues (see below).</p><br><img src="../img/queue_illustration.png" width="100%" alt="Queue Illustration">
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-7">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-1" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>If we simply use the <a href="list9578.html?slide=2-3"><u>compact array</u></a> implementation for this Queue ADT with <samp>a<sub>0</sub></samp> is the front of the queue and <samp>a<sub>N-1</sub></samp> is the back of the queue, we will encounter major performance issue with the <b>dequeue</b> operation.</p><br><p>This is because insertion at the back of a compact array is fast, O(<b>1</b>), but removal at the front of a compact array is slow due to the need to shift items, please review <a href="listd82e.html?slide=2-5"><u>this slide</u></a>.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-2" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Another possible array implementation is to avoid that shifting of items during dequeue operation by having <b>two</b> indices: <b>front</b> (the index of the queue front-most item, increased after a dequeue operation) and <b>back</b> (the index of the queue back-most item, also increased after an enqueue operation).</p><br><p>Suppose we use an array of size <b>M = 8</b> items and the content of our queue is as follows: <samp>[2,4,1,7,-,-,-,-]</samp> with <b>front = 0</b> and <b>back = 3</b>.</p><br><p>If we call dequeue, we have <samp>[-,4,1,7,-,-,-,-]</samp>, <b>front = 0+1 = 1</b>, and <b>back = 3</b>.</p><br><p>If we then call enqueue(5), we have <samp>[-,4,1,7,5,-,-,-]</samp>, <b>front = 1</b>, and <b>back = 3+1 = 4</b>.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-3" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>However, many dequeue and enqueue operations later, we may have <samp>[-,-,-,-,-,6,2,3]</samp>, <b>front = 5</b>, and <b>back = 7</b>. By now, we cannot enqueue anything else albeit we have many empty spaces at the front of the array.</p><br><p>If we allow both <b>front</b> and <b>back</b> indices to "wrap back" to index 0 when they have reached index <b>M</b>-1, we effectively make the array "circular" and we can use the empty spaces.</p><br><p>For example, if we call enqueue(8) next, we have <samp>[8 , -,-,-,-,6,2,3]</samp>, <b>front = 5</b>, and <b>back = (7+1)%8 = 0</b>.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-4" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Yet, this does not solve the main problem of array implementation: The items of the array are stored in <b>contiguous</b> manner in computer memory.</p><br><p>A few more enqueue operations later, we may have <samp>[8,10,11,12,13 , 6,2,3]</samp>, <b>front = 5</b>, and <b>back = 4</b>. At this point, we cannot enqueue anything else.</p><br><p>We can enlarge the array, e.g. make <b>M = 2*8 = 16</b>, but that will entail re-copying the items from index <b>front</b> to <b>back</b> in a <b>slow</b> O(<b>N</b>) process to have <samp>[6,2,3,8,10,11,12,13,-,-,-,-,-,-,-,-,]</samp>, <b>front = 0</b>, and <b>back = 7</b>.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-5" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Recall that in a Queue, we only need the two extreme ends of the List, one for insertion (enqueue) only and one for removal (dequeue) only.</p><br><p>If we review <a href="list78af.html?slide=3-21"><u>this slide</u></a>, we see that insertion <b>after tail</b> and removal <b>from head</b> in a Singly Linked List are fast, i.e. O(<b>1</b>). Thus, we designate the head/tail of the Singly Linked List as the front/back of the queue, respectively. Then, as the items in a Linked List are <b>not</b> stored contiguously in computer memory, our Linked List can grow and shrink as needed.</p><br><p>In our visualization, Queue is basically a <b>protected</b> Singly Linked List where we can only peek at the head item, enqueue a new item to one position after the current tail, e.g. try <span class="slide-actions" onclick="doButtonAction108()">Enqueue(random-integer)</span>, and dequeue existing item from the head, e.g. try <span class="slide-actions" onclick="doButtonAction105()">RemoveHead()</span> (which is essentially a dequeue operation). All operations are O(<b>1</b>).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-6">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-6" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Queue ADT is usually used to simulate real queues.</p><br><p>One super important application of Queue ADT is inside the <a href="sssp.html"><u>Breadth-First Search</u></a> graph traversal algorithm.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="6">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-6" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Doubly Linked List (DLL) is 99% the same as its Singly Linked List version. The main difference is that now each vertex contains <b>two</b> pointers. The <b>next</b> pointer is the same as in Singly Linked List version in which it links item <b>a<sub>i</sub></b> with the next item <b>a<sub>i+1</sub></b>, if exists. The additional <b>prev</b> pointer also links item <b>a<sub>i</sub></b> with the previous item <b>a<sub>i-1</sub></b>, if exists.</p><br><p>The usage of <b>prev</b> pointers makes it possible to move/iterate <b>backwards</b> at the expense of two-times memory usage requirement as now each vertex records one additional pointer. The positive side effect of this ability to move backwards is now we can address the weak <a href="listc679.html?slide=3-18"><u>removal at tail case</u></a> of the Singly Linked List.</p><br><p>In this visualization, notice that the edges in Doubly Linked List (and later Deque) are undirected (bidirectional) edges.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-6">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="6-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-6-1" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>The main problem of removal of the tail element in the Singly Linked List, even if we have direct access to the tail item via the tail pointer, is that we then have to update the tail pointer to point to one item just before the tail after such removal.</p><br><p>With Doubly Linked List ability to move <b>backwards</b>, we can find this item before the tail via <samp>tail-&gt;prev</samp>... Thus, we can implement removal of tail this way (in C++):</p><pre>Vertex* temp = tail; // remember tail item<br>tail = tail-&gt;prev; // the key step to achieve O(1) performance :O<br>tail-&gt;next = null; // remove this dangling reference<br>delete temp; // remove the old tail</pre><p>Now this operation is O(<b>1</b>). Try <span class="slide-actions" onclick="doButtonAction106()">RemoveTail()</span> on example DLL [22 (head)&lt;-&gt;2&lt;-&gt;77&lt;-&gt;6&lt;-&gt;43&lt;-&gt;76&lt;-&gt;89 (tail)].</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="6-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-6-2" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>As we have one more pointer <b>prev</b> for each vertex, their values need to be updated too during each insertion or removal. Try all these operations on example DLL [22 (head)&lt;-&gt;2&lt;-&gt;77&lt;-&gt;6&lt;-&gt;43&lt;-&gt;76&lt;-&gt;89 (tail)].</p><br><p>Try <span class="slide-actions" onclick="doButtonAction100()">InsertHead(50)</span> — additional step: 22&#39;s <b>prev</b> pointer points to new head 50.</p><br><p>Try <span class="slide-actions" onclick="doButtonAction101()">InsertTail(10)</span> — additional step: 10&#39;s <b>prev</b> pointer points to old tail 89.</p><br><p>Try <span class="slide-actions" onclick="doButtonAction102()">Insert(3, 44)</span> — additional step: 6&#39;s/44&#39;s <b>prev</b> pointers point to 44/77, respectively.</p><br><p>Try <span class="slide-actions" onclick="doButtonAction105()">RemoveHead()</span> — set new head 2&#39;s <b>prev</b> pointer to null.</p><br><p>Try <span class="slide-actions" onclick="doButtonAction107()">Remove(5)</span> — set 89&#39;s <b>prev</b> pointer to 43.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Double-ended queue (often abbreviated to deque, pronounced deck) is an Abstract Data Type that generalizes a Queue, for which elements can be added to or removed only from <b>either</b> the front (head) or back (tail).</p><br><p>In our visualization, Deque is basically a protected Doubly Linked List where we can only:<br>search the head/tail item (peek front/back),<br>insert a new item to the head/tail (try <span class="slide-actions" onclick="doButtonAction100()">InsertHead(50)</span> or <span class="slide-actions" onclick="doButtonAction101()">InsertTail(10)</span>), and <br>remove an existing item from the head/tail (try <span class="slide-actions" onclick="doButtonAction105()">RemoveHead()</span> or <span class="slide-actions" onclick="doButtonAction106()">RemoveTail()</span>).</p><br><p>All operations are O(<b>1</b>).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7-1" class="electure-dialog" style="top:200px;left:50%;margin-left:-250px;width:500px;">
<p>Deque are used a few advanced applications, like finding the shortest paths 0/1-weighted graph using modified BFS, on some sliding window techniques, etc.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="8">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-8" class="electure-dialog" style="bottom:200px;left:60px;width:500px;">
<p>Create operation is the same for all five modes.</p><br><p>However there are minor differences for the search/insert/remove operations among the five modes.</p><br><p>For Stack, you can only peek/restricted-search, push/restricted-insert, and pop/restricted-remove from the top/head.</p><br><p>For Queue, you can only peek/restricted-search from the front, push/restricted-insert from the back, and pop/restricted-remove from the front.</p><br><p>For Deque, you can peek/restricted-search, enqueue/restricted-insert, dequeue/restricted-remove from both front/back, but not from the middle.</p><br><p>Single (Singly) and Doubly Linked List do not have such restrictions.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="9">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-9" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>We have reached the end of this e-Lecture.</p><br><p>But read ahead for a few extra challenges.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="8">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="9-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-9-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>The following are the more advanced insights about Linked List:</p><ol><li>What happen if we don&#39;t store the tail pointer too?</li><li>What if we use dummy head?</li><li>What if the last tail item points back to the head item?</li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="9-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-9-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="9-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-9-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>C++ STL:<br><a href="http://en.cppreference.com/w/cpp/container/forward_list" target="_blank"><u>forward_list</u></a> (a Singly Linked List)<br><a href="http://en.cppreference.com/w/cpp/container/stack" target="_blank"><u>stack</u></a><br><a href="http://en.cppreference.com/w/cpp/container/queue" target="_blank"><u>queue</u></a><br><a href="http://en.cppreference.com/w/cpp/container/list" target="_blank"><u>list</u></a> (a Doubly Linked List)<br><a href="http://en.cppreference.com/w/cpp/container/deque" target="_blank"><u>deque</u></a> (actually not using Doubly Linked List but another technique, see cppreference)</p><br><p>Java API:<br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html" target="_blank"><u>LinkedList</u></a> (already a Doubly Linked List)<br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Stack.html" target="_blank"><u>Stack</u></a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html" target="_blank"><u>Queue</u></a> (actually an interface, usually implemented using LinkedList class)<br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html" target="_blank"><u>Deque</u></a> (actually an interface, usually implemented using LinkedList class)</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="9-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-9-4" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Python:<br><a href="https://docs.python.org/3/tutorial/datastructures.html" target="_blank"><u>list</u></a> for List/Stack/Queue<br><a href="https://docs.python.org/3/library/collections.html#collections.deque" target="_blank"><u>deque</u></a></p><br><p>OCaml:<br><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html" target="_blank"><u>List</u></a><br><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Stack.html" target="_blank"><u>Stack</u></a><br><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Queue.html" target="_blank"><u>Queue</u></a><br>No built-in support for Deque</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="9-5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-9-5" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>For a few more interesting questions about this data structure, please practice on <a href="https://visualgo.net/training?diff=Medium&amp;n=7&amp;tl=0&amp;module=list"><u>Linked List</u></a> training module (no login is required).</p><br><p>However, for registered users, you should login and then go to the <a href="https://visualgo.net/training"><u>Main Training Page</u></a> to officially clear this module and such achievement will be recorded in your user account.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="9-6">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-9-6" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>We also have a few programming problems that somewhat requires the usage of this Linked List, Stack, Queue, or Deque data structure:<br><a href="https://uva.onlinejudge.org/external/119/11988.pdf" title="" target="_blank"><u>UVa 11988 - Broken Keyboard (a.k.a. Beiju Text)</u></a>,<br><a href="https://open.kattis.com/problems/backspace" title="" target="_blank"><u>Kattis - backspace</u></a>, and<br><a href="https://open.kattis.com/problems/integerlists" title="" target="_blank"><u>Kattis - integerlists</u></a>.</p><br><p>Try them to consolidate and improve your understanding about this data structure. You are allowed to use C++ STL or Java API if that simplifies your implementation.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9-5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99" class="electure-dialog" style="right:150px;bottom:335px;width:500px;">
<p>As the action is being carried out, each step will be described in the status panel.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9-6">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-1" class="electure-dialog" style="right:170px;bottom:275px;width:180px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-2" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-120px;width:260px;">
<p>Control the animation with the player controls! Keyboard shortcuts are:<br></p><div style="margin-top: 8px;"><strong>Spacebar:</strong> play/pause/replay</div><strong>Left/right arrows:</strong> step backward/step forward<br><strong>-/+:</strong> decrease/increase speed<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-3" class="electure-dialog" style="top:70px;right:60px;width:300px;">
<p>Return to &#39;Exploration Mode&#39; to start exploring!</p><br><p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99-2">Trước đó <u>PgUp</u></div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="actions" class="panel">
<p id="create">Tạo</p>
<p id="search" class="execAction" onClick="searchGeneric()">Tìm kiếm(v)</p>
<p id="insert">Chèn(i,v)</p>
<p id="remove" class="execAction" onClick="removeGeneric()">Di chuyển(i)</p>
</div>
<div id="actions-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide actions panel" /></div>
<div id="actions-extras">
<div class="create action-menu-pullout">
<div id="create-empty" class="execAction new-menu-option coloured-menu-option" onClick="empty()"><p>Trống</p></div>
<div id="create-random" class="execAction new-menu-option coloured-menu-option" onClick="random()"><p>Ngẫu nhiên</p></div>
<div id="create-random-sorted" class="execAction new-menu-option coloured-menu-option" onClick="randomSorted()"><p>Random Sorted</p></div>
<div id="create-random-fixed-size" class="execAction new-menu-option coloured-menu-option" onclick="createModelingOpen('createfixedsize')"><p>Random Fixed Size</p>
<div id="createfixedsize-input" class="new-menu-option">
<input type="number" id="v-create-size" title="Enter the size of the linked list" autocomplete="off" min=1 max=10 value=7>
<div id="createfixedsize-go" class="execAction coloured-menu-option" onClick="randomFixedSize()" title="Create random fixed size linked list"><p>Go</p></div>
</div>
</div>
<div id="create-from-arr" class="execAction new-menu-option coloured-menu-option" onclick="createModelingOpen('createuserdefined')"><p>--- User Defined List ---</p>
<div id="createuserdefined-input" class="new-menu-option">
<input type="text" id="v-create-arr" title="Enter the elements separated by comma" autocomplete="off" value="1,2,3">
<div id="createuserdefined-go" class="execAction coloured-menu-option" onClick="nonRandom()" title="Create random fixed size linked list"><p>Go</p></div>
</div>
</div>
<div id="create-err" class="err"></div>
</div>
<div class="search action-menu-pullout">

<div id="search-peek-front" style="display: none;" class="execAction new-menu-option coloured-menu-option" onclick="peekDeque('front')"><p>Front</p></div>
<div id="search-peek-back" style="display: none;" class="execAction new-menu-option coloured-menu-option" onclick="peekDeque('back')"><p>Back</p></div>

<div id="search-input" class="new-menu-option">v = <input type="number" id="v-search" title="Enter an Integer" autocomplete="off" min=0 max=99 value=5></div>
<div id="search-go" class="execAction coloured-menu-option" onclick="searchVertex()"><p>Go</p></div>
<div id="search-err" class="err"></div>
</div>
<div class="insert action-menu-pullout">


<div id="pushtop-input" style="display: none;" class="new-menu-option">v = <input type="number" id="v-push-top-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=53></div>
<div id="pushtop-go" style="display: none;" class="execAction coloured-menu-option" onclick="pushTop()"><p>Go</p></div>

<div id="enqueueback-input" style="display: none;" class="new-menu-option">v = <input type="number" id="v-enqueue-back-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=57></div>
<div id="enqueueback-go" style="display: none;" class="execAction coloured-menu-option" onclick="enqueueBack()"><p>Go</p></div>

<div id="insert-deque-input" style="display: none;" class="new-menu-option">v = <input type="number" id="v-insert-deque-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=57></div>
<div id="insert-deque-front" style="display: none;" class="execAction new-menu-option coloured-menu-option" onclick="insertDeque('front')"><p>Front</p></div>
<div id="insert-deque-back" style="display: none;" class="execAction new-menu-option coloured-menu-option" onclick="insertDeque('back')"><p>Back</p></div>


<div id="insert-head" class="execAction new-menu-option coloured-menu-option" onclick="insertModelingOpen('inserthead')"><p>i = 0 (Head), specify v =</p>
<div id="inserthead-input" class="new-menu-option">
<input type="number" id="v-insert-head-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=85>
<div id="inserthead-go" class="execAction coloured-menu-option" onClick="insertHead()" title="Insert to Head"><p>Go</p></div>
</div>
</div>
<div id="insert-tail" class="execAction new-menu-option coloured-menu-option" onclick="insertModelingOpen('inserttail')"><p>i = N (After Tail), specify v =</p>
<div id="inserttail-input" class="new-menu-option">
<input type="number" id="v-insert-tail-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=80>
<div id="inserttail-go" class="execAction coloured-menu-option" onClick="insertTail()" title="Insert to Tail"><p>Go</p></div>
</div>
</div>
<div id="insert-kth" class="execAction new-menu-option coloured-menu-option" onclick="insertModelingOpen('insertkth')"><p>specify both i in [1..N-1] and v =</p>
<div id="insertkth-input" class="new-menu-option">
<input type="number" id="v-insert-kth" title="Enter an Integer" autocomplete="off" min=1 max=9 value=2>
<input type="number" id="v-insert-kth-value" title="Enter an Integer" autocomplete="off" min=0 max=99 value=90>
<div id="insertkth-go" class="execAction coloured-menu-option" onClick="insertKth()" title="Insert to kth"><p>Go</p></div>
</div>
</div>
<div id="insert-err" class="err"></div>
</div>
<div class="remove action-menu-pullout">

<div id="remove-deque-front" style="display:none;" class="execAction new-menu-option coloured-menu-option" onclick="removeDeque('front')"><p>Front</p></div>
<div id="remove-deque-back" style="display:none;" class="execAction new-menu-option coloured-menu-option" onclick="removeDeque('back')"><p>Back</p></div>

<div id="remove-head" class="execAction new-menu-option coloured-menu-option" onClick="removeHead()"><p>Remove i = 0 (Head)</p></div>
<div id="remove-tail" class="execAction new-menu-option coloured-menu-option" onClick="removeTail()"><p>Remove i = N-1 (Tail)</p></div>
<div id="remove-kth" class="execAction new-menu-option coloured-menu-option" onclick="removeModelingOpen('removekth')"><p>specify i in [1..N-2]</p>
<div id="removekth-input" class="new-menu-option">
<input type="number" id="v-remove-kth" title="Enter an Integer" autocomplete="off" min=1 max=8 value=2>
<div id="removekth-go" class="execAction coloured-menu-option" onClick="removeKth()" title="Remove k-th"><p>Go</p></div>
</div>
</div>
<div id="remove-err" class="err"></div>
</div>
</div>
<div id="bottom-bar">
<a id="trigger-about">Về</a>
<a id="trigger-team">Nhóm</a>
<a id="trigger-terms">Điều khoản sử dụng</a>
</div>
<div id="about" class="overlays">
<h4>Về</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
VisuAlgo được lên ý tưởng vào năm 2011 bởi tiến sĩ Steven Halim như là một công cụ để giúp những sinh viên của ông ấy có thể hiểu rõ hơn về các cấu trúc dữ liệu và thuật toán, bằng cách cho phép họ tự học những nội dung cơ bản nhất với tiến độ phù hợp với riêng họ.<br>VisuAlgo chứa rất nhiều thuật toán nâng cao đã được thảo luận trong cuốn sách của Tiến sĩ Steven Halim (&#39;Competitive Programming&#39;, đồng tác giả với anh trai của ông ấy, tiến sĩ Felix Halim) và hơn thế nữa. Hiện tại, một số mô phỏng/hiệu ứng hoạt hình của các thuật toán nâng cao này chỉ có thể tìm thấy ở VisuAlgo.<div>Mặc dù được thiết kế đặc biệt cho những sinh viên đại học quốc gia Singapore (phải học rất nhiều môn học về cấu trúc dữ liệu và thuật toán - ví dụ: CS1010, CS1020, CS2010, CS2020, CS3230, and CS3230), như những người ủng hộ việc học trực tuyến, chúng tôi hi vọng rằng những người quan tâm tới cấu trúc dữ liệu và thuật toán trên toàn thế giới cũng có thể thấy những mô tả này là hữu dụng.<br>Ngay từ đầu, VisuAlgo không được thiết kế để làm việc tốt trên những màn hình cảm ứng nhỏ (ví dụ như smartphones) do việc mô phỏng các thuật toán phức tạp cần rất nhiều điểm ảnh và cử chỉ nhấp và kéo để tương tác. Độ phân giải màn ảnh nhỏ nhất cho trải nghiệm người dùng chấp nhận được là 1024x768 và chỉ có duy nhất trang đích là tương đối thân thiện với bản di động.</div><div>VisuAlgo là một dự án liên tục và nhiều mô phỏng phức tạp vẫn đang được phát triển.<br>Cải tiến thú vị nhất là tạo và duyệt câu hỏi tự động (hệ thống câu hỏi trực tuyến) cho phép sinh viên kiểm tra kiến thức cơ bản về các cấu trúc dữ liệu và thuật toán. Các câu hỏi được tạo ngẫu nhiên thông qua những quy luật và câu trả lời của sinh viên sẽ được chấm điểm tự động và ngay lập tức dựa trên việc nộp bài tới server chấm điểm của chúng tôi. Hệ thống câu hỏi trực tuyến này, khi mà nó được chấp nhận bởi nhiều giảng viên CS trên toàn thế giới, sẽ xóa bỏ mặt kĩ thuật các câu hỏi về cấu trúc dữ liệu và thuật toán cơ bản khỏi các kỳ thi khoa học máy tính điển hình tại rất nhiều trường đại học. Bằng cách đặt một tiêu chí chấm điểm nhỏ (nhưng khác 0) vào việc vượt qua các câu hỏi trực tuyến, giảng viên CS có thể làm tăng (một cách đáng kể) sự thành thạo của những sinh viên trên những câu hỏi cơ bản này khi họ một lượng vô số các câu hỏi thực tế cho sự luyện tập cái mà có thể được kiểm chứng ngay lập tức trước khi họ làm câu hỏi trực tuyến. Hiện tại, chế độ hướng dẫn bao gồm các câu hỏi cho 12 module mô phỏng. Chúng tôi sẽ sớm thêm vào 8 module mô phỏng còn lại để cho tất cả các module mô phỏng ở VisuAlgo đều có phần câu hỏi trực tuyến.<br>Một cải tiến hấp dẫn khác là việc quốc tế hóa các dự án nhánh của VisuAlgo. Chúng tôi muốn chuẩn bị cơ sở dữ liệu các thuật ngữ CS cho các văn bản tiếng Anh đã từng xuất hiện trên hệ thống VisuAlgo. Đây là một nhiệm vụ lớn và cần điện toán đám đông. Một khi hệ thống đã sẵn sàng, chúng tôi sẽ mời người dùng VisuAlgo đóng góp, đặc biệt là khi bạn không phải là người nói tiếng Anh bản ngữ. Hiện tại, chúng tôi cũng đang viết những ghi chú về VisuAlgo bằng những ngôn ngữ khác nhau.<br></div>
<a href="https://weibo.com/p/230418436e9ee80102v4rk" target='_blank'><u>zh</u></a>, <a href='https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689' target='_blank'><u>id</u></a>, <a href="https://blog.naver.com/visualgo_nus" target='_blank'><u>kr</u></a>, <a href='https://www.facebook.com/groups/163215593699283/permalink/824003417620494/' target='_blank'><u>vn</u></a>, <a href='http://pantip.com/topic/32736343' target='_blank'><u>th</u></a>.</p>
</div>
</div>
<div id="team" class="overlays">
<h4>Nhóm</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
<p>
<strong><span style='line-height: 150%;'>Trưởng dự án và cố vấn (từ tháng 7/2011 đến nay)</span></strong><br>
<a href='http://www.comp.nus.edu.sg/~stevenha/' target='_blank'>Dr Steven Halim</a>, Senior Lecturer, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href='http://felix-halim.net/' target='_blank'>Dr Felix Halim</a>, Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style='line-height: 150%;'>Những nhà nghiên cứu sinh viên 1 (Jul 2011-Apr 2012)</span></strong><br>
Koh Zi Chun, <a href='http://roticv.rantx.com/' target='_blank'>Victor Loh Bo Huai</a>
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 1 (Jul 2012-Dec 2013)</span></strong><br>
Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 2 (Jun 2013-Apr 2014)</span></strong><br>
<a href='http://www.rosemarietan.com/' target='_blank'>Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style='line-height: 150%;'>Những nhà nghiên cứu sinh viên 2 (May 2014-Jul 2014)</span></strong><br>
Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 3 (Jun 2014-Apr 2015)</span></strong><br>
Erin Teo Yi Ling, Wang Zi
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 4 (Jun 2016-Dec 2017)</span></strong><br>
Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir
</p>
<p>
List of translators who have contributed &ge;100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style='line-height: 150%;'>Lời cảm ơn</span></strong><br>
This project is made possible by the generous <a href="http://www.cdtl.nus.edu.sg/teg/" target="_blank">Teaching Enhancement Grant</a> from NUS Centre for Development of Teaching and Learning (CDTL).
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Điều khoản sử dụng</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
VisuAlgo miễn phí đối với cộng đồng Khoa học Máy tính trên toàn thế giới. Nếu bạn yêu thích VisuAlgo, khoản chi phí duy nhất mà chúng tôi muốn bạn chi trả chính là hãy nói cho những <b>sinh viên/ giảng viên ngành khoa học máy tính</b> mà bạn biết<b> về sự tồn tại của VisuAlgo</b> =) thông qua Facebook, Twitter, trang web về khóa học, blog review, email , v.v &amp; v.v. Nếu bạn là một<b> sinh viên/ giảng viên</b> ngành cấu trúc dữ liệu và thuật toán, bạn được phép sử dụng website này một cách trực tiếp trong các lớp học của bạn. Nếu bạn lấy những ảnh chụp màn hình (videos) từ website này, bạn có thể sử dụng chúng ở bất kỳ đâu, miễn là có dẫn nguồn URL của website này (http://visualgo.net) và/hoặc liệt kê các công bố ở dưới như là tài liệu tham khảo. Tuy nhiên, bạn <b>KHÔNG</b> được phép tải xuống các tập tin VisuAlgo (phía máy trạm) và lưu trữ nó ở website riêng của bạn vì nó được coi là <b>đạo ý tưởng</b> .Hiện tại, chúng tôi <b>KHÔNG</b> cho phép những người khác chia nhỏ dự án này và tạo ra những phiên bản khác của VisuAlgo. Việc sử dụng bản sao ngoại tuyến của VisuAlgo (phía máy trạm) cho mục đích cá nhân của bạn thì có thể chấp nhận được.<br>Lưu ý rằng hệ thống câu hỏi trực tuyến của VisuAlgo có phần dữ liệu phía máy chủ rất lớn và không dễ dàng để lưu lại mã kịch bản phía máy chủ và cơ sở dữ liệu một cách cục bộ. Hiện tại, mọi người chỉ có thể sử dụng "chế độ đào tạo" để truy cập hệ thống câu hỏi trực tuyến này. Chế độ kiểm tra hiện là môi trường có kiểm soát hơn cho việc sử dụng những câu hỏi được tạo ngẫu nhiên này và tự động kiểm duyệt cho kỳ thi <b>thật sự</b> tại Đại học Quốc gia Singapore<span style="white-space: normal;">.</span> Những giảng viên quan tâm tới khoa học máy tính có thể liên hệ với Steven nếu muốn trải nghiệm "chế độ kiểm tra"<br><b>Danh sách phát hành</b><br>Dự án này đươc trình bày một cách vắn tắt ở Hội thảo CLI tại ACM ICPC World Finals 2012 (Warsaw, Ba Lan) và tại Hội nghị IOI 2012 (Sirmione-Montichiari, Italy). Bạn có thể nhấn vào link này để đọc bài viết năm 2012 của chúng tôi về hệ thống này (nó không được gọi là VisuAlgo vào năm 2012)<br>Dự án này được hoàn thiện hầu hết bởi những cựu sinh viên của tôi. Báo cáo cuối cùng gần đây nhất là của: <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/erin-report.pdf" target="_blank">Erin</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/wangzi-report.pdf" target="_blank">Wang Zi</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/rose-report.pdf" target="_blank">Rose</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/ivan-report.pdf" target="_blank">Ivan</a>.<br><b>Báo cáo lỗi hoặc đề xuất tính năng mới</b><br>VisuAlgo là một dự án chưa hoàn thiện. Tiến sĩ Steven Halim vẫn đang tiếp tục phát triển VisuAlgo một cách tích cực/ Nếu bạn đang sử dụng VisuAlgo và phát hiện ra lỗi ở bất kỳ trang mô phỏng/ công cụ câu hỏi trực tuyến nào của chúng tôi hoặc nếu bạn muốn đề xuất những tính năng mới, hãy liên lạc với Tiến sĩ Steven Halim. Địa chỉ liên lạc của ông ấy là stevenhalim@gmail.com<br>
</div>
</div>

<script src="../js/jquery-3.3.1.min.js"></script>
<script>
      var PHP_DOMAIN = "";

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        //setTimeout(function() {
          if (retval) { // mode == "exploration" && // now not only for exploration mode, but check if this opens other problems
            $('#current-action').show();
            $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
            $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
            triggerRightPanels();
            isPlaying = true;
          }
        //}, 500);
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; i++) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.right-links').css('background', surpriseColour);
        $('#login-go').css('background', surpriseColour);

        $('.colour').css("color", surpriseColour); // name
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
          // temporary quick fix for Google Chrome Aug 2016 issue...
          setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 100); // force resize/redraw...
          setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        });

        // overlays stuffs
        $('#trigger-about').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#about').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('#trigger-team').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#team').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('#trigger-terms').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#termsofuse').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('.close-overlay').click(function() {
          $('.overlays').fadeOut(function() {
            $('#dark-overlay').fadeOut();
          });
        });

        $('#dark-overlay').click(function() {
          $('.overlays').fadeOut();
          $('#dark-overlay').fadeOut();
        });

        $.get('/isloggedin', function(data) {
          var isLoggedIn = data['isloggedin'] == '1';
          var element;
          if (isLoggedIn) {
            // element = '<a onclick="verifyLogout()">Đăng Xuất<div><br></div></a>';
            element = '<a href="https://visualgo.net/profile">Profile</a>'; 
          }
          else {
            element = '<a href="https://visualgo.net/login">Đăng nhập</a>'
          }
          $('#useraccount').html(element);
        });
      });

      function verifyLogout() {
        // Steven's remarks: use a better 'confirm' than the default :(
        var doesLogout = confirm('Are you sure to logout?');
        if (doesLogout == true) {
          window.location = "https://visualgo.net/logout";
        }
      }

      function checkLogin() {
        $.get('/checklogin', function(data) {
          var url = data['url'];
          window.location.href = '/' + url;
        });
      }

      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','../../www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-1566631-4', 'auto');
      ga('send', 'pageview');
    </script>

<script src="../js/jquery-ui.min.js"></script>

<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.3.js"></script>
<script src="../js/visualgo_print.js"></script>
<script src="../js/graph_library.js"></script>
<script>
      function runSlide(slide) {
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 1 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '1-1') {
          $("#e-lecture").html("slide " + slide + " (" + 3 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 4 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-1') {
          $("#e-lecture").html("slide " + slide + " (" + 6 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-2') {
          $("#e-lecture").html("slide " + slide + " (" + 7 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-3') {
          $("#e-lecture").html("slide " + slide + " (" + 9 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-4') {
          $("#e-lecture").html("slide " + slide + " (" + 10 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-5') {
          $("#e-lecture").html("slide " + slide + " (" + 12 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-6') {
          $("#e-lecture").html("slide " + slide + " (" + 13 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-7') {
          $("#e-lecture").html("slide " + slide + " (" + 15 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2-8') {
          $("#e-lecture").html("slide " + slide + " (" + 16 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 18 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-1') {
          $("#e-lecture").html("slide " + slide + " (" + 19 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-2') {
          $("#e-lecture").html("slide " + slide + " (" + 21 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-3') {
          $("#e-lecture").html("slide " + slide + " (" + 22 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-4') {
          $("#e-lecture").html("slide " + slide + " (" + 24 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-5') {
          $("#e-lecture").html("slide " + slide + " (" + 25 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-6') {
          $("#e-lecture").html("slide " + slide + " (" + 27 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-7') {
          $("#e-lecture").html("slide " + slide + " (" + 28 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-8') {
          $("#e-lecture").html("slide " + slide + " (" + 30 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-9') {
          $("#e-lecture").html("slide " + slide + " (" + 31 + "%)");
          $("#title-LL").click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-10') {
          $("#e-lecture").html("slide " + slide + " (" + 33 + "%)");
          $("#title-LL").click();
empty();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-11') {
          $("#e-lecture").html("slide " + slide + " (" + 34 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-12') {
          $("#e-lecture").html("slide " + slide + " (" + 36 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-13') {
          $("#e-lecture").html("slide " + slide + " (" + 37 + "%)");
          $("#title-LL").click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-14') {
          $("#e-lecture").html("slide " + slide + " (" + 39 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-15') {
          $("#e-lecture").html("slide " + slide + " (" + 40 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-16') {
          $("#e-lecture").html("slide " + slide + " (" + 42 + "%)");
          $("#title-LL").click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-17') {
          $("#e-lecture").html("slide " + slide + " (" + 43 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-18') {
          $("#e-lecture").html("slide " + slide + " (" + 45 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-19') {
          $("#e-lecture").html("slide " + slide + " (" + 46 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-20') {
          $("#e-lecture").html("slide " + slide + " (" + 48 + "%)");
          $("#title-LL").click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-21') {
          $("#e-lecture").html("slide " + slide + " (" + 50 + "%)");
          $("#title-LL").click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3-22') {
          $("#e-lecture").html("slide " + slide + " (" + 51 + "%)");
          $("#title-LL").click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 53 + "%)");
          $('#title-Stack').click();
$("#v-create-arr").val("2,7,5,3,1,9");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-1') {
          $("#e-lecture").html("slide " + slide + " (" + 54 + "%)");
          $('#title-Stack').click();
$("#v-create-arr").val("2,7,5,3,1,9");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-2') {
          $("#e-lecture").html("slide " + slide + " (" + 56 + "%)");
          $('#title-Stack').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-3') {
          $("#e-lecture").html("slide " + slide + " (" + 57 + "%)");
          $('#title-Stack').click();

          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-4') {
          $("#e-lecture").html("slide " + slide + " (" + 59 + "%)");
          $('#title-Stack').click();

          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-5') {
          $("#e-lecture").html("slide " + slide + " (" + 60 + "%)");
          $('#title-Stack').click();

          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-6') {
          $("#e-lecture").html("slide " + slide + " (" + 62 + "%)");
          $('#title-Stack').click();

          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-7') {
          $("#e-lecture").html("slide " + slide + " (" + 63 + "%)");
          $('#title-Stack').click();

          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5') {
          $("#e-lecture").html("slide " + slide + " (" + 65 + "%)");
          $('#title-Queue').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-1') {
          $("#e-lecture").html("slide " + slide + " (" + 66 + "%)");
          $('#title-Queue').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-2') {
          $("#e-lecture").html("slide " + slide + " (" + 68 + "%)");
          $('#title-Queue').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-3') {
          $("#e-lecture").html("slide " + slide + " (" + 69 + "%)");
          $('#title-Queue').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-4') {
          $("#e-lecture").html("slide " + slide + " (" + 71 + "%)");
          $('#title-Queue').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-5') {
          $("#e-lecture").html("slide " + slide + " (" + 72 + "%)");
          $('#title-Queue').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-6') {
          $("#e-lecture").html("slide " + slide + " (" + 74 + "%)");
          $('#title-Queue').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6') {
          $("#e-lecture").html("slide " + slide + " (" + 75 + "%)");
          $('#title-DLL').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6-1') {
          $("#e-lecture").html("slide " + slide + " (" + 77 + "%)");
          $('#title-DLL').click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6-2') {
          $("#e-lecture").html("slide " + slide + " (" + 78 + "%)");
          $('#title-DLL').click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7') {
          $("#e-lecture").html("slide " + slide + " (" + 80 + "%)");
          $('#title-Deque').click();
$("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-1') {
          $("#e-lecture").html("slide " + slide + " (" + 81 + "%)");
          $('#title-Deque').click();
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '8') {
          $("#e-lecture").html("slide " + slide + " (" + 83 + "%)");
          
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9') {
          $("#e-lecture").html("slide " + slide + " (" + 84 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9-1') {
          $("#e-lecture").html("slide " + slide + " (" + 86 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9-2') {
          $("#e-lecture").html("slide " + slide + " (" + 87 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9-3') {
          $("#e-lecture").html("slide " + slide + " (" + 89 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9-4') {
          $("#e-lecture").html("slide " + slide + " (" + 90 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9-5') {
          $("#e-lecture").html("slide " + slide + " (" + 92 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9-6') {
          $("#e-lecture").html("slide " + slide + " (" + 93 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99') {
          $("#e-lecture").html("slide " + slide + " (" + 95 + "%)");
          
          hideEntireActionsPanel();
 
          showStatusPanel();
          showCodetracePanel();
      
        }
        if (slide == '99-1') {
          $("#e-lecture").html("slide " + slide + " (" + 96 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99-2') {
          $("#e-lecture").html("slide " + slide + " (" + 98 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99-3') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };

      function pushState(slideValue) {
        var url = '/vi/list';
        if (typeof slideValue != 'undefined' && slideValue != null) url += '?slide=' + slideValue;
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5); 
        $('#overlay').show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      $(function() {
        var slide = getUrlParameter('slide');
        
        $.get('/hasvisited' + '/list', function(data) {
          var hasVisited = data['hasvisited'] == '1';
          if (!hasVisited) {
            var postData = {
              '_token': 'iVivZ7KRPe6XK7pbuGtOoEjljE1xyBVNhLKNFuF8',
              'page': '/list'.substring(1),
            };

            $.post("/visitpage", postData, function(data) {
              // non critical request...
            });

            if (typeof slide != undefined && slide != null) {
              cur_slide = slide;
            }

            $("#mode-menu a").trigger("click");
          }
          else {
            if (typeof slide != undefined && slide != null) {
              cur_slide = slide;
              $('#mode-menu a').click();
            }    
          }
        }).fail(function() {
          if (typeof slide != undefined && slide != null) {
            cur_slide = slide;
            $('#mode-menu a').click();
          }
        });

        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
      
        $('#electure-1-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
        $('#electure-1-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
      
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1-1');
          pushState('1-1');
        });
      
        $('#electure-2-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2-2');
          pushState('2-2');
        });
        $('#electure-2-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
      
        $('#electure-2-2 .electure-next').click(function() {
          hidePopup();
          runSlide('2-3');
          pushState('2-3');
        });
        $('#electure-2-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-1');
          pushState('2-1');
        });
      
        $('#electure-2-3 .electure-next').click(function() {
          hidePopup();
          runSlide('2-4');
          pushState('2-4');
        });
        $('#electure-2-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-2');
          pushState('2-2');
        });
      
        $('#electure-2-4 .electure-next').click(function() {
          hidePopup();
          runSlide('2-5');
          pushState('2-5');
        });
        $('#electure-2-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-3');
          pushState('2-3');
        });
      
        $('#electure-2-5 .electure-next').click(function() {
          hidePopup();
          runSlide('2-6');
          pushState('2-6');
        });
        $('#electure-2-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-4');
          pushState('2-4');
        });
      
        $('#electure-2-6 .electure-next').click(function() {
          hidePopup();
          runSlide('2-7');
          pushState('2-7');
        });
        $('#electure-2-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-5');
          pushState('2-5');
        });
      
        $('#electure-2-7 .electure-next').click(function() {
          hidePopup();
          runSlide('2-8');
          pushState('2-8');
        });
        $('#electure-2-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-6');
          pushState('2-6');
        });
      
        $('#electure-2-8 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-7');
          pushState('2-7');
        });
      
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2-8');
          pushState('2-8');
        });
      
        $('#electure-3-1 .electure-next').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
        $('#electure-3-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
      
        $('#electure-3-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
        $('#electure-3-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-1');
          pushState('3-1');
        });
      
        $('#electure-3-3 .electure-next').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
        $('#electure-3-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-2');
          pushState('3-2');
        });
      
        $('#electure-3-4 .electure-next').click(function() {
          hidePopup();
          runSlide('3-5');
          pushState('3-5');
        });
        $('#electure-3-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-3');
          pushState('3-3');
        });
      
        $('#electure-3-5 .electure-next').click(function() {
          hidePopup();
          runSlide('3-6');
          pushState('3-6');
        });
        $('#electure-3-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-4');
          pushState('3-4');
        });
      
        $('#electure-3-6 .electure-next').click(function() {
          hidePopup();
          runSlide('3-7');
          pushState('3-7');
        });
        $('#electure-3-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-5');
          pushState('3-5');
        });
      
        $('#electure-3-7 .electure-next').click(function() {
          hidePopup();
          runSlide('3-8');
          pushState('3-8');
        });
        $('#electure-3-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-6');
          pushState('3-6');
        });
      
        $('#electure-3-8 .electure-next').click(function() {
          hidePopup();
          runSlide('3-9');
          pushState('3-9');
        });
        $('#electure-3-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-7');
          pushState('3-7');
        });
      
        $('#electure-3-9 .electure-next').click(function() {
          hidePopup();
          runSlide('3-10');
          pushState('3-10');
        });
        $('#electure-3-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-8');
          pushState('3-8');
        });
      
        $('#electure-3-10 .electure-next').click(function() {
          hidePopup();
          runSlide('3-11');
          pushState('3-11');
        });
        $('#electure-3-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-9');
          pushState('3-9');
        });
      
        $('#electure-3-11 .electure-next').click(function() {
          hidePopup();
          runSlide('3-12');
          pushState('3-12');
        });
        $('#electure-3-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-10');
          pushState('3-10');
        });
      
        $('#electure-3-12 .electure-next').click(function() {
          hidePopup();
          runSlide('3-13');
          pushState('3-13');
        });
        $('#electure-3-12 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-11');
          pushState('3-11');
        });
      
        $('#electure-3-13 .electure-next').click(function() {
          hidePopup();
          runSlide('3-14');
          pushState('3-14');
        });
        $('#electure-3-13 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-12');
          pushState('3-12');
        });
      
        $('#electure-3-14 .electure-next').click(function() {
          hidePopup();
          runSlide('3-15');
          pushState('3-15');
        });
        $('#electure-3-14 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-13');
          pushState('3-13');
        });
      
        $('#electure-3-15 .electure-next').click(function() {
          hidePopup();
          runSlide('3-16');
          pushState('3-16');
        });
        $('#electure-3-15 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-14');
          pushState('3-14');
        });
      
        $('#electure-3-16 .electure-next').click(function() {
          hidePopup();
          runSlide('3-17');
          pushState('3-17');
        });
        $('#electure-3-16 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-15');
          pushState('3-15');
        });
      
        $('#electure-3-17 .electure-next').click(function() {
          hidePopup();
          runSlide('3-18');
          pushState('3-18');
        });
        $('#electure-3-17 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-16');
          pushState('3-16');
        });
      
        $('#electure-3-18 .electure-next').click(function() {
          hidePopup();
          runSlide('3-19');
          pushState('3-19');
        });
        $('#electure-3-18 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-17');
          pushState('3-17');
        });
      
        $('#electure-3-19 .electure-next').click(function() {
          hidePopup();
          runSlide('3-20');
          pushState('3-20');
        });
        $('#electure-3-19 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-18');
          pushState('3-18');
        });
      
        $('#electure-3-20 .electure-next').click(function() {
          hidePopup();
          runSlide('3-21');
          pushState('3-21');
        });
        $('#electure-3-20 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-19');
          pushState('3-19');
        });
      
        $('#electure-3-21 .electure-next').click(function() {
          hidePopup();
          runSlide('3-22');
          pushState('3-22');
        });
        $('#electure-3-21 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-20');
          pushState('3-20');
        });
      
        $('#electure-3-22 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3-22 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-21');
          pushState('3-21');
        });
      
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3-22');
          pushState('3-22');
        });
      
        $('#electure-4-1 .electure-next').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
      
        $('#electure-4-2 .electure-next').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
        $('#electure-4-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
      
        $('#electure-4-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
        $('#electure-4-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
      
        $('#electure-4-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
        $('#electure-4-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
      
        $('#electure-4-5 .electure-next').click(function() {
          hidePopup();
          runSlide('4-6');
          pushState('4-6');
        });
        $('#electure-4-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
      
        $('#electure-4-6 .electure-next').click(function() {
          hidePopup();
          runSlide('4-7');
          pushState('4-7');
        });
        $('#electure-4-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
      
        $('#electure-4-7 .electure-next').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-4-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-6');
          pushState('4-6');
        });
      
        $('#electure-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
        $('#electure-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-7');
          pushState('4-7');
        });
      
        $('#electure-5-1 .electure-next').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
        $('#electure-5-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
      
        $('#electure-5-2 .electure-next').click(function() {
          hidePopup();
          runSlide('5-3');
          pushState('5-3');
        });
        $('#electure-5-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
      
        $('#electure-5-3 .electure-next').click(function() {
          hidePopup();
          runSlide('5-4');
          pushState('5-4');
        });
        $('#electure-5-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
      
        $('#electure-5-4 .electure-next').click(function() {
          hidePopup();
          runSlide('5-5');
          pushState('5-5');
        });
        $('#electure-5-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-3');
          pushState('5-3');
        });
      
        $('#electure-5-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-6');
          pushState('5-6');
        });
        $('#electure-5-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-4');
          pushState('5-4');
        });
      
        $('#electure-5-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-5-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-5');
          pushState('5-5');
        });
      
        $('#electure-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-6');
          pushState('5-6');
        });
      
        $('#electure-6-1 .electure-next').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-6-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
      
        $('#electure-6-2 .electure-next').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-6-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
      
        $('#electure-7 .electure-next').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
      
        $('#electure-7-1 .electure-next').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
        $('#electure-7-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
      
        $('#electure-8 .electure-next').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
        $('#electure-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
      
        $('#electure-9 .electure-next').click(function() {
          hidePopup();
          runSlide('9-1');
          pushState('9-1');
        });
        $('#electure-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
      
        $('#electure-9-1 .electure-next').click(function() {
          hidePopup();
          runSlide('9-2');
          pushState('9-2');
        });
        $('#electure-9-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
      
        $('#electure-9-2 .electure-next').click(function() {
          hidePopup();
          runSlide('9-3');
          pushState('9-3');
        });
        $('#electure-9-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-1');
          pushState('9-1');
        });
      
        $('#electure-9-3 .electure-next').click(function() {
          hidePopup();
          runSlide('9-4');
          pushState('9-4');
        });
        $('#electure-9-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-2');
          pushState('9-2');
        });
      
        $('#electure-9-4 .electure-next').click(function() {
          hidePopup();
          runSlide('9-5');
          pushState('9-5');
        });
        $('#electure-9-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-3');
          pushState('9-3');
        });
      
        $('#electure-9-5 .electure-next').click(function() {
          hidePopup();
          runSlide('9-6');
          pushState('9-6');
        });
        $('#electure-9-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-4');
          pushState('9-4');
        });
      
        $('#electure-9-6 .electure-next').click(function() {
          hidePopup();
          runSlide('99');
          pushState('99');
        });
        $('#electure-9-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-5');
          pushState('9-5');
        });
      
        $('#electure-99 .electure-next').click(function() {
          hidePopup();
          runSlide('99-1');
          pushState('99-1');
        });
        $('#electure-99 .electure-prev').click(function() {
          hidePopup();
          runSlide('9-6');
          pushState('9-6');
        });
      
        $('#electure-99-1 .electure-next').click(function() {
          hidePopup();
          runSlide('99-2');
          pushState('99-2');
        });
        $('#electure-99-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('99');
          pushState('99');
        });
      
        $('#electure-99-2 .electure-next').click(function() {
          hidePopup();
          runSlide('99-3');
          pushState('99-3');
        });
        $('#electure-99-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('99-1');
          pushState('99-1');
        });
      
        $('#electure-99-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('99-2');
          pushState('99-2');
        });
      
 

        // temporary quick fix for Google Chrome Aug 2016 issue..., put at last part so that everything else has been loaded
        // setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 500);
        // setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        // I turn it off on 14 June 2018, seems 'ok'?
      });

      function doButtonAction96() {
        CUSTOM_ACTION('search','77');
      }
      function doButtonAction97() {
        CUSTOM_ACTION('search','7');
      }
      function doButtonAction98() {
        CUSTOM_ACTION('peek');
      }
      function doButtonAction99() {
        CUSTOM_ACTION('push','6');
      }
      function doButtonAction100() {
        $("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
CUSTOM_ACTION('insert_head','50');
      }
      function doButtonAction101() {
        $("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
CUSTOM_ACTION('insert_tail','10');
      }
      function doButtonAction102() {
        $("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
CUSTOM_ACTION('insert_kth','3,44');
      }
      function doButtonAction103() {
        empty();
CUSTOM_ACTION('insert_head','50');
      }
      function doButtonAction104() {
        $("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
CUSTOM_ACTION('insert_kth','6,55');
      }
      function doButtonAction105() {
        CUSTOM_ACTION('remove_head');
      }
      function doButtonAction106() {
        CUSTOM_ACTION('remove_tail');
      }
      function doButtonAction107() {
        $("#v-create-arr").val("22,2,77,6,43,76,89");
nonRandom();
CUSTOM_ACTION('remove_kth','5');
      }
      function doButtonAction108() {
        CUSTOM_ACTION('enqueue');
      }

      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();  
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url.html) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}
    </script>
<script type="text/javascript">

// List Widget
// original author: Steven Kester Yuwono, then cleaned and maintained by Steven Halim

var BACK_EDGE_CONST = 5000;

var List = function() {
  var self = this;
  var graphWidget = new GraphWidget();
  var activeStatus = "list";
  var maxSize = 10;
  var maxStackSize = 7;

  var valueRange = [1, 99]; // Range of valid values of List vertexes allowed
  var maxHeightAllowed = 10;

  var initialArray = [15, 6, 23, 4, 7, 71, 5, 50];
  var initialStackArray = [15, 6, 50, 4];

  /*
   * iL: Internal representation of List in this object
   * The keys are the text of the vertices, and the value is the attributes of the corresponding vertex encapsulated in a JS object, which are:
   * - "prev": text of the prev vertex. If the vertex is root Vertex, the value is null
   * - "next": text of the right child. No child -> null
   * - "cx": X-coordinate of center of the vertex
   * - "cy": Y-coordinate of center of the vertex
   * - "height": height of the Vertex. Height of root is 0
   * - "vtxIdx": Vertex class number of the corresponding Vertex
   *
   * In addition, there is a key called "head" in iL, containing the text of the root Vertex.
   * If List is empty, root is null.
   */

  var iL = {};
  var amountVertex = 0;
  var vertexClassNumberCounter = 9;
  iL["head"] = null;

  init(generateRandomArray(Math.floor((Math.random()*5 + 3))));

  this.setActiveStatus = function(newActiveStatus) {
    if (activeStatus != newActiveStatus) {
      clearScreen();
      activeStatus = newActiveStatus;
      init(generateRandomArray(Math.floor((Math.random()*5 + 3))));
    }
  }

  this.getActiveStatus = function() { return activeStatus; }

  this.widgetRecalculatePosition = function() { recalculatePosition(); }

  this.getGraphWidget = function() { return graphWidget; }

  /* FIRST MENU: Create */

  this.generate = function(initArr) { init(initArr); }

  function generateRandomArray(vertexAmt) {
    var initArr = new Array();
    while (initArr.length < vertexAmt) {
      var random = Math.floor(1 + Math.random()*98);
      if ($.inArray(random, initArr) < 0)
        initArr.push(random);
    }
    return initArr;
  }

  this.generateRandom = function(isSorted) {
    var initArr = generateRandomArray(Math.floor((Math.random()*5 + 3))); // [3..7]
    if (isSorted) initArr.sort(function(a, b) { return a-b; }); // sort it first
    init(initArr);
    return true;
  };

  this.generateRandomFixedSize = function(val) {
    if (activeStatus == "stack") {
      if (val > maxStackSize) {
        $('#create-err').html('Sorry, the maximum number of vertex allowed is {maxSize}'.replace("{maxSize}", maxStackSize));
        return false;
      }
    }
    else {
      if (val > maxSize) {
        $('#create-err').html('Sorry, the maximum number of vertex allowed is {maxSize}'.replace("{maxSize}", maxSize));
        return false;
      }
    }
    var initArr = generateRandomArray(val);
    init(initArr);
    return true;
  }

  this.generateUserDefined = function(vertexTextArr) {
    var vertexAmt = vertexTextArr.length;
    if (activeStatus == "stack") {
      if (vertexAmt > maxStackSize) {
        $('#create-err').html('Sorry, the maximum number of vertex allowed is {maxSize}'.replace("{maxSize}", maxStackSize));
        return false;
      }
    }
    else {
      if (vertexAmt > maxSize) {
        $('#create-err').html('Sorry, the maximum number of vertex allowed is {maxSize}'.replace("{maxSize}", maxSize));
        return false;
      }
    }

    if (vertexTextArr == '') { // prevent creation of empty list
      $('#create-err').html('Sorry, the minimum number of vertex is at least 1.');
      return false;
    }

    var initArr = new Array();
    for (i = 0; i < vertexTextArr.length; i++) {
      var vt = parseInt(vertexTextArr[i]);
      if (!isNaN(vt) && $.inArray(vt, initArr) < 0) // remove duplicates
        initArr.push(vt);
    }
    init(initArr);
    return true;
  }

  this.getA = function() {
    var theArr = [], currentVertex = iL["head"];
    while (currentVertex != null) {
      theArr.push(currentVertex);
      currentVertex = iL[currentVertex]["next"];
    }
    return theArr;
  }

  /* SECOND MENU: Search (LL, DLL) or Peek (Stack, Queue, Deque -- additional Peek back) */

  this.search = function(val, callback) {
    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = createState(iL), curVtxIdx, key, index = 0;

    if (currentVertex == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The current Linked List is empty, we return NOT_FOUND.
      cs["status"] = 'The current Linked List is empty, we return NOT_FOUND.';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      // temp = head, index = 0
      cs = createState(iL, vertexTraversed, edgeTraversed);
      curVtxIdx = iL[currentVertex]["vtxIdx"];
      cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][curVtxIdx]["extratext"] = curVtxIdx + (curVtxIdx == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/temp";
      // This is the current Linked List.
      // We want to search for value v = {val} starting from the head (index 0).
      cs["status"] = 'This is the current Linked List.<br>We want to search for value v = {val} starting from the head (index 0).'.replace("{val}", val);
      cs["lineNo"] = 2;
      stateList.push(cs);

      // while (temp.data != input)
      while (parseInt(currentVertex) != parseInt(val)) {
        vertexTraversed[currentVertex] = true;
        cs = createState(iL, vertexTraversed, edgeTraversed);
        // Comparing {currentVertex} with {val} (index = {index}).
        // {currentVertex} is not equal to {val} so we have to continue.
        cs["status"] = 'Comparing {currentVertex} (index = {index}) with v = {val}.<br>{currentVertex} is not equal to {val} so we have to continue.'.replace("{currentVertex}", currentVertex).replace("{val}", val).replace("{index}", index).replace("{currentVertex}", currentVertex).replace("{val}", val);
        cs["vl"][curVtxIdx]["extratext"] = curVtxIdx + (curVtxIdx == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/temp";
        cs["lineNo"] = 3;
        stateList.push(cs);

        // case when vertex is not found
        currentVertex = iL[currentVertex]["next"];
        if (currentVertex == null) {
          // temp = temp.next, index++
          cs = createState(iL, vertexTraversed, edgeTraversed);
          // We try advancing temp to the next vertex.
          // But...
          cs["status"] = 'We try advancing temp to the next vertex.<br>But...';
          cs["lineNo"] = 4;
          stateList.push(cs);

          // if temp == null
          //   return -1
          cs = createState(iL, vertexTraversed, edgeTraversed);
          // temp is null (we have gone past the tail after O(N) step(s)).
          // We conclude that value {val} is NOT_FOUND in the Linked List.
          cs["status"] = 'temp is null (we have gone past the tail after O(N) step(s)).<br>We conclude that value v = {val} is NOT_FOUND in the Linked List.'.replace("{val}", val);
          cs["lineNo"] = [5, 6];
          stateList.push(cs);

          break;
        }

        // temp = temp.next, index++
        // if temp == null
        curVtx = iL[currentVertex]["prev"];
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        var edgeHighlighted = iL[curVtx]["vtxIdx"];
        edgeTraversed[edgeHighlighted] = true;
        if ((activeStatus == "doublylist") || (activeStatus == "deque"))
          edgeTraversed[edgeHighlighted + BACK_EDGE_CONST] = true;
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = curVtxIdx + (curVtxIdx == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/temp";
        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
        // So temp advances to the next vertex.
        // temp is not null, continue searching.
        cs["status"] = 'So temp advances to the next vertex.<br>temp is not null, continue searching.';
        cs["lineNo"] = [4, 5];
        stateList.push(cs);

        index++;
      }

      // case when vertex is found
      if (currentVertex != null) {
        // return index
        cs = createState(iL, vertexTraversed, edgeTraversed);
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = curVtxIdx + (curVtxIdx == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/temp";
        // Found value v = {val} at this highlighted vertex so we return index {index}.
        // The whole operation is O(N).
        cs["status"] = 'Found value v = {val} at this highlighted vertex so we return index {index}.<br>The whole operation is O(N).'.replace("{val}", val).replace("{index}", index);
        cs["lineNo"] = 7;
        stateList.push(cs);
      }
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(4);
    return true;
  };

  this.peek = function(isHead, callback) {
    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = createState(iL), curVtxIdx, key, index = 0;

    if (currentVertex == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The current Linked List is empty, we return NOT_FOUND.
      cs["status"] = 'The current Linked List is empty, we return NOT_FOUND.';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      if (!isHead) {
        while (true) { // go to tail
          if (iL[currentVertex]["next"] != null) currentVertex = iL[currentVertex]["next"];
          else break;
        }
      }

      cs = createState(iL, vertexTraversed, edgeTraversed);
      curVtxIdx = iL[currentVertex]["vtxIdx"];
      cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      // Return the value stored at the head: {currentVertex}.
      cs["status"] = (isHead ? 'Return the value stored at the head: {currentVertex}.' : 'Return the value stored at the tail: {currentVertex}.').replace("{currentVertex}", currentVertex);
      cs["lineNo"] = 2;
      stateList.push(cs);
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(isHead ? 3 : 9);
    return true;
  }

  /* THIRD MENU: Insert (LL, DLL, minor differences only)/Push (Stack)/Enqueue (Queue, Deque) */

  this.insertHead = function(v, callback) {
    var val = parseInt(v);
    var tempinternalList = deepCopy(iL);

    // 1. Check whether value is number
    if (isNaN(val)) {
      // Please fill in an Integer.
      $('#insert-err').html('Please fill in an Integer.');
      return false;
    }
    // 2. No duplicates allowed. Also works if more than one similar value are inserted
    if (tempinternalList[val] != null) {
      // No duplicate vertex allowed!
      $('#insert-err').html('No duplicate vertex allowed!');
      if (typeof callback == 'function') callback();
      return false;
    }
    // 3. Check range
    if (parseInt(val) < valueRange[0] || parseInt(val) > valueRange[1]) {
      // Sorry, only values between {range0} and {range1} can be inserted.
      $('#insert-err').html('Sorry, only values between {range0} and {range1} can be inserted.'.replace("{range0}", valueRange[0]).replace("{range1}", valueRange[1]));
      return false;
    }
    // 4. check size
    if (activeStatus == "stack") {
      if (amountVertex >= maxStackSize) {
        // Sorry, the maximum size is {maxSize}.
        $('#insert-err').html('Sorry, the maximum size is {maxSize}.'.replace("{maxSize}", maxStackSize));
        return false;
      }
    }
    else {
      if (amountVertex >= maxSize) {
        // Sorry, the maximum size is {maxSize}.
        $('#insert-err').html('Sorry, the maximum size is {maxSize}.'.replace("{maxSize}", maxSize));
        return false;
      }
    }

    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;
    if (amountVertex >= 1) cs = createState(iL);
    else                   cs = {};

    // Begin insertion, first, update internal representation
    iL[parseInt(val)] = {
      "next": null,
      "vtxIdx": vertexClassNumberCounter++
    };

    // modified this part for linked list insertion
    var newVtx = parseInt(val);
    var oldHeadIdx;

    iL[newVtx]["cx"] = 50;
    iL[newVtx]["cy"] = 120;

    // if linked list is empty
    amountVertex++;
    if (amountVertex > 1) {
      var tempChild = iL["head"];
      oldHeadIdx = iL[tempChild]["vtxIdx"];
      iL[newVtx]["next"] = tempChild;
      iL[tempChild]["prev"] = newVtx;
      iL["head"] = newVtx;
    }
    else
      iL["head"] = newVtx;

    // Then, draw edge
    var newVtxIdx = iL[parseInt(val)]["vtxIdx"];

    if (amountVertex > 1) {
      // Vertex vtx = new Vertex(v)
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][newVtxIdx]["extratext"] = "vtx";
      cs["vl"][oldHeadIdx]["extratext"] = "head";
      cs["el"][newVtxIdx]["state"] = OBJ_HIDDEN;
      if ((activeStatus == "doublylist") || (activeStatus == "deque"))
        cs["el"][newVtxIdx + BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
      // Create new vertex to store value {val}.
      cs["status"] = 'Create new vertex to store value {val}.'.replace("{val}", val);
      cs["lineNo"] = 1;
      stateList.push(cs);

      // vtx.next = head
      cs = createState(iL, vertexTraversed, edgeTraversed);
      var edgeHighlighted = iL[newVtx]["vtxIdx"];
      cs["el"][edgeHighlighted]["animateHighlighted"] = true;
      cs["el"][edgeHighlighted]["state"] = EDGE_HIGHLIGHTED;
      cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][newVtxIdx]["extratext"] = "vtx";
      cs["vl"][oldHeadIdx]["extratext"] = "head";
      if ((activeStatus == "doublylist") || (activeStatus == "deque"))
        cs["el"][newVtxIdx + BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
      // Now, temp.next points to the current head.
      cs["status"] = 'Now, vtx.next points to the current head.';
      cs["lineNo"] = 2;
      stateList.push(cs);

      if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
        // if (head != null) head.prev = vtx
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][oldHeadIdx]["extratext"] = "head";
        cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][newVtxIdx]["extratext"] = "vtx";
        cs["el"][newVtxIdx+BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
        cs["el"][newVtxIdx+BACK_EDGE_CONST]["animateHighlighted"] = true;
        // (Old) head.prev points to vtx.
        cs["status"] = '(Old) head.prev points to vtx.';
        cs["lineNo"] = 3;
        stateList.push(cs);
      }
    }
    else {
      // Vertex vtx = new Vertex(v)
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][newVtxIdx]["extratext"] = "vtx";
      // Create new vertex to store value {val}.
      // But as head is currently null, temp.next remains null.
      cs["status"] = 'Create new vertex to store value {val}.'.replace("{val}", val) + '<br>But as head is currently null, temp.next remains null.';
      cs["lineNo"] = [1, 2];
      stateList.push(cs);
    }

    // head = vtx
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = "head/vtx";
    // Now, head points to vtx.
    cs["status"] = 'Now, head points to vtx.';
    if ((activeStatus == "doublylist") || (activeStatus == "deque"))
      cs["lineNo"] = 4;
    else
      cs["lineNo"] = 3;
    stateList.push(cs);

    if (amountVertex == 1) {
      // tail = head
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][newVtxIdx]["extratext"] = "head/tail/vtx";
      // Tail points to head.
      cs["status"] = 'Tail points to head.';
      cs["lineNo"] = 3;
      stateList.push(cs);
    }

    recalculatePosition();
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = "head" + (amountVertex == 1 ? "/tail" : "") + "/vtx";
    // Re-layout the Linked List for visualization.
    // The whole process is O({N}).
    cs["status"] = 'Re-layout the Linked List for visualization.<br>The whole process is O({N}).'.replace("{N}", "1");
    cs["lineNo"] = 0;
    stateList.push(cs);

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(1);
    return true;
  }

  this.insertTail = function(v, callback) {
    if (amountVertex == 0) return this.insertHead(v, callback);

    var val = parseInt(v);
    var tempinternalList = deepCopy(iL); // Use this to simulate internal insertion

    // 1. Check whether value is number
    if (isNaN(val)) {
      // Please fill in an Integer.
      $('#insert-err').html('Please fill in an Integer.');
      if (typeof callback == 'function') callback();
      return false;
    }
    // 2. No duplicates allowed. Also works if more than one similar value are inserted
    if (tempinternalList[val] != null) {
      // No duplicate vertex allowed!
      $('#insert-err').html('No duplicate vertex allowed!');
      if (typeof callback == 'function') callback();
      return false;
    }
    // 3. Check range
    if (parseInt(val) < valueRange[0] || parseInt(val) > valueRange[1]) {
      // Sorry, only values between {range0} and {range1} can be inserted.
      $('#insert-err').html('Sorry, only values between {range0} and {range1} can be inserted.'.replace("{range0}", valueRange[0]).replace("{range1}", valueRange[1]));
      if (typeof callback == 'function') callback();
      return false;
    }
    // 4. check size
    if (amountVertex >= maxSize) {
      // Sorry, the maximum size is {maxSize}.
      $('#insert-err').html('Sorry, the maximum size is {maxSize}.'.replace("{maxSize}", maxSize));
      if (typeof callback == 'function') callback();
      return false;
    }

    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;

    // Find prev
    while (currentVertex != val && currentVertex != null) {
      var nextVertex;
      nextVertex = iL[currentVertex]["next"];
      if (nextVertex == null) break;
      else                    currentVertex = nextVertex;
    }

    // Begin insertion, first, update internal representation
    var newVtx = parseInt(val);
    var oldTailIdx = iL[currentVertex]["vtxIdx"];

    iL[parseInt(val)] = {
      "next": null,
      "vtxIdx": vertexClassNumberCounter++
    };

    if (currentVertex != null) {
      iL[parseInt(val)]["prev"] = currentVertex;
      iL[currentVertex]["next"] = parseInt(val);
    }
    else {
      iL[parseInt(val)]["prev"] = null;
      iL["head"] = parseInt(val);
    }

    amountVertex++;
    recalculatePosition();

    var newVtxIdx = iL[parseInt(val)]["vtxIdx"];
    curVtxIdx = iL[currentVertex]["vtxIdx"];

    // Vertex vtx = new vertex(v)
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][newVtxIdx]["extratext"] = "vtx";
    cs["vl"][oldTailIdx]["extratext"] = "tail";
    cs["el"][curVtxIdx]["state"] = OBJ_HIDDEN;
    if ((activeStatus == "doublylist") || (activeStatus == "deque"))
      cs["el"][curVtxIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
    // Create new vertex to store value {val}.
    cs["status"] = 'Create new vertex to store value {val}.'.replace("{val}", val);
    cs["lineNo"] = 1;
    stateList.push(cs);

    // tail.next = vtx
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][newVtxIdx]["extratext"] = "vtx";
    cs["vl"][oldTailIdx]["extratext"] = "tail";
    cs["el"][curVtxIdx]["state"] = EDGE_TRAVERSED;
    cs["el"][curVtxIdx]["animateHighlighted"] = true;
    if ((activeStatus == "doublylist") || (activeStatus == "deque"))
      cs["el"][curVtxIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
    // Now vtx.next points to new vertex.
    cs["status"] = 'Now temp.next points to new vertex.';
    cs["lineNo"] = 2;
    stateList.push(cs);

    if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][curVtxIdx]["extratext"] = "tail";
      cs["vl"][newVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][newVtxIdx]["extratext"] = "vtx";
      cs["el"][curVtxIdx+BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
      cs["el"][curVtxIdx+BACK_EDGE_CONST]["animateHighlighted"] = true;
      // Update prev pointer of the new vertex to point back to the (old) tail.
      cs["status"] = 'Update prev pointer of the new vertex to point back to the (old) tail.';
      cs["lineNo"] = 2;
      stateList.push(cs);
    }

    // tail = vtx
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = "tail/vtx";
    // Now, tail points to the new vertex too.
    // The whole operation is O(1) if we maintain the tail pointer.
    cs["status"] = 'Now, tail points to the new vertex too.<br>The whole operation is O(1) if we maintain the tail pointer.';
    cs["lineNo"] = 3;
    stateList.push(cs);

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(2);
    return true;
  }

  this.insertKth = function(index, v, callback) {
    // index checking start
    if (isNaN(index)) {
      // Please fill in an Integer.
      $('#insert-err').html('Please fill in an Integer.');
      return false;
    }
    if ((index < 1) || (index > amountVertex)) {
      // Please enter a valid index between [1..{limit}].
      $('#insert-err').html('Please enter a valid index between [1..{limit}].'.replace("{limit}", Math.max(1, amountVertex-1)));
      return false;
    }

    // check if it is insertion at index 0/N i.e. insert head/tail, respectively (will no longer be used?)
    if (index == 0)            return this.insertHead(v);
    if (index == amountVertex) return this.insertTail(v);

    var val = parseInt(v);
    var tempinternalList = deepCopy(iL); // Use this to simulate internal insertion

    // 1. Check whether value is number
    if (isNaN(val)) {
      // Please fill in an Integer.
      $('#insert-err').html('Please fill in an Integer.');
      return false;
    }
    // 2. No duplicates allowed. Also works if more than one similar value are inserted
    if (tempinternalList[val] != null) {
      // No duplicate vertex allowed!
      $('#insert-err').html('No duplicate vertex allowed!');
      return false;
    }
    // 3. Check range
    if (parseInt(val) < valueRange[0] || parseInt(val) > valueRange[1]) {
      // Sorry, only values between {range0} and {range1} can be inserted.
      $('#insert-err').html('Sorry, only values between {range0} and {range1} can be inserted.'.replace("{range0}", valueRange[0]).replace("{range1}", valueRange[1]));
      return false;
    }
    // 4. check size
    if (amountVertex >= maxSize) {
      // Sorry, the maximum size is {maxSize}.
      $('#insert-err').html('Sorry, the maximum size is {maxSize}.'.replace("{maxSize}", maxSize));
      return false;
    }

    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {};
    var temp1Idx, temp2Idx, newVtxIdx;

    // Vertex prev = head
    cs = createState(iL, vertexTraversed, edgeTraversed);
    temp1Idx = iL[currentVertex]["vtxIdx"];
    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][temp1Idx]["extratext"] = "0/head/pre";
    vertexTraversed[currentVertex] = true;
    // Set prev to head.
    cs["status"] = 'Set temp1 to head.';
    cs["lineNo"] = 1;
    stateList.push(cs);

    // Find prev
    // for (k = 0; k < i; k++)
    var i = 0;
    for (var k = 0; k < index-1; k++) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      temp1Idx = iL[currentVertex]["vtxIdx"];
      cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
      vertexTraversed[currentVertex] = true;
      // Increment k, index specified has not been reached.
      // k is now: {k}.
      cs["status"] = 'Decrement k, index specified has not been reached.<br>k is now: {k}.'.replace("{k}", k);
      cs["lineNo"] = 2;
      stateList.push(cs);

      var nextVertex;
      nextVertex = iL[currentVertex]["next"];

      if (nextVertex == null) break;
      else                    currentVertex = nextVertex;

      // pre = pre.next
      curVtx = iL[currentVertex]["prev"];
      cs = createState(iL, vertexTraversed, edgeTraversed);
      var edgeHighlighted = iL[curVtx]["vtxIdx"];
      edgeTraversed[edgeHighlighted] = true;
      cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
      cs["el"][edgeHighlighted]["animateHighlighted"] = true;
      cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
      // We set prev to the next vertex.
      cs["status"] = 'We set prev to the next vertex.';
      cs["lineNo"] = 3;
      stateList.push(cs);

      i++;
    }

    if (currentVertex != null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      temp1Idx = iL[currentVertex]["vtxIdx"];
      cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
      vertexTraversed[currentVertex] = true;
      // We have found the insertion point.
      // We continue the next insertion step.
      cs["status"] = 'We have found the insertion point.<br>We continue the next insertion step.';
      cs["lineNo"] = 2;
      stateList.push(cs);
    }

    // Begin insertion, first, update internal representation
    // Vertex aft = pre.next
    var temp2Vertex = iL[currentVertex]["next"];
    temp2Idx = iL[temp2Vertex]["vtxIdx"];
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
    cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
    cs["vl"][temp2Idx]["extratext"] = (i+1) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
    cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
    cs["el"][temp1Idx]["animateHighlighted"] = true;
    edgeTraversed[temp1Idx] = true;
    // The specified index is found.
    // pre is before the insertion point and aft is the insertion point.
    cs["status"] = 'The index before insertion point is found.<br>pre is before the insertion point and aft is the insertion point.';
    cs["lineNo"] = 4;
    stateList.push(cs);

    iL[parseInt(val)] = {
      "next": null,
      "vtxIdx": vertexClassNumberCounter++
    };
    amountVertex++;
    //modified this part for linked list insertion
    var newVtx = parseInt(val);
    newVtxIdx = iL[parseInt(val)]["vtxIdx"];
    var tempChild;

    iL[newVtx]["cx"] = iL[temp2Vertex]["cx"];
    iL[newVtx]["cy"] = iL[temp2Vertex]["cy"] + 70;

    // vertex vtx = new Vertex(v)
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
    cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
    cs["vl"][temp2Idx]["extratext"] = (i+1) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = "vtx";
    // Create new vertex to store value {val}.
    cs["status"] = 'Create new vertex to store value {val}.'.replace("{val}", val);
    cs["lineNo"] = 5;
    stateList.push(cs);
    edgeTraversed[newVtxIdx] = true;

    // RELINK THE POINTERs
    iL[newVtx]["next"] = temp2Vertex;
    iL[temp2Vertex]["prev"] = newVtx;

    // vtx.next = aft
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
    cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
    cs["vl"][temp2Idx]["extratext"] = (i+1) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = "vtx";
    cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
    cs["el"][newVtxIdx]["state"] = EDGE_GREEN;
    cs["el"][newVtxIdx]["animateHighlighted"] = true;
    if ((activeStatus == "doublylist") || (activeStatus == "deque"))
      cs["el"][newVtxIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
    // v.next points to aft.
    cs["status"] = 'vtx.next points to aft.';
    cs["lineNo"] = 6;
    stateList.push(cs);

    // aft.prev = v (for DLL and deque)
    if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
      cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
      cs["vl"][temp2Idx]["extratext"] = (i+1) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
      cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][newVtxIdx]["extratext"] = "vtx";
      cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
      cs["el"][newVtxIdx]["state"] = EDGE_GREEN;
      cs["el"][newVtxIdx+BACK_EDGE_CONST]["state"] = EDGE_GREEN;
      cs["el"][temp1Idx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
      // aft.prev points to vtx.
      cs["status"] = 'aft.prev points to vtx.';
      cs["lineNo"] = 6;
      stateList.push(cs);
    }

    iL[currentVertex]["next"] = newVtx;
    iL[newVtx]["prev"] = currentVertex;

    // pre.next = vtx
    cs = createState(iL, vertexTraversed, edgeTraversed);
    cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
    cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
    cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
    cs["vl"][temp2Idx]["extratext"] = (i+2) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = (i+1) + "/vtx";
    cs["el"][newVtxIdx]["state"] = EDGE_GREEN;
    cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
    if ((activeStatus == "doublylist") || (activeStatus == "deque"))
      cs["el"][temp1Idx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
    // pre.next points to vtx.
    cs["status"] = 'pre.next points to vtx.';
    cs["lineNo"] = 7;
    stateList.push(cs);

    // vtx.prev = pre
    if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][temp1Idx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][temp1Idx]["extratext"] = i + (i == 0 ? "/head" : (iL[currentVertex]["next"] == null ? "/tail" : "")) + "/pre";
      cs["vl"][temp2Idx]["state"] = VERTEX_BLUE_FILL;
      cs["vl"][temp2Idx]["extratext"] = (i+2) + (i+1 == 0 ? "/head" : (iL[temp2Vertex]["next"] == null ? "/tail" : "")) + "/aft";
      cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][newVtxIdx]["extratext"] = temp2Idx + "/vtx";
      cs["el"][temp1Idx]["state"] = EDGE_TRAVERSED;
      cs["el"][temp1Idx+BACK_EDGE_CONST]["state"] = EDGE_TRAVERSED;
      // vtx.prev points to pre.
      cs["status"] = 'vtx.prev points to pre.';
      cs["lineNo"] = 7;
      stateList.push(cs);
    }

    recalculatePosition();
    cs = createState(iL, {}, {});
    cs["vl"][newVtxIdx]["state"] = VERTEX_GREEN_FILL;
    cs["vl"][newVtxIdx]["extratext"] = (i+1) + "/vtx";
    // Re-layout the Linked List for visualization.
    // The whole process is O({N}).
    cs["status"] = 'Re-layout the Linked List for visualization.<br>The whole process is O({N}).'.replace("{N}", "N");
    cs["lineNo"] = 0;
    stateList.push(cs);

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(0);
    return true;
  }

  /* FOURTH MENU: Remove */

  this.removeHead = function(callback) {
    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;

    if (currentVertex == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The Linked List is already empty.
      // No action is performed.
      cs["status"] = 'The Linked List is already empty.<br>No action is performed.';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      if (iL[currentVertex]["next"] == null) { // head has no next vertex
        // temp = head
        cs = createState(iL, vertexTraversed, edgeTraversed);
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        // The head is the only vertex in this List.
        cs["status"] = 'The head is the only vertex in this List.';
        cs["lineNo"] = 2;
        stateList.push(cs);

        // head = head.next
        cs = createState(iL, vertexTraversed, edgeTraversed);
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        // Head points to next (which is null).
        cs["status"] = 'Head points to next (which is null).';
        cs["lineNo"] = 3;
        stateList.push(cs);

        curVtxIdx = iL[currentVertex]["vtxIdx"];

        // delete temp
        iL["head"] = null;
        delete iL[currentVertex];
        delete vertexTraversed[currentVertex];
        delete edgeTraversed[curVtxIdx];

        cs = createState(iL, vertexTraversed, edgeTraversed);
        // Remove head vertex.
        // We now have an empty List.
        cs["status"] = 'Remove head vertex.<br>We now have an empty List.';
        cs["lineNo"] = 4;
        stateList.push(cs);
      }
      else { // head has next vertex
        // temp = head
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = "head/temp";
        // The head has a next vertex.
        cs["status"] = 'The head has a next vertex.';
        cs["lineNo"] = 2;
        stateList.push(cs);

        var rightChildVertex = iL[currentVertex]["next"];
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        nextVtxIdx = iL[rightChildVertex]["vtxIdx"];

        // head = head.next
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = "temp";
        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
        cs["vl"][nextVtxIdx]["extratext"] = "head";
        cs["el"][curVtxIdx]["state"] = EDGE_GREEN;
        cs["el"][curVtxIdx]["animateHighlighted"] = true;
        // head points to the next vertex.
        cs["status"] = 'head points to the next vertex.';
        cs["lineNo"] = 3;
        stateList.push(cs);

        iL["head"] = rightChildVertex;
        iL[rightChildVertex]["prev"] = null;

        // delete temp
        delete iL[currentVertex];
        delete vertexTraversed[currentVertex];
        delete edgeTraversed[curVtxIdx];
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
        // Delete temp = (previous) head.
        cs["status"] = 'Delete temp = (previous) head.';
        cs["lineNo"] = 4;
        stateList.push(cs);

        if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
          // head.prev = null
          cs = createState(iL, vertexTraversed, edgeTraversed);
          cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
          // Set head.prev to null for consistency purpose.
          cs["status"] = 'Set head.prev to null for consistency purpose.';
          cs["lineNo"] = 5;
          stateList.push(cs);
        }

        // relayout
        amountVertex--;
        recalculatePosition(); // this line triggers some D3.js errors although OK? find the root cause?
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
        if (amountVertex == 1) cs["vl"][nextVtxIdx]["extratext"] = "head/tail";
        // Re-layout the Linked List for visualization.
        // The whole process is O({N}).
        cs["status"] = 'Re-layout the Linked List for visualization.<br>The whole process is O({N}).'.replace("{N}", "1");
        stateList.push(cs);
      }
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(5);
    return true;
  }

  this.removeTail = function(callback) {
    if (amountVertex == 1) return this.removeHead(callback); // special case

    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {}, curVtxIdx;

    if (currentVertex == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The Linked List is already empty.
      // No action is performed.
      cs["status"] = 'The Linked List is already empty.<br>No action is performed.';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      var nextVertex = iL[currentVertex]["next"], nextVtxIdx;

      // Vertex pre = head
      cs = createState(iL, vertexTraversed, edgeTraversed);
      curVtxIdx = iL[currentVertex]["vtxIdx"];
      cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][curVtxIdx]["extratext"] = "head/pre";
      // Set up pre pointer.
      // pre will eventually point to the last vertex before tail.
      cs["status"] = 'Set up pre pointer.<br>pre will eventually point to the last vertex before tail.';
      cs["lineNo"] = 2;
      stateList.push(cs);

      // temp = head.next
      cs = createState(iL, vertexTraversed, edgeTraversed);
      curVtxIdx = iL[currentVertex]["vtxIdx"];
      cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][curVtxIdx]["extratext"] = "head/pre";
      nextVtxIdx = iL[nextVertex]["vtxIdx"];
      cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][nextVtxIdx]["extratext"] = (iL[nextVertex]["next"] == null ? "tail/" : "") + "temp";
      cs["el"][curVtxIdx]["animateHighlighted"] = true;
      cs["el"][curVtxIdx]["state"] = EDGE_TRAVERSED;
      // Set up temp pointer.
      // temp will eventually point to the current tail.
      cs["status"] = 'Set up temp pointer.<br>temp will eventually point to the current tail.';
      cs["lineNo"] = 3;
      stateList.push(cs);

      // Find vertex
      var i = 0;
      while (true) {
        cs = createState(iL, vertexTraversed, edgeTraversed);
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = (i == 0 ? "head/" : "") + "pre";
        nextVtxIdx = iL[nextVertex]["vtxIdx"];
        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
        cs["vl"][nextVtxIdx]["extratext"] = (iL[nextVertex]["next"] == null ? "tail/" : "") + "temp";
        vertexTraversed[currentVertex] = true;
        // Check if temp.next is null.
        cs["status"] = 'Check if temp.next is null.';
        cs["lineNo"] = 4;
        stateList.push(cs);

        if (iL[nextVertex]["next"] != null) {
          nextVertex = iL[nextVertex]["next"];
          currentVertex = iL[currentVertex]["next"];
          i++;
        }
        else
          break;

        // pre = pre.next, temp = temp.next
        cs = createState(iL, vertexTraversed, edgeTraversed);
        curVtxIdx = iL[currentVertex]["vtxIdx"];
        cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][curVtxIdx]["extratext"] = (i == 0 ? "head/" : "") + "pre";
        nextVtxIdx = iL[nextVertex]["vtxIdx"];
        cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
        cs["vl"][nextVtxIdx]["extratext"] = (iL[nextVertex]["next"] == null ? "tail/" : "") + "temp";
        vertexTraversed[currentVertex] = true;
        curVtx = iL[currentVertex]["prev"];
        var edgeHighlighted = iL[curVtx]["vtxIdx"];
        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
        edgeTraversed[edgeHighlighted] = true;
        var edgeHighlighted2 = iL[currentVertex]["vtxIdx"];
        cs["el"][edgeHighlighted2]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted2]["state"] = EDGE_GREEN;
        // It is not null.
        // So both pre and temp pointers advance to their next vertex.
        cs["status"] = 'It is not null.<br>So both pre and temp pointers advance to their next vertex.';
        cs["lineNo"] = 5;
        stateList.push(cs);
      }

      // pre.next = null
      cs = createState(iL, vertexTraversed, edgeTraversed);
      curVtxIdx = iL[currentVertex]["vtxIdx"];
      nextVtxIdx = iL[nextVertex]["vtxIdx"];
      cs["el"][curVtxIdx]["state"] = OBJ_HIDDEN;
      cs["vl"][curVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][curVtxIdx]["extratext"] = (i == 0 ? "head/" : "") + "pre";
      nextVtxIdx = iL[nextVertex]["vtxIdx"];
      cs["vl"][nextVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][nextVtxIdx]["extratext"] = "tail/temp";
      vertexTraversed[currentVertex] = true;
      // It is null.
      // So set the next of pre (the new tail) to null.
      cs["status"] = 'It is null.<br>So set the next of pre (the new tail) to null.';
      cs["lineNo"] = 6;
      stateList.push(cs);

      var curVtx = iL[nextVertex]["prev"];
      if (curVtx != null) iL[curVtx]["next"] = null;
      else                iL["head"] = null;

      // delete temp, tail = pre
      delete iL[nextVertex];
      delete vertexTraversed[nextVertex];
      delete edgeTraversed[nextVtxIdx];

      amountVertex--;

      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
      if (amountVertex == 1) cs["vl"][curVtxIdx]["extratext"] = "head/tail";
      // Delete temp (the previous tail) then update the tail pointer to prev (the current tail). The whole process is O(N) just to find the pre pointer.
      cs["status"] = 'Delete temp (the previous tail) then update the tail pointer to pre (the current tail). The whole process is O(N) just to find the pre pointer.';
      cs["lineNo"] = 7;
      stateList.push(cs);
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(6);
    return true;
  }

  this.removeTailDLL = function(callback) {
    if (amountVertex == 1) return this.removeHead(callback);

    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, currentVertex = iL["head"], cs = {};

    if (currentVertex == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The Linked List is already empty.
      // No action is performed.
      cs["status"] = 'The Linked List is already empty.<br>No action is performed.';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      var nextVertex = iL[currentVertex]["next"];
      var curVtxIdx, nextVtxIdx;

      // Find tail vertex
      while (true) {
        if (iL[nextVertex]["next"] != null) {
          nextVertex = iL[nextVertex]["next"];
          currentVertex = iL[currentVertex]["next"];
        }
        else
          break;
      }

      curVtxIdx = iL[currentVertex]["vtxIdx"];
      nextVtxIdx = iL[nextVertex]["vtxIdx"];

      // temp = tail
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][nextVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][nextVtxIdx]["extratext"] = "tail/temp";
      // Set temp to (old) tail.
      cs["status"] = 'Set temp to (old) tail.';
      cs["lineNo"] = 2;
      stateList.push(cs);

      // tail = tail.prev
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][nextVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][nextVtxIdx]["extratext"] = "temp";
      cs["el"][curVtxIdx + BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
      cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][curVtxIdx]["extratext"] = "tail";
      // Set tail to tail.prev
      cs["status"] = 'Set tail to tail.prev';
      cs["lineNo"] = 3;
      stateList.push(cs);

      // tail.next = null
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][curVtxIdx]["extratext"] = "tail";
      cs["vl"][nextVtxIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][nextVtxIdx]["extratext"] = "temp";
      cs["el"][curVtxIdx]["state"] = OBJ_HIDDEN;
      vertexTraversed[currentVertex] = true;
      // Set the next of (new) tail to null.
      cs["status"] = 'Set the next of (new) tail to null.';
      cs["lineNo"] = 4;
      stateList.push(cs);

      var curVtx = iL[nextVertex]["prev"];
      if (curVtx != null) iL[curVtx]["next"] = null;
      else                iL["head"] = null;

      delete iL[nextVertex];
      delete vertexTraversed[nextVertex];
      delete edgeTraversed[nextVtxIdx];

      amountVertex--;

      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][curVtxIdx]["state"] = VERTEX_GREEN_FILL;
      if (amountVertex == 1) cs["vl"][curVtxIdx]["extratext"] = "head/tail";
      // Delete temp.
      // The whole operations is just O(1) as we can access (old) tail.prev.
      cs["status"] = 'Delete temp.<br>The whole operations is just O(1) as we can access (old) tail.prev.';
      cs["lineNo"] = 5;
      stateList.push(cs);
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(8);
    return true;
  }

  this.removeKth = function(v, callback) {
    var index = parseInt(v);

    // Check whether value is number
    if (isNaN(index)) {
      $('#remove-err').html('Please fill in an Integer.');
      return false;
    }
    if (amountVertex < 3) {
      // This operation only works for N bigger than 2.
      $('#remove-err').html('This operation only works for N bigger than 2.');
      return false;
    }
    if ((index < 1) || (index >= amountVertex-1)) {
      // Please enter a valid index between [1..{limit}].
      $('#remove-err').html('Please enter a valid index between [1..{limit}].'.replace("{limit}", Math.max(1, amountVertex-2)));
      return false;
    }

    if (index == 0) return this.removeHead(); // not going to be executable
    if (index == amountVertex-1) {
      if (this.getActiveStatus() == "doublylist") return this.removeTailDLL();
      else                                        return this.removeTail();
    }

    var stateList = [], vertexTraversed = {}, edgeTraversed = {}, prevVtx = iL["head"], delVtx, afterVtx, cs = {};
    var prevIdx, delIdx, afterIdx;

    if (prevVtx == null) {
      cs = createState(iL, vertexTraversed, edgeTraversed);
      // The Linked List is already empty.
      // No action is performed.
      cs["status"] = 'The Linked List is already empty.<br>No action is performed.';
      cs["lineNo"] = 1;
      stateList.push(cs);
    }
    else {
      // Vertex pre = head
      prevIdx = iL[prevVtx]["vtxIdx"];
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][prevIdx]["extratext"] = "0/head/pre";
      // Set prev to head.
      // Pointer prev will stop at one vertex before the deleted vertex.
      cs["status"] = 'Set prev to head.<br>Pointer prev will stop at one vertex before the deleted vertex.';
      cs["lineNo"] = 2;
      stateList.push(cs);

      // Find vertex
      for (i = 0; i < index-1; i++) {
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][prevIdx]["extratext"] = i + (i == 0 ? "/head" : "") + "/pre";
        vertexTraversed[prevVtx] = true;
        // Index specified has not been reached.
        // k = {k}.
        cs["status"] = 'Index specified has not been reached.<br>k = {i}.'.replace("{k}", i);
        cs["lineNo"] = 3;
        stateList.push(cs);

        // important assignment
        var edgeHighlighted = iL[prevVtx]["vtxIdx"]; // before moving
        prevVtx = iL[prevVtx]["next"];
        prevIdx = iL[prevVtx]["vtxIdx"];

        // pre = pre.next
        cs = createState(iL, vertexTraversed, edgeTraversed);
        cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
        cs["vl"][prevIdx]["extratext"] = (i+1) + "/pre";
        edgeTraversed[edgeHighlighted] = true;
        cs["el"][edgeHighlighted]["animateHighlighted"] = true;
        cs["el"][edgeHighlighted]["state"] = EDGE_TRAVERSED;
        // Pointer prev advances to the next vertex.
        cs["status"] = 'Pointer prev advances to the next vertex.';
        cs["lineNo"] = 4;
        stateList.push(cs);
      }

      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][prevIdx]["extratext"] = i + "/pre";
      vertexTraversed[prevVtx] = true;
      // k is 0, prev now points to one vertex behind the vertex to-be-deleted.
      // We stop searching and continue with the removal.
      cs["status"] = 'k is 0, prev now points to one vertex behind the vertex to-be-deleted.<br>We stop searching and continue with the removal.';
      cs["lineNo"] = 3;
      stateList.push(cs);

      var delVertex = iL[prevVtx]["next"];
      delIdx = iL[delVertex]["vtxIdx"];
      var afterVertex = iL[delVertex]["next"];
      afterIdx = iL[afterVertex]["vtxIdx"];

      // Vertex del = prev.next
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][prevIdx]["extratext"] = i + "/pre";
      cs["vl"][delIdx]["state"] = VERTEX_RED_FILL;
      cs["vl"][delIdx]["extratext"] = (i+1) + "/del";
      cs["vl"][afterIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][afterIdx]["extratext"] = (i+2) + "/aft";
      edgeTraversed[prevIdx] = edgeTraversed[delIdx] = true;
      cs["el"][prevIdx]["animateHighlighted"] = cs["el"][delIdx]["animateHighlighted"] = true;
      cs["el"][prevIdx]["state"] = EDGE_HIGHLIGHTED;
      cs["el"][delIdx]["state"] = EDGE_RED;
      if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
        cs["el"][prevIdx+BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
        cs["el"][delIdx+BACK_EDGE_CONST]["state"] = EDGE_RED;
      }
      vertexTraversed[prevVtx] = true;
      // We store reference to the vertex to-be-deleted.
      // We also store reference to the vertex after the to-be-deleted vertex.
      cs["status"] = 'We store reference to the vertex to-be-deleted.<br>We also store reference to the vertex after the to-be-deleted vertex.';
      cs["lineNo"] = 5;
      stateList.push(cs);

      // prev.next = after, after.prev = prev (for DLL and deque)
      iL[delVertex]["cy"] = 50+iL[delVertex]["cy"];
      iL[prevVtx]["next"] = afterVertex;
      iL[afterVertex]["prev"] = prevVtx;

      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][prevIdx]["extratext"] = i + "/pre";
      cs["vl"][delIdx]["state"] = VERTEX_RED_FILL;
      cs["vl"][delIdx]["extratext"] = "del";
      cs["vl"][afterIdx]["state"] = VERTEX_GREEN_FILL;
      cs["vl"][afterIdx]["extratext"] = (i+1) + "/aft";
      cs["el"][prevIdx]["animateHighlighted"] = true;
      cs["el"][prevIdx]["state"] = EDGE_HIGHLIGHTED;
      if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
        cs["el"][prevIdx+BACK_EDGE_CONST]["state"] = EDGE_HIGHLIGHTED;
        cs["el"][delIdx+BACK_EDGE_CONST]["state"] = OBJ_HIDDEN;
      }
      // We connect the vertex behind the vertex to-be-deleted (pointer prev) with the next vertex after the vertex to-be-deleted (pointer after).
      cs["status"] = 'We connect the vertex behind the vertex to-be-deleted (pointer prev) with the next vertex after the vertex to-be-deleted (pointer after).';
      cs["lineNo"] = 6;
      stateList.push(cs);

      // delete temp
      delete iL[delVertex];
      delete vertexTraversed[delVertex];
      delete edgeTraversed[delIdx];
      cs = createState(iL, vertexTraversed, edgeTraversed);
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][afterIdx]["state"] = VERTEX_GREEN_FILL;
      // Now we delete this vertex.
      cs["status"] = 'Now we delete this vertex.';
      cs["lineNo"] = 7;
      stateList.push(cs);
      amountVertex--;

      // relayout list
      recalculatePosition();
      cs = createState(iL, {}, {});
      cs["vl"][prevIdx]["state"] = VERTEX_HIGHLIGHTED;
      cs["vl"][afterIdx]["state"] = VERTEX_GREEN_FILL;
      if (amountVertex == 1) cs["vl"][afterIdx]["extratext"] = "head/tail";
      // Re-layout the Linked List for visualization.
      // The whole process is O({N}).
      cs["status"] = 'Re-layout the Linked List for visualization.<br>The whole process is O({N}).'.replace("{N}", "N");
      stateList.push(cs);
    }

    graphWidget.startAnimation(stateList, callback);
    populatePseudocode(7);
    return true;
  }

  function init(initArr) {
    amountVertex = 0;
    clearScreen();

    for (var i = 0; i < initArr.length; i++) {
      var curVtx = iL["head"];
      var newVtx = parseInt(initArr[i]);

      if (curVtx == null) {
        iL["head"] = parseInt(newVtx);
        iL[newVtx] = {
          "prev": null,
          "next": null,
          "vtxIdx": amountVertex
        };
      }
      else {
        while (true) { // go to tail
          if (iL[curVtx]["next"] == null) break;
          curVtx = iL[curVtx]["next"];
        }
        iL[curVtx]["next"] = newVtx;
        iL[newVtx] = {
          "prev": curVtx,
          "next": null,
          "vtxIdx": amountVertex
        }
      }

      amountVertex++;
    }

    recalculatePosition();

    for (key in iL) {
      if (key == "head") continue;
      graphWidget.addVertex(iL[key]["cx"], iL[key]["cy"], key, iL[key]["vtxIdx"], true, (iL["head"] == key ? "head" : (iL[key]["next"] == null ? "tail" : ""))); // iL[key]["vtxIdx"] + 
    }

    for (key in iL) {
      if (key == "head") continue;
      if (key == iL["head"]) continue;
      var curVtx = iL[key]["prev"];

      graphWidget.addEdge(iL[curVtx]["vtxIdx"], iL[key]["vtxIdx"], iL[curVtx]["vtxIdx"], EDGE_TYPE_DE, 1, true);
      if ((activeStatus == "doublylist") || (activeStatus == "deque"))
        graphWidget.addEdge(iL[key]["vtxIdx"], iL[curVtx]["vtxIdx"], iL[curVtx]["vtxIdx"]+BACK_EDGE_CONST, EDGE_TYPE_DE, 1, true);
    }
  }

  function clearScreen() {
    var key;

    for (key in iL) {
      if (key == "head") continue;
      graphWidget.removeEdge(iL[key]["vtxIdx"] + BACK_EDGE_CONST);
      graphWidget.removeEdge(iL[key]["vtxIdx"]);
    }

    for (key in iL) {
      if (key == "head") continue;
      graphWidget.removeVertex(iL[key]["vtxIdx"]);
    }

    iL = {};
    iL["head"] = null;
    amountVertex = 0;
  }

  this.getN = function() {
    return amountVertex;
  }

  /*
   * iLObject: a JS object with the same structure of iL. This means the List doen't have to be the List stored in this class
   * vertexTraversed: JS object with the vertexes of the List which are to be marked as traversed as the key
   * edgeTraversed: JS object with the edges of the List which are to be marked as traversed as the key
   */

  function createState(iLObject, vertexTraversed, edgeTraversed) {
    if (vertexTraversed == null || vertexTraversed == undefined || !(vertexTraversed instanceof Object))
      vertexTraversed = {};
    if (edgeTraversed == null || edgeTraversed == undefined || !(edgeTraversed instanceof Object))
      edgeTraversed = {};

    var state = {
      "vl": {},
      "el": {}
    };
    var key;

    for (key in iLObject) {
      if (key == "head") continue;

      idx = iLObject[key]["vtxIdx"];

      state["vl"][idx] = {};
      state["vl"][idx]["cx"] = iLObject[key]["cx"];
      state["vl"][idx]["cy"] = iLObject[key]["cy"];
      state["vl"][idx]["text"] = key;
      state["vl"][idx]["state"] = VERTEX_DEFAULT;

      if (iLObject[key]["next"] == null) continue;

      parentChildEdgeId = iLObject[key]["vtxIdx"];

      state["el"][parentChildEdgeId] = {};

      state["el"][parentChildEdgeId]["vertexA"] = iLObject[key]["vtxIdx"];
      state["el"][parentChildEdgeId]["vertexB"] = iLObject[iLObject[key]["next"]]["vtxIdx"];
      state["el"][parentChildEdgeId]["type"] = EDGE_TYPE_DE;
      state["el"][parentChildEdgeId]["weight"] = 1;
      state["el"][parentChildEdgeId]["state"] = EDGE_DEFAULT;
      state["el"][parentChildEdgeId]["animateHighlighted"] = false;

      // add an edge for doubly linked list
      if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
        parentChildEdgeId = iLObject[key]["vtxIdx"]+BACK_EDGE_CONST;
        state["el"][parentChildEdgeId] = {};

        state["el"][parentChildEdgeId]["vertexA"] = iLObject[iLObject[key]["next"]]["vtxIdx"];
        state["el"][parentChildEdgeId]["vertexB"] = iLObject[key]["vtxIdx"];
        state["el"][parentChildEdgeId]["type"] = EDGE_TYPE_DE;
        state["el"][parentChildEdgeId]["weight"] = 1;
        state["el"][parentChildEdgeId]["state"] = EDGE_DEFAULT;
        state["el"][parentChildEdgeId]["animateHighlighted"] = false;
      }
    }

    var cur = iLObject["head"], idx = 0;
    while (cur != null) {
      curIdx = iLObject[cur]["vtxIdx"];
      // state["vl"][curIdx]["extratext"] = idx;
           if (idx == 0)                      state["vl"][curIdx]["extratext"] = "head";
      else if (iLObject[cur]["next"] == null) state["vl"][curIdx]["extratext"] = "tail";
      cur = iLObject[cur]["next"];
      idx++;
    }

    for (key in vertexTraversed) {
      idx = iLObject[key]["vtxIdx"];
      state["vl"][idx]["state"] = VERTEX_TRAVERSED;
    }

    for (key in edgeTraversed) {
      state["el"][key]["state"] = EDGE_TRAVERSED;
      if (state["el"][key+BACK_EDGE_CONST] != null) state["el"][key+BACK_EDGE_CONST] = EDGE_TRAVERSED;
    }

    return state;
  }

  // modified recalculateposition
  function recalculatePosition() {
    updatePosition(iL["head"]);

    function updatePosition(currentVertex) {
      if (currentVertex == null) return;

      if (activeStatus == "stack") { // relayout vertical
        if (currentVertex == iL["head"])
          iL[currentVertex]["cy"] = 20;
        else {
          var curVtx = iL[currentVertex]["prev"]
          iL[currentVertex]["cy"] = iL[curVtx]["cy"] + 70;
        }
        iL[currentVertex]["cx"] = 350;
      }
      else { // relayout horizontal
        if (currentVertex == iL["head"])
          iL[currentVertex]["cx"] = 50;
        else {
          var curVtx = iL[currentVertex]["prev"];
          iL[currentVertex]["cx"] = iL[curVtx]["cx"] + 80;
        }
        iL[currentVertex]["cy"] = 50;
      }

      updatePosition(iL[currentVertex]["next"]);
    }
  }

  function populatePseudocode(act) {
    switch (act) {
      case 4: // search
        $('#code1').html('if empty, return NOT_FOUND');
        $('#code2').html('index = 0, temp = head');
        $('#code3').html('while (temp.item != v)');
        $('#code4').html('&nbsp&nbsp' + 'index++, temp = temp.next');
        $('#code5').html('&nbsp&nbspif temp == null');
        $('#code6').html('&nbsp&nbsp&nbsp&nbspreturn NOT_FOUND');
        $('#code7').html('return index');
        break;
      case 3: // peek
        $('#code1').html('if empty, return NOT_FOUND');
        $('#code2').html('return head.item');
        $('#code3').html('');
        $('#code4').html('');
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 9: // peek back
        $('#code1').html('if empty, return NOT_FOUND');
        $('#code2').html('return tail.item');
        $('#code3').html('');
        $('#code4').html('');
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;

      case 1: // insertHead
        $('#code1').html('Vertex vtx = new Vertex(v)');
        $('#code2').html('vtx.next = head');
        if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
          $('#code3').html('if (head != null) head.prev = temp');
          if (amountVertex == 1)
            $('#code4').html('head = vtx, tail = head');
          else
            $('#code4').html('head = vtx');
        }
        else if (amountVertex == 1) {
          $('#code3').html('head = vtx, tail = head');
          $('#code4').html('');
        }
        else {
          $('#code3').html('head = vtx');
          $('#code4').html('');
        }
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 2: // insertTail
        $('#code1').html('Vertex vtx = new Vertex(v)');
        if ((activeStatus == "doublylist") || (activeStatus == "deque"))
          $('#code2').html('tail.next = temp, temp.prev = tail');
        else
          $('#code2').html('tail.next = vtx');
        $('#code3').html('tail = vtx');
        $('#code4').html('');
        $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 0: // Insert
        $('#code1').html('Vertex pre = head');
        $('#code2').html('for (k = 0; k < i-1; k++)');
        $('#code3').html('&nbsp&nbsp' + 'pre = pre.next');
        $('#code4').html('Vertex aft = pre.next');
        $('#code5').html('Vertex vtx = new Vertex(v)');
        if ((activeStatus == "doublylist") || (activeStatus == "deque")) {
          $('#code6').html('vtx.next = aft, aft.prev = vtx');
          $('#code7').html('pre.next = vtx, vtx.prev = pre');
        }
        else {
          $('#code6').html('vtx.next = aft');
          $('#code7').html('pre.next = vtx');
        }
        break;

      case 5: // remove head
        $('#code1').html('if empty, do nothing');
        $('#code2').html('temp = head');
        $('#code3').html('head = head.next');
        $('#code4').html('delete temp');
        if ((activeStatus == "doublylist") || (activeStatus == "deque"))
          $('#code5').html('if (head != null) head.prev = null');
        else
          $('#code5').html('');
        $('#code6').html('');
        $('#code7').html('');
        break;
      case 6: // remove tail (SLL)
        $('#code1').html('if empty, do nothing');
        $('#code2').html('Vertex pre = head');
        $('#code3').html('temp = head.next');
        $('#code4').html('while (temp.next != null)');
        $('#code5').html('&nbsp&nbsp' + 'pre = pre.next');
        $('#code6').html('pre.next = null');
        $('#code7').html('delete temp, tail = pre');
        break;
      case 7: // remove kth
        $('#code1').html('if empty, do nothing');
        $('#code2').html('Vertex pre = head');
        $('#code3').html('for (k = 0; k < i-1; k++)');
        $('#code4').html('&nbsp&nbsp' + 'pre = pre.next');
        $('#code5').html('Vertex del = pre.next, aft = del.next');
        if ((activeStatus == "doublylist") || (activeStatus == "deque"))
          $('#code6').html('pre.next = aft, aft.prev = pre');
        else
          $('#code6').html('pre.next = aft // bypass del');
        $('#code7').html('delete del');
        break;
      case 8: // remove tail (DLL, easier)
        $('#code1').html('if empty, do nothing');
        $('#code2').html('temp = tail');
        $('#code3').html('tail = tail.prev');
        $('#code4').html('tail.next = null');
        $('#code5').html('delete temp');
        $('#code6').html('');
        $('#code7').html('');
        break;
    }
  }
}



// List actions
// actions panel stuff
var actionsWidth = 150;
var statusCodetraceWidth = 420;
var isCreateOpen = false, isSearchOpen = false, isInsertOpen = false, isRemoveOpen = false;

function openCreate() {
  $(".create").css("bottom","146px");
  $('#createfixedsize-input').hide();
  $('#createuserdefined-input').hide();
  if (!isCreateOpen) {
    $('.create').fadeIn('fast');
    isCreateOpen = true;
  }
}

function closeCreate() {
  if (isCreateOpen) {
    $('.create').fadeOut('fast');
    $('#create-err').html("");
    isCreateOpen = false;
  }
}

function openSearch() {
  if (!isSearchOpen) {
    $('.search').fadeIn('fast');
    isSearchOpen = true;
  }
}

function closeSearch() {
  if (isSearchOpen) {
    $('.search').fadeOut('fast');
    $('#search-err').html("");
    isSearchOpen = false;
  }
}

function openInsert() {
  $(".insert").css("bottom","92px");
  $('#insertkth-input').hide();
  $('#inserthead-input').hide();
  $('#inserttail-input').hide();
  if (!isInsertOpen) {
    $('.insert').fadeIn('fast');
    isInsertOpen = true;
  }
}

function closeInsert() {
  if(isInsertOpen) {
    $('.insert').fadeOut('fast');
    $('#insert-err').html("");
    isInsertOpen = false;
  }
}

function openRemove() {
  $(".remove").css("bottom","65px");
  $('#removekth-input').hide();
  if (!isRemoveOpen) {
    $('.remove').fadeIn('fast');
    isRemoveOpen = true;
  }
}

function closeRemove() {
  if (isRemoveOpen) {
    $('.remove').fadeOut('fast');
    $('#remove-err').html("");
    isRemoveOpen = false;
  }
}

function hideEntireActionsPanel() {
  closeCreate();
  closeSearch();
  closeInsert();
  closeRemove();
  hideActionsPanel();
}



// local
// title changing
function SOP() {
  if (isPlaying) stop();
  showActionsPanel();
  hideStatusPanel();
  hideCodetracePanel();
  $("#title-LL").text("LL");
  $("#title-DLL").text("DLL");
}

$('#title-LL').click(function() {
  SOP();
  displayList();
  changeTextList();
  lw.setActiveStatus("list");
  $("#title-LL").text('Danh sách liên kết');
});

$('#title-Stack').click(function() {
  SOP();
  displayStack();
  changeTextStack();
  lw.setActiveStatus("stack");
});

$('#title-Queue').click(function() {
  SOP();
  displayQueue();
  changeTextQueue();
  lw.setActiveStatus("queue");
});

$('#title-DLL').click(function() {
  SOP();
  displayList();
  changeTextDoublyList();
  lw.setActiveStatus("doublylist");
  $("#title-DLL").text('Doubly Linked List');
});

$('#title-Deque').click(function() {
  SOP();
  displayDeque();
  changeTextDeque();
  lw.setActiveStatus("deque");
});

var lw = new List(), gw;

$(function() {
  $('#play').hide();
  gw = lw.getGraphWidget();
  var five_modes = ["LL", "Stack", "Queue", "DLL", "Deque"];
  $('#title-'+five_modes[Math.floor(Math.random()*5)]).click(); // randomly open one of the five default example every time

  var llMode = getQueryVariable("mode");
  if (llMode.length > 0) {
    $('#title-' + llMode).click();
  }
  var createLL = getQueryVariable("create");
  if (createLL.length > 0) {
    var newLL = createLL.split(",");
    lw.generate(newLL);
  }
  var operation = getQueryVariable("operation");
  var operationValue = getQueryVariable("operationValue");
  var operationMode = getQueryVariable("operationMode");
  if (operation.length > 0) {
    switch (operation) {
      case "insert":
        openInsert();
        insertModelingOpen(operationMode);
        $("#" + operationMode + "-input input").val(operationValue);
    }
  }

  $('#create').click(function() {
    closeSearch();
    closeInsert();
    closeRemove();
    openCreate();
  });

  $('#search').click(function() {
    closeCreate();
    closeInsert();
    closeRemove();
    openSearch();
  });

  $('#insert').click(function() {
    closeCreate();
    closeSearch();
    closeRemove();
    openInsert();
  });

  $('#remove').click(function() {
    closeCreate();
    closeSearch();
    closeInsert();
    openRemove();
  });
});

function allOff() {
  $("#search-input").css("display", "none");
  $("#search-go").css("display", "none");
  $("#search-peek-front").css("display", "none");
  $("#search-peek-back").css("display", "none");

  $("#insert-head").css("display", "none");
  $("#insert-tail").css("display", "none");
  $("#insert-kth").css("display", "none");
  $("#pushtop-input").css("display", "none");
  $("#pushtop-go").css("display", "none");
  $("#enqueueback-input").css("display", "none");
  $("#enqueueback-go").css("display", "none");
  $("#insert-deque-input").css("display", "none");
  $("#insert-deque-front").css("display", "none");
  $("#insert-deque-back").css("display", "none");

  $("#remove-head").css("display", "none");
  $("#remove-tail").css("display", "none");
  $("#remove-kth").css("display", "none");
  $("#remove-deque-front").css("display", "none");
  $("#remove-deque-back").css("display", "none");
}

function displayList() {
  allOff();

  $("#search-input").css("display", "");
  $("#search-go").css("display", "");

  $("#insert-head").css("display", "");
  $("#insert-tail").css("display", "");
  $("#insert-kth").css("display", "");

  $("#remove-head").css("display", "");
  $("#remove-tail").css("display", "");
  $("#remove-kth").css("display", "");
}

function displayStack() {
  allOff();

  $("#pushtop-input").css("display", "");
  $("#pushtop-go").css("display", "");
}

function displayQueue() {
  allOff();

  $("#enqueueback-input").css("display", "");
  $("#enqueueback-go").css("display", "");
}

function displayDeque() {
  allOff();

  $("#search-peek-front").css("display", "");
  $("#search-peek-back").css("display", "");

  $("#insert-deque-input").css("display", "");
  $("#insert-deque-front").css("display", "");
  $("#insert-deque-back").css("display", "");

  $("#remove-deque-front").css("display", "");
  $("#remove-deque-back").css("display", "");
}

function changeTextList() {
  $("#create").text('Tạo');
  $("#search").text('Tìm kiếm');
  $("#insert").text('Chèn');
  $("#remove").text('Di chuyển');
}

function changeTextStack() {
  $("#create").text('Tạo');
  $("#search").text('Lấy ra nhưng không loại bỏ');
  $("#insert").text('Đẩy vào');
  $("#remove").text('Lấy ra');
}

function changeTextQueue() {
  $("#create").text('Tạo');
  $("#search").text('Lấy ra nhưng không loại bỏ');
  $("#insert").text('Enqueue');
  $("#remove").text('Hàng đợi hai đầu');
}

function changeTextDoublyList() {
  $("#create").text('Tạo');
  $("#search").text('Tìm kiếm');
  $("#insert").text('Chèn');
  $("#remove").text('Di chuyển');
}

function changeTextDeque() {
  $("#create").text('Tạo');
  $("#search").text('Lấy ra nhưng không loại bỏ');
  $("#insert").text('Enqueue');
  $("#remove").text('Hàng đợi hai đầu');
}

function empty() {
  if (isPlaying) stop();
  if (lw.generateRandomFixedSize(0)) {
    $('#progress-bar').slider("option", "max", 0);
    closeCreate();
    isPlaying = false;
  }
  hideStatusPanel();
  hideCodetracePanel();
}

function random() {
  if (isPlaying) stop();
  if (lw.generateRandom(false)) {
    $('#progress-bar').slider("option", "max", 0);
    closeCreate();
    isPlaying = false;
  }
  hideStatusPanel();
  hideCodetracePanel();
}

function randomSorted() {
  if (isPlaying) stop();
  if (lw.generateRandom(true)) {
    $('#progress-bar').slider("option", "max", 0);
    closeCreate();
    isPlaying = false;
  }
  hideStatusPanel();
  hideCodetracePanel();
}

function randomFixedSize() {
  if (isPlaying) stop();
  var input = $('#v-create-size').val();
  input = parseInt(input);
  if (lw.generateRandomFixedSize(input)) {
    $('#progress-bar').slider("option", "max", 0);
    closeCreate();
    isPlaying = false;
  }
  hideStatusPanel();
  hideCodetracePanel();
}

function nonRandom() {
  if (isPlaying) stop();
  var input = $('#v-create-arr').val();
  input = input.split(",");
  if (lw.generateUserDefined(input)) {
    $('#progress-bar').slider("option", "max", 0);
    closeCreate();
    isPlaying = false;
  }
  hideStatusPanel();
  hideCodetracePanel();
}

function searchVertex(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#v-search').val());
  commonAction(lw.search(input, callback), "Tìm kiếm " + input);
  setTimeout(function() {
    if (Math.random() > 0.5) // 50% chance totally random
      $('#v-search').val(1 + Math.floor(Math.random()*99)); 
    else { // 50% something that is inside the list
      var a = lw.getA();
      $('#v-search').val(a[Math.floor(Math.random()*a.length)]);
    }
  }, 500);
}

function peekStack(callback) {
  if (isPlaying) stop();
  commonAction(lw.peek(true, callback), 'Peek top (head)');
}

function peekQueue(callback) {
  if (isPlaying) stop();
  commonAction(lw.peek(true, callback), 'Peek front (head)');
}

function searchGeneric(callback) {
       if (lw.getActiveStatus() == "stack")
    peekStack(callback);
  else if (lw.getActiveStatus() == "queue")
    peekQueue(callback);
}

function peekDeque(location, callback) {
  if (isPlaying) stop();
  if (location == "front")
    commonAction(lw.peek(true, callback), 'Peek front (head)');
  else
    commonAction(lw.peek(false, callback), 'Peek back (tail)');
}

function insertHead(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#v-insert-head-value').val());
  commonAction(lw.insertHead(input, callback), 'Insert {input} at head'.replace("{input}", input));
  setTimeout(function() { $('#v-insert-head-value').val(1 + Math.floor(Math.random()*99)); }, 500);
}

function insertTail(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#v-insert-tail-value').val());
  commonAction(lw.insertTail(input, callback), 'Insert {input} at tail'.replace("{input}", input));
  setTimeout(function() { $('#v-insert-tail-value').val(1 + Math.floor(Math.random()*99)); }, 500);
}

function insertKth(callback) {
  if (isPlaying) stop();
  var index = parseInt($('#v-insert-kth').val());
  var input = parseInt($('#v-insert-kth-value').val());
  commonAction(lw.insertKth(index, input, callback), 'Insert {input} at index {index}'.replace("{input}", input).replace("{index}", index));
  setTimeout(function() {
    $('#v-insert-kth').val(1 + Math.floor(Math.random()*(lw.getN()-1))); // [1..N-1]
    $('#v-insert-kth-value').val(1 + Math.floor(Math.random()*99));
  }, 500);
}

function pushTop(callback) {
  if (isPlaying) stop();
  var input = $('#v-push-top-value').val();
  commonAction(lw.insertHead(input, callback), 'Push {input} at top (head)'.replace("{input}", input));
  setTimeout(function() { $('#v-push-top-value').val(1 + Math.floor(Math.random()*99)); }, 500);
}

function enqueueBack(callback) {
  if (isPlaying) stop();
  var input = $('#v-enqueue-back-value').val();
  commonAction(lw.insertTail(input, callback), 'Enqueue {input} at back (tail)'.replace("{input}", input));
  setTimeout(function() { $('#v-enqueue-back-value').val(1 + Math.floor(Math.random()*99)); }, 500);
}

function insertDeque(location) {
  if (isPlaying) stop();
  var input = $('#v-insert-deque-value').val();
  if (location == "front")
    commonAction(lw.insertHead(input), 'Enqueue {input} to front (head)'.replace("{input}", input));
  else
    commonAction(lw.insertTail(input), 'Enqueue {input} to back (tail)'.replace("{input}", input));
  setTimeout(function() { $('#v-insert-deque-value').val(1 + Math.floor(Math.random()*99)); }, 500);
}

function removeHead(callback) { // PS both pop/stack and dequeue/queue also calls the same thing: remove head
  if (isPlaying) stop();
  commonAction(lw.removeHead(callback), 'Remove i = 0 (Head)');
}

function removeTail(callback) {
  if (isPlaying) stop();
  if (lw.getActiveStatus() == "doublylist" || lw.getActiveStatus() == "deque")
    commonAction(lw.removeTailDLL(callback), 'Remove i = N-1 (Tail)');
  else
    commonAction(lw.removeTail(callback), 'Remove i = N-1 (Tail)');
}

function removeKth(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#v-remove-kth').val());
  commonAction(lw.removeKth(input, callback), 'Remove index {input}'.replace("{input}", input));
  setTimeout(function() { $('#v-remove-kth').val(1 + Math.floor(Math.random()*(lw.getN()-2))); }, 500); // [1..N-2]
}

function removeGeneric(callback) {
  if ((lw.getActiveStatus() == "stack") || (lw.getActiveStatus() == "queue"))
    removeHead(callback);
}

function removeDeque(location) {
  if (isPlaying) stop();
  if (location == "front")
    commonAction(lw.removeHead(), 'Loại bỏ phần tử đầu ');
  else
    commonAction(lw.removeTailDLL(), 'Loại bỏ phần tử cuối<br>');
}

function createModelingOpen(modelingType) {
  $(".create").css("bottom", "119px");
  if (modelingType != "createfixedsize")
    $('#createfixedsize-input').fadeOut('fast');
  if (modelingType != "createuserdefined")
    $('#createuserdefined-input').fadeOut('fast');
  $('#'+modelingType+'-input').fadeIn('fast');
}

function insertModelingOpen(modelingType) {
  $(".insert").css("bottom", "65px");
  if (modelingType != "insertkth")
    $('#insertkth-input').fadeOut('fast');
  if (modelingType != "inserthead")
    $('#inserthead-input').fadeOut('fast');
  if (modelingType != "inserttail")
    $('#inserttail-input').fadeOut('fast');
  $('#'+modelingType+'-input').fadeIn('fast');
}

function removeModelingOpen(modelingType) {
  $(".remove").css("bottom", "38px");
  $('#'+modelingType+'-input').fadeIn('fast');
}

// Implement these functions in each visualisation
// var userGraph = {
//   'vl': {},
//   'el': {},
// };

// This function will be called before entering E-Lecture Mode
function ENTER_LECTURE_MODE() {
  //if (lw) userGraph = lw.getGraph();
}

// This function will be called before returning to Explore Mode
function ENTER_EXPLORE_MODE() {
  //loadGraph(userGraph);
}

// Lecture action functions
function CUSTOM_ACTION(action, data, mode) {
       if (action == 'search') {
    hideSlide(function() {
      $('#v-search').val(data); // force
      searchVertex(showSlide);
    });
  }
  else if (action == 'peek') {
    hideSlide(function() {
      searchGeneric(showSlide);
    });
  }
  else if (action == 'insert_head') {
    hideSlide(function() {
      $('#v-insert-head-value').val(data); // force
      insertHead(showSlide);
    });
  }
  else if (action == 'insert_tail') {
    hideSlide(function() {
      $('#v-insert-tail-value').val(data); // force
      insertTail(showSlide);
    });
  }
  else if (action == 'insert_kth') {
    hideSlide(function() {
      $('#v-insert-kth').val(data.split(",")[0]); // force
      $('#v-insert-kth-value').val(data.split(",")[1]); // force
      insertKth(showSlide);
    });
  }
  else if (action == 'remove_head') {
    var a = lw.getA();
    if (a.length > 0) {
      hideSlide(function() {
        removeHead(showSlide);
      });
    }
    else
      alert('The Linked List is already empty'); // put in variable?
  }
  else if (action == 'remove_tail') {
    var a = lw.getA();
    if (a.length > 0) {
      hideSlide(function() {
        removeTail(showSlide);
      });
    }
    else
      alert('The Linked List is already empty'); // put in variable?
  }
  else if (action == 'remove_kth') {
    hideSlide(function() {
      $('#v-remove-kth').val(data); // force
      removeKth(showSlide);
    });
  }
  else if (action == 'push') {
    hideSlide(function() {
      $('#v-push-top-value').val(data); // force
      pushTop(showSlide);
    });
  }
  else if (action == 'enqueue') {
    var a = lw.getA();
    if (a.length < 10) {
      var randval = 1 + Math.floor(Math.random()*99);
      while (a.includes(randval))
        randval = 1 + Math.floor(Math.random()*99);
      hideSlide(function() {
        $('#v-enqueue-back-value').val(randval); // force random
        enqueueBack(showSlide);
      });
    }
    else
      alert('The Linked List is already too long for this visualization'); // put in variable?
  }
}
</script>
</body>

<!-- Mirrored from visualgo.net/vi/list?slide=3-7 by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 26 Nov 2020 06:40:24 GMT -->
</html>
