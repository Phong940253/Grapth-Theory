<!DOCTYPE html>
<html lang="vi">

<!-- Mirrored from visualgo.net/vi/dfsbfs by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 26 Nov 2020 06:40:12 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="description" content="Given a graph, we can use the O(V+E) DFS (Depth-First Search) or BFS (Breadth-First Search) algorithm to traverse the graph and explore the features/properties of the graph. Each algorithm has its own characteristics, features, and side-effects that we will explore in this visualization.This visualization is rich with a lot of DFS and BFS variants (all run in O(V+E)) such as: Topological Sort algorithm (both DFS and BFS/Kahn&#39;s algorithm version),Bipartite Graph Checker algorithm (both DFS and BFS version),Cut Vertex &amp; Bridge finding algorithm,Strongly Connected Components (SCC) finding algorithms(both Kosaraju&#39;s and Tarjan&#39;s version), and2-SAT Checker algorithm.">
<meta name="keywords" content="Graph Traversal Depth Breadth First Search Directed Undirected DFS BFS Topological Sort Toposort Bipartite Check Tarjan Kosaraju 2-SAT">
 
<meta name="csrf-token" content="iVivZ7KRPe6XK7pbuGtOoEjljE1xyBVNhLKNFuF8">
<meta http-equiv="X-UA-Compatible" content="IE=EDGE">
<meta property="og:image" content="../img/png/dfsbfs.png">
<title>VisuAlgo - Xét toàn đồ thị (Tìm kiếm theo chiều sâu/rộng)</title>
<link rel="icon" href="../img/favicon.png" type="image/x-icon">
<link rel="shortcut icon" href="../img/favicon.png" type="image/x-icon">
<link rel="apple-touch-icon" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="72x72" href="../img/favicon.png">
<link rel="apple-touch-icon" sizes="114x114" href="../img/favicon.png">
<link rel="stylesheet" type="text/css" href="../fonts/silkscreen/stylesheet.css">
<link rel="stylesheet" type="text/css" href="../css/common.css">
<link rel="stylesheet" href="../css/viz-1.0.1.css">
<link rel="stylesheet" href="../css/visual.css">
<link rel="stylesheet" href="../css/drawgraph.css">
<style>
      #e-lecture {
        top: 45px;
        right: 130px;
        width: 400px;
        display: block;
        background: none;
        /*overflow: normal;*/
        white-space: normal;
        text-align: right;
        color: black; font-weight: bold; font-size: 20px;
      }
      .electure-prev, .electure-next { /* force update, copied from viz.css */
        position: absolute;
        /* bottom: -12px; */
        top: -20px;
        /*bottom: '';*/
        padding: 3px 8px;
        background: #999;
        color: white;
        cursor: pointer;
        border-radius: 2px;
      }
      .electure-prev {
        left: -10px;
        /* right: 30px; */
      }
      .electure-next {
        right: -10px;
        color: white;
      }
    </style>
<style>
.execAction { padding: 5px 8px; }
.err { padding: 5px 0px; }
#actions-extras input {
  width: 35px;
  padding: 5px 8px 7px;
}

/*
.directedChange { bottom: 200px; }
#directedChange-err { padding: 5px 8px; }
*/

#twosat-board {
  height: 470px;
  width: 600px;
  margin-left: -300px;
  margin-top: -235px;
}

.draw { bottom: 308px; }
.examples { bottom: 254px; }
.dfs { bottom: 227px; }
.bfs { bottom: 200px; }
.topo { bottom : 173px; }
.bipartite { bottom: 146px; }
.bridge { bottom: 119px; }
.scc { bottom: 92px;}
.twosat { bottom: 65px; }
</style>
<script>
      function changeURL() {
        var URL = window.location.href.split('https://visualgo.net/');
        var val = document.getElementById("Language").value;
        URL[3] = val;
        window.location.assign(URL.join('https://visualgo.net/'));
      }
    </script>
</head>
<body>
<div id="top-bar">
<a href="http://www.comp.nus.edu.sg/~stevenha"><span class="colour" style="border: 1px solid green; border-radius: 25px;">7</span></a>&nbsp;&nbsp;&nbsp;
 <a id="home" href="https://visualgo.net/">Visu<span class="colour">Algo</span><span style="font-size: 40%">.net</span></a>
/
<select id="Language" onchange="changeURL()">
<option value="en">en</option>
<option value="zh">zh</option>
<option value="es">es</option>
<option value="pt">pt</option>
<option value="ru">ru</option>
<option value="id">id</option>
<option value="de">de</option>
<option value="bn">bn</option>
<option value="ja">ja</option>
<option value="ko">ko</option>
<option value="vi" selected>vi</option>
</select>
/dfsbfs
<span class="right-links" id="useraccount">Login</span>
<span id="title">
<a id='title-dfsbfs' class='selected-viz'>Xét toàn đồ thị (DFS/BFS)</a>
</span>
<div id="mode-menu">
<div id='mode-button' title='exploration'>Chế độ thăm dò &#9663;</div>
<div id='other-modes'>
<a title='e-Lecture'>Chế độ Bài giảng trực tuyến</a>
</div>
</div>
</div>
<div id="dark-overlay"></div>
<div id="status" class="panel"><p></p></div>
<div id="status-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide status panel" /></div>
<div id="codetrace" class="panel">
<p id="code1" style="padding-top: 10px;"></p>
<p id="code2"></p>
<p id="code3"></p>
<p id="code4"></p>
<p id="code5"></p>
<p id="code6"></p>
<p id="code7" style="padding-bottom: 10px;"></p>
</div>
<div id="codetrace-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title="show/hide codetrace panel" /></div>
<div id="left-bar"></div>
<div id="right-bar"></div>
<div id="media-controls">
<div id='speed-control'>Chậm<div id='speed-input'></div>Nhanh<br></div>
<span id="go-to-beginning" class="media-control-button" title="go to beginning" onclick=goToBeginning()><img src="../img/goToBeginning.png" alt="go to beginning"></span>
<span id="previous" class="media-control-button" title="step backward" onclick=stepBackward()><img src="../img/prevFrame.png" alt="previous frame"></span>
<span id="pause" class="media-control-button" title="pause" onclick=pause()><img src="../img/pause.png" alt="pause"></span>
<span id="play" class="media-control-button" title="play" onclick=play()><img src="../img/play.png" alt="play"></span>
<span id="next" class="media-control-button" title="step forward" onclick=stepForward()><img src="../img/nextFrame.png" alt="next frame"></span>
<span id="go-to-end" class="media-control-button" title="go to end" onclick=goToEnd()><img src="../img/goToEnd.png" alt="go to end"></span>
<div id="progress-bar" class="media-control-button"></div>
</div>
<div id='viz'></div>
<div id='current-action' class='panel'></div>
<div id='e-lecture' class='panel'></div>
<div id="overlay" hidden></div>
<div id="dropdown-temp-holder" hidden></div>
<div id="electure-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>Given a graph, we can use the O(<b>V</b>+<b>E</b>) DFS (Depth-First Search) or BFS (Breadth-First Search) algorithm to traverse the graph and explore the features/properties of the graph. Each algorithm has its own characteristics, features, and side-effects that we will explore in this visualization.</p><br><p>This visualization is rich with a lot of DFS and BFS variants (all run in O(<b>V</b>+<b>E</b>)) such as: </p><ol><li>Topological Sort algorithm (both DFS and BFS/Kahn&#39;s algorithm version),</li><li>Bipartite Graph Checker algorithm (both DFS and BFS version),</li><li>Cut Vertex &amp; Bridge finding algorithm,</li><li>Strongly Connected Components (SCC) finding algorithms<br>(both Kosaraju&#39;s and Tarjan&#39;s version), and</li><li>2-SAT Checker algorithm.</li></ol>
<hr>
<p><b>Remarks</b>: By default, we show e-Lecture Mode for first time (or non logged-in) visitor.<br>
Please <a href="https://visualgo.net/login"><u>login</u></a> if you are a repeated visitor or <a href="https://visualgo.net/login"><u>register</u></a> for an (optional) free account first.</p>
<div id='electure-dropdown'>
<select class="lecture-dropdown" style="width:100%">
<option value="1">1. DFS & BFS</option>
<option value="2">2. Visualization</option>
<option value="3">3. Specifying an Input Graph</option>
<option value="4">4. Recap</option>
<option value="4-1">&nbsp;&nbsp;&nbsp;4-1. Binary Tree Traversal - Source = Root</option>
<option value="4-2">&nbsp;&nbsp;&nbsp;4-2. Binary Tree Traversal - Pre-/In-/Post-order</option>
<option value="4-3">&nbsp;&nbsp;&nbsp;4-3. The Answer</option>
<option value="4-4">&nbsp;&nbsp;&nbsp;4-4. Binary Tree Traversal - Acyclic</option>
<option value="4-5">&nbsp;&nbsp;&nbsp;4-5. Issues in General Graph</option>
<option value="5">5. DFS</option>
<option value="5-1">&nbsp;&nbsp;&nbsp;5-1. Analogy</option>
<option value="5-2">&nbsp;&nbsp;&nbsp;5-2. Trying All Options</option>
<option value="5-3">&nbsp;&nbsp;&nbsp;5-3. Avoiding Cycle</option>
<option value="5-4">&nbsp;&nbsp;&nbsp;5-4. Memorizing the Path</option>
<option value="5-5">&nbsp;&nbsp;&nbsp;5-5. Hands-on Example</option>
<option value="5-6">&nbsp;&nbsp;&nbsp;5-6. O(V+E) Time Complexity</option>
<option value="5-7">&nbsp;&nbsp;&nbsp;5-7. O(V+E) at all times?</option>
<option value="5-8">&nbsp;&nbsp;&nbsp;5-8. The Answer</option>
<option value="6">6. BFS</option>
<option value="6-1">&nbsp;&nbsp;&nbsp;6-1. Analogy</option>
<option value="6-2">&nbsp;&nbsp;&nbsp;6-2. Try All, Avoid Cycle, Memorize Path</option>
<option value="6-3">&nbsp;&nbsp;&nbsp;6-3. Hands-on Example</option>
<option value="6-4">&nbsp;&nbsp;&nbsp;6-4. O(V+E) Time Complexity</option>
<option value="7">7. Simple DFS/BFS Applications</option>
<option value="7-1">&nbsp;&nbsp;&nbsp;7-1. Detecting Cycle - Part 1</option>
<option value="7-2">&nbsp;&nbsp;&nbsp;7-2. Detecting Cycle - Part 2</option>
<option value="7-3">&nbsp;&nbsp;&nbsp;7-3. Hands-on Example (Detailed)</option>
<option value="7-4">&nbsp;&nbsp;&nbsp;7-4. Print the Traversal Path</option>
<option value="7-5">&nbsp;&nbsp;&nbsp;7-5. Reachability Test</option>
<option value="7-6">&nbsp;&nbsp;&nbsp;7-6. Identifying a Connected Component (CC)</option>
<option value="7-7">&nbsp;&nbsp;&nbsp;7-7. Counting the Number of/Labeling the CCs</option>
<option value="7-8">&nbsp;&nbsp;&nbsp;7-8. Wait, What is the Time Complexity?</option>
<option value="7-9">&nbsp;&nbsp;&nbsp;7-9. The Answer</option>
<option value="7-10">&nbsp;&nbsp;&nbsp;7-10. Topological Sort - Definition</option>
<option value="7-11">&nbsp;&nbsp;&nbsp;7-11. Topological Sort</option>
<option value="8">8. More Advanced DFS/BFS Applications</option>
<option value="9">9. Bipartite Graph Checker</option>
<option value="10">10. Find Cut Vertices & Bridges</option>
<option value="11">11. Find Strongly Connected Components</option>
<option value="12">12. 2-SAT Checker Algorithm</option>
<option value="13">13. Which One is Better?</option>
<option value="13-1">&nbsp;&nbsp;&nbsp;13-1. The Answer</option>
<option value="14">14. Extras</option>
<option value="14-1">&nbsp;&nbsp;&nbsp;14-1. Online Quiz</option>
<option value="14-2">&nbsp;&nbsp;&nbsp;14-2. Online Judge Exercises</option>
<option value="14-3">&nbsp;&nbsp;&nbsp;14-3. Discussion</option>
<option value="99">99. Status Panel</option>
<option value="99-1">&nbsp;&nbsp;&nbsp;99-1. Codetrace Panel</option>
<option value="99-2">&nbsp;&nbsp;&nbsp;99-2. Media Control</option>
<option value="99-3">&nbsp;&nbsp;&nbsp;99-3. Return to &#39;Exploration Mode&#39;</option>
</select>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-next' data-nextid="2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-2" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>When the chosen graph traversal algorithm is running, the animation will be shown here.</p><br><p>We use vertex+edge color (the color scheme will be elaborated soon) and occasionally the extra text under the vertex (in <span style="color: red;">red font</span>) to highlight the changes.</p><br><p>All graph traversal algorithms work on directed graphs (this is the default setting, where each edge has an arrowtip to indicate its direction) but the <b>Bipartite Graph Check</b> algorithm and the <b>Cut Vertex &amp; Bridge</b> finding algorithm requires the undirected graphs (the conversion is done automatically by this visualization).</p>
<hr>
<p>Pro-tip: Since you are not <a href="https://visualgo.net/login"><u>logged-in</u></a>, you may be a first time visitor who are not aware of the following keyboard shortcuts to navigate this e-Lecture mode: <b>[PageDown]</b> to advance to the next slide, <b>[PageUp]</b> to go back to the previous slide, <b>[Esc]</b> to toggle between this e-Lecture mode and exploration mode.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-3" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>There are two different sources for specifying an input graph:</p><ol><li><b>Draw Graph</b>: You can draw <strong>any</strong> unweighted directed graph as the input graph (to draw bidirectional edge (u, v), you can draw two directed edges u → v and v → u).</li><li><b>Example Graphs</b>: You can select from the list of our selected example graphs to get you started.</li></ol>
<hr>
<p>Another pro-tip: We designed this visualization and this e-Lecture mode to look good on 1366x768 resolution <b>or larger</b> (typical modern laptop resolution in 2017). We recommend using Google Chrome to access VisuAlgo. Go to full screen mode (<b>F11</b>) to enjoy this setup. However, you can use zoom-in (<b>Ctrl +</b>) or zoom-out (<b>Ctrl -</b>) to calibrate this.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4" class="electure-dialog" style="top:100px;right:60px;width:500px;">
<p>If you arrive at this e-Lecture <b>without</b> having first explore/master the concept of <a href="heap.html"><u>Binary Heap</u></a> and especially <a href="bst.html"><u>Binary Search Tree</u></a>, we suggest that you explore them first, as traversing a (Binary) Tree structure is much simpler than traversing a general graph.</p><br><input class="msq-answer" id="msq-answer-14" value="60,63,64" hidden><p>Quiz: <b>Mini pre-requisite check. What are the Pre-/In-/Post-order traversal of the binary tree shown (root = vertex 0), left and right child are as drawn?</b></p><input type="checkbox" class="msq-choice" id="msq-14-choice-61"> Pre = 0, 2, 4, 3, 1<br><input type="checkbox" class="msq-choice" id="msq-14-choice-62"> In = 4, 2, 3, 0, 1<br><input type="checkbox" class="msq-choice" id="msq-14-choice-60"> Pre = 0, 1, 2, 3, 4<br><input type="checkbox" class="msq-choice" id="msq-14-choice-63"> In = 1, 0, 3, 2, 4<br><input type="checkbox" class="msq-choice" id="msq-14-choice-65"> Post = 4, 3, 2, 1, 0<br><input type="checkbox" class="msq-choice" id="msq-14-choice-64"> Post = 1, 3, 4, 2, 0<br><button class="msq-submit" id="submit-14">Submit</button> <span id="answer-status-14"></span>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-1" class="electure-dialog" style="top:100px;right:60px;width:500px;">
<p>We normally start from the most important vertex of a (binary) tree: The <b>root</b> vertex.</p><br><p>If the given tree is not &#39;rooted&#39; (see the example picture), we can pick any one vertex (for example, vertex 0 in the example picture) and designate it as the root. If we imagine that all edges are strings of similar length, then after "virtually pulling the designated root upwards" and let gravity pulls the rest downwards, we have a rooted directed (downwards) tree &mdash; see the next slide.</p><br><p>PS: Technically, this transformation is done by running <code>DFS(0)</code> that we will explore soon.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-2" class="electure-dialog" style="top:100px;right:60px;width:500px;">
<p>In a <b>binary</b> tree, we only have <b>up to two</b> neighboring choices: From the current vertex, we can go to the left subtree first or go to the right subtree first. We also have option to visit the current vertex before or after visiting one of the (or both) subtree(s).</p><br><p>This gives rise to the classics: pre-order (visit current vertex, visit its left subtree, visit its right subtree), in-order (left, current, right), and post-order (left, right, current) traversals.</p><br><p>Discussion: Do you notice that there are three other possible binary tree traversal combinations? What are they?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-3" class="electure-dialog" style="top:100px;right:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-4" class="electure-dialog" style="top:100px;right:60px;width:500px;">
<p>In a binary tree, or in a tree structure in general, there is no (non-trivial) cycle involving 3 or more distinct vertices to worry about (we do not consider the trivial cycle involving bi-directional edges which can be taken care of easily — see three slides earlier).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="4-5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-4-5" class="electure-dialog" style="top:100px;right:60px;width:500px;">
<p>In general graph, we do not have the notion of root vertex. Instead, we need to pick one distinguished vertex to be the starting point of the traversal, i.e. the source vertex <b>s</b>.</p><br><p>We also have 0, 1, ..., <b>k</b> neighbors of a vertex instead of just &le; 2.</p> <br><p>We <b>may (or actually very likely)</b> have cycle(s) in our general graph instead of acyclic tree,<br> be it the trivial one like u &rarr; v &rarr; u or the non-trivial one like a &rarr; b &rarr; c &rarr; a.</p><br><p>But fret not, graph traversal is an easy problem with two classic algorithms: DFS and BFS.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>One of the most basic graph traversal algorithm is the O(<b>V</b>+<b>E</b>) Depth-First Search (DFS).</p><br><p>DFS takes one input parameter: The source vertex <b>s</b>.</p><br><p>DFS is one of the most fundamental graph algorithm, so please spend time to understand the key steps of this algorithm.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="4-5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-1" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p><img src="https://visualgo.net/img/maze.svg" width="100" height="100" style="background-color: white; float: right;" alt="maze">The closest analogy of the behavior of DFS is to imagine a maze with only one entrance and one exit. You are at the entrance and want to explore the maze to reach the exit. Obviously you cannot split yourself into more than one.</p><br><p>Ask these reflective questions before continuing: What will you do if there are branching options in front of you? How to avoid going in cycle? How to mark your own path? Hint: You need a chalk, stones (or any other marker) and a (long) string.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-2" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>As it name implies, DFS starts from a distinguished source vertex <b>s</b> and uses recursion (an implicit stack) to order the visitation sequence as deep as possible before backtracking.</p><br><p>If DFS is at a vertex <b>u</b> and it has <b>X</b> neighbors, it will pick the first neighbor <b>V<sub>1</sub></b> (usually the vertex with the lowest vertex number), recursively explore all reachable vertices from vertex <b>V<sub>1</sub></b>, and eventually backtrack to vertex <b>u</b>. DFS will then do the same for the other neighbors until it finishes exploring the last neighbor <b>V<sub>X</sub></b> and its reachable vertices.</p><br><p>This wordy explanation will be clearer with DFS animation later.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-3" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>If the graph is <b>cyclic</b>, the previous &#39;try-all&#39; strategy may lead DFS to run in cycle.</p><br><p>So <i>the basic form of DFS</i> uses an array <b>status[u]</b> of size <b>V</b> vertices to decide between <i>binary conditions</i>: Whether vertex <b>u</b> has been visited or unvisited. Only if vertex <b>u</b> is still unvisited, then DFS can visit vertex <b>u</b>.</p><br><p>When DFS runs out of option, it <b>backtrack</b> to previous vertex (<b>p[u]</b>, see the next slide) as the recursion unwinds.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-4" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>DFS uses another array <b>p[u]</b> of size <b>V</b> vertices to remember the <b>parent/predecessor/previous</b> of each vertex <b>u</b> along the DFS traversal path.</p><br><p>The predecessor of the source vertex, i.e. <b>p[s]</b> is set to -1 to say that the source vertex has no predecessor (as the lowest vertex number is vertex 0).</p><br><p>The sequence of vertices from a vertex <b>u</b> that is reachable from the source vertex <b>s</b> back to <b>s</b> forms the <b>DFS spanning tree</b>. We color these <b>tree edges</b> with <span style="color: red;">red color</span>.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-5" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>For now, ignore the extra <b>status[u] = explored</b> in the displayed pseudocode and the presence of <span style="color: lightblue;">blue</span> and <span style="color: grey;">grey</span> edges in the visualization (to be explained soon).</p><br><p>Without further ado, let&#39;s execute <span class="slide-actions" onclick="doButtonAction39()">DFS(0)</span> on the default example graph for this e-Lecture (CP3 Figure 4.1). <span id="dfsrecap"><span class="slide-actions" onclick="doButtonAction41()">Recap DFS Example</span></span></p><br><p>The <i>basic version</i> of DFS presented so far is already enough for most simple cases.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-6">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-6" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>The time complexity of DFS is O(<b>V</b>+<b>E</b>) because:</p><ol><li>Each vertex is only visited once due to the fact that DFS will only recursively explore a vertex <b>u</b> if <b>status[u] = unvisited</b> &mdash; O(<b>V</b>)</li><li>Every time a vertex is visited, all its <b>k</b> neighbors are explored and therefore after all vertices are visited, we have examined all <b>E</b> edges &mdash; (O(<b>E</b>) as the total number of neighbors of each vertex equals to <b>E</b>).</li></ol>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-7">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-7" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>The O(<b>V</b>+<b>E</b>) time complexity of DFS only achievable if we can visit all <b>k</b> neighboring vertices of a vertex in O(<b>k</b>) time.</p><br><input class="mcq-answer" id="mcq-answer-13" value="57" hidden><p>Quiz: <b>Which underlying graph data structure support that operation?</b></p><form><input type="radio" name="mcq-13-choice" value="58"> Edge List<br><input type="radio" name="mcq-13-choice" value="56"> Adjacency Matrix<br><input type="radio" name="mcq-13-choice" value="57"> Adjacency List<br></form><button class="mcq-submit" id="submit-13">Submit</button> <span id="answer-status-13"></span><br><br><p>Discussion: Why?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-6">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="5-8">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-5-8" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-7">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="6">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-6" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>Another basic graph traversal algorithm is the O(<b>V</b>+<b>E</b>) Breadth-First Search (BFS).</p><br><p>As with DFS, BFS also takes one input parameter: The source vertex <b>s</b>.</p><br><p>Both DFS and BFS have their own strengths and weaknesses. It is important to learn both and apply the correct graph traversal algorithm for the correct situation.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="5-8">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="6-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-6-1" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p><img src="../img/ripple.jpg" width="100" height="100" style="float: right;" alt="ripple">Imagine a still body of water and then you throw a stone into it. The first location where the stone hits the water surface is the position of the source vertex and the subsequent <b>ripple effect</b> across the water surface is like the BFS traversal pattern.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="6-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-6-2" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>BFS is very similar with DFS that have been discussed earlier, but with some differences.</p><br><p>BFS starts from a source vertex <b>s</b> but it uses a <a href="listc97b.html?mode=Queue"><u>queue</u></a> to order the visitation sequence <i>as breadth as possible before going deeper</i>.</p><br><p>BFS also uses a Boolean array of size <b>V</b> vertices to distinguish between two states: visited and unvisited vertices (we will not use BFS to detect back edge(s) as with DFS).</p><br><p>In this visualization, we also show that starting from the same source vertex <b>s</b> in an <b>unweighted graph</b>, BFS spanning tree of the graph equals to its <a href="sssp.html"><u>SSSP spanning tree</u></a>.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="6-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-6-3" class="electure-dialog" style="top:100px;right:60px;width:500px;">
<p>Without further ado, let&#39;s execute <span class="slide-actions" onclick="doButtonAction40()">BFS(5)</span> on the default example graph for this e-Lecture (CP3 Figure 4.3). <span id="bfsrecap"><span class="slide-actions" onclick="doButtonAction42()">Recap BFS Example</span></span>.</p><br><p>Notice the <i>Breadth-first</i>&nbsp;exploration due to the usage of FIFO data structure: Queue?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="6-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-6-4" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>The time complexity of BFS is O(<b>V</b>+<b>E</b>) because:</p><ol><li>Each vertex is only visited once as it can only enter the queue once — O(<b>V</b>)</li><li>Every time a vertex is dequeued from the queue, all its <b>k</b> neighbors are explored and therefore after all vertices are visited, we have examined all <b>E</b> edges — (O(<b>E</b>) as the total number of neighbors of each vertex equals to <b>E</b>).</li></ol><p>As with DFS, this O(<b>V</b>+<b>E</b>) time complexity is only possible if we use <a href="graphds.html"><u>Adjacency List</u></a> graph data structure — same reason as with DFS analysis.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>So far, we can use DFS/BFS to solve a few graph traversal problem variants:</p><ol><li>Detecting if a graph is cyclic,</li><li>Actually printing the traversal path,</li><li>Reachability test,</li><li>Identifying/Counting/Labeling Connected Components (CCs) of undirected graphs,</li><li>Topological Sort (only on DAGs),</li></ol><p>For most data structures and algorithms courses, the applications of DFS/BFS are up to these few basic ones only, although DFS/BFS can do much more...</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="6-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7-1" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>We can actually <i>augment</i> the basic DFS further to give more insights about the underlying graph.</p><br><p>In this visualization, we use <span style="color: lightblue;">blue color</span> to highlight <b>back</b> edge(s) of the DFS spanning tree. The presence of at least one back edge shows that the traversed graph (component) is <b>cyclic</b> while its absence shows that at least the component connected to the source vertex of the traversed graph is <b>acyclic</b>.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7-2" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>Back edge can be detected by modifying array <b>status[u]</b> to record <b>three</b> different states:</p><ol><li><b>unvisited</b>: same as earlier, DFS has not reach vertex <b>u</b> before,</li><li><b>explored</b>: DFS has visited vertex <b>u</b>, but at least one neighbor of vertex <b>u</b> has not been visited yet (DFS will go depth-first to that neighbor first),</li><li><b>visited</b>: now stronger definition: all neighbors of vertex <b>u</b> have also been visited and DFS is about to backtrack from vertex <b>u</b> to vertex <b>p[u]</b>.</li></ol><p>If DFS is now at vertex <b>x</b> and explore edge <b>x &rarr; y</b> and encounter <b>status[y] = explored</b>, we can declare <b>x &rarr; y</b> is a <b>back edge</b> (a cycle is found as we were previously at vertex <b>y</b> (hence <b>status[y] = explored</b>), go deep to neighbor of <b>y</b> and so on, but we are now at vertex <b>x</b> that is reachable from <b>y</b> but vertex <b>x</b> leads back to vertex <b>y</b>).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7-3" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>The edges in the graph that are not <span style="color: red;">tree edge(s)</span> nor <span style="color: lightblue;">back edge(s)</span> are colored <span style="color: grey;">grey</span>. They are called <b>forward or cross edge(s)</b> and currently have limited use (not elaborated).</p><br><p>Now try <span class="slide-actions" onclick="doButtonAction39()">DFS(0)</span> on the example graph above with this new understanding, especially about the 3 possible status of a vertex (unvisited/<span style="color: black; background-color: white;">normal black circle</span>, explored/<span style="color: lightblue;">blue circle</span>, <span style="color: orange;">visited/orange circle</span>) and <span style="color: lightblue;">back edge</span>. Edge 2 → 1 will be discovered as a back edge as it is part of cycle 1 → 3 → 2 → 1 (similarly with Edge 6 → 4 as part of cycle 4 &rightarrow; 5 &rightarrow; 7 &rightarrow; 6 &rightarrow; 4).</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-4">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7-4" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>We can use following simple recursive function to print out the path stored in array <b>p</b>. Possible follow-up discussion: Can you write this in <b>iterative</b> form? (trivial)</p><pre>method backtrack(u)<br>  if (u == -1) stop<br>  backtrack(p[u]);<br>  output vertex u<br></pre><p>To print out the path from a source vertex <b>s</b> to a target vertex <b>t</b> in a graph, you can call O(<b>V</b>+<b>E</b>) <samp>DFS(s)</samp> (or <samp>BFS(s)</samp>) and then O(<b>V</b>) <samp>backtrack(t)</samp>. Example: <b>s = 0</b> and <b>t = 4</b>, you can call <span class="slide-actions" onclick="doButtonAction39()">DFS(0)</span> and then <samp>backtrack(4)</samp>. <span id="printexample"><span class="slide-actions" onclick="doButtonAction43()">Elaborate</span></span></p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-5">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7-5" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>If you are asked to test whether a vertex <b>s</b> and a (different) vertex <b>t</b> in a graph are reachable, i.e. connected directly (via a direct edge) or indirectly (via a simple, non cyclic, path), you can call the O(<b>V</b>+<b>E</b>) <samp>DFS(s)</samp> (or <samp>BFS(s)</samp>) and check if <samp>status[t] = visited</samp>.</p><br><p>Example 1: <b>s = 0</b> and <b>t = 4</b>, run <span class="slide-actions" onclick="doButtonAction39()">DFS(0)</span> and notice that <samp>status[4] = visited</samp>.<br>Example 2: <b>s = 0</b> and <b>t = 7</b>, run <span class="slide-actions" onclick="doButtonAction39()">DFS(0)</span> and notice that <samp>status[7] = unvisited</samp>.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-4">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-6">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7-6" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>We can enumerate <b>all</b> vertices that are reachable from a vertex <b>s</b> in an <b>undirected graph</b> (as the example graph shown above) by simply calling O(<b>V</b>+<b>E</b>) <samp>DFS(s)</samp> (or <samp>BFS(s)</samp>) and enumerate all vertex <b>v</b> that has <samp>status[v] = visited</samp>.</p><br><p>Example: <b>s = 0</b>, run <span class="slide-actions" onclick="doButtonAction39()">DFS(0)</span> and notice that <samp>status[{0,1,2,3,4}] = visited</samp> so they are all reachable vertices from vertex 0, i.e. they form one <b>Connected Component (CC)</b>.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-5">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-7">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7-7" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>We can use the following pseudo-code to count the number of CCs:</p><pre>CC = 0<br>for all u in V, set status[u] = unvisited<br>for all u in V<br>  if (status[u] == unvisited)<br>    CC++ // we can use CC counter number as the CC label<br>    DFS(u) // or BFS(u), that will flag its members as visited<br>output CC // the answer is 3 for the example graph above, i.e.<br>// CC 0 = {0,1,2,3,4}, CC 1 = {5}, CC 2 = {6,7,8}</pre><p>You can modify the DFS(u)/BFS(u) code a bit if you want to use it to label each CC with the identifier of that CC.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-6">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-8">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7-8" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<input class="mcq-answer" id="mcq-answer-15" value="67" hidden><p>Quiz: <b>What is the time complexity of Counting the Number of CCs algorithm?</b></p><form><input type="radio" name="mcq-15-choice" value="67"> It is still O(V+E)<br><input type="radio" name="mcq-15-choice" value="66"> Calling O(V+E) DFS/BFS V times, so O(V*(V+E)) = O(V^2 + VE)<br><input type="radio" name="mcq-15-choice" value="68"> Trick question, the answer is none of the above, it is O(_____)<br></form><button class="mcq-submit" id="submit-15">Submit</button> <span id="answer-status-15"></span><br><br><p>Discussion: Why?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-7">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-9">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7-9" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-8">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-10">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7-10" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>There is another DFS (and also BFS) application that can be treated as &#39;simple&#39;: Performing Topological Sort(ing) of a Directed Acyclic Graph (DAG) &mdash; see example above.</p><br><p>Topological sort of a DAG is a linear ordering of the DAG&#39;s vertices in which each vertex comes before all vertices to which it has outbound edges.</p><br><p>Every DAG has at least one but possibly more topological sorts/ordering.</p><br><p>One of the main purpose of (at least one) topological sort of a DAG is for <a href="recursion.html"><u>Dynamic Programming (DP)</u></a> technique. For example, this topological sorting process is used internally in <a href="sssp.html"><u>DP solution for SSSP on DAG</u></a>.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-9">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="7-11">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-7-11" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>We can use either the O(<b>V</b>+<b>E</b>) DFS or BFS to perform Topological Sort of a Directed Acyclic Graph (DAG).</p><br><p>The DFS version requires just one additional line compared to the normal DFS and is basically the post-order traversal of the graph. Try <span class="slide-actions" onclick="doButtonAction44()">Toposort (DFS)</span> on the example DAG.</p><br><p>The BFS version is based on the idea of vertices without incoming edge and is also called as Kahn&#39;s algorithm. Try <span class="slide-actions" onclick="doButtonAction45()">Toposort (BFS/Kahn's)</span> on the example DAG.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-10">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="8">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-8" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>As of now, you have seen DFS/BFS and what it can solve (with just minor tweaks). There are a few more advanced applications that require more tweaks and we will let advanced students to explore them on their own:</p><ol><li>Bipartite Graph Checker (DFS and BFS variants),</li><li>Finding Articulation Points (Cut Vertices) and Bridges of an Undirected Graph (DFS only),</li><li>Finding Strongly Connected Components (SCCs) of a Directed Graph (Tarjan&#39;s and Kosaraju&#39;s algorithms), and</li><li>2-SAT(isfiability) Checker algorithms.</li></ol><hr><p>Advertisement: The details are written in <a href="https://cpbook.net/" target="_blank"><u>Competitive Programming book</u></a>.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="7-11">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="9">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-9" class="electure-dialog" style="top:300px;left:50%;margin-left:-250px;width:500px;">
<p>We can use the O(<b>V</b>+<b>E</b>) DFS or BFS (they work similarly) to check if a given graph is a Bipartite Graph by giving alternating color (<span style="color: orange;">orange</span> versus <span style="color: lightblue;">blue</span> in this visualization) between neighboring vertices and report &#39;non bipartite&#39; if we ends up assigning same color to two adjacent vertices or &#39;bipartite&#39; if it is possible to do such &#39;2-coloring&#39; process. Try <span class="slide-actions" onclick="doButtonAction46()">DFS_Checker</span> or <span class="slide-actions" onclick="doButtonAction47()">BFS_Checker</span> on the example Bipartite Graph.</p><br><p>Bipartite Graphs have useful applications in <a href="matching.html"><u>(Bipartite) Graph Matching problem</u></a>.</p><br><p>Note that Bipartite Graphs are usually only defined for undirected graphs so this visualization will convert directed input graphs into its undirected version automatically before continuing. This action is irreversible and you may have to redraw the directed input graph again for other purposes.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="8">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="10">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-10" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>We can modify (but unfortunately, not trivially) the O(<b>V</b>+<b>E</b>) DFS algorithm into an algorithm to find Cut Vertices &amp; Bridges of an Undirected Graph.</p><br><p>A Cut Vertex, or an Articulation Point, is a vertex of an undirected graph which removal disconnects the graph. Similarly, a bridge is an edge of an undirected graph which removal disconnects the graph.</p><br><p>Note that this algorithm for finding Cut Vertices &amp; Bridges only works for undirected graphs so this visualization will convert directed input graphs into its undirected version automatically before continuing. This action is irreversible and you may have to redraw the directed input graph again for other purposes. You can try to <span class="slide-actions" onclick="doButtonAction48()">Find Cut Vertices &amp; Bridges</span> on the example graph above.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="9">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="11">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-11" class="electure-dialog" style="top:270px;left:50%;margin-left:-250px;width:500px;">
<p>We can modify (but unfortunately, not trivially) the O(<b>V</b>+<b>E</b>) DFS algorithm into an algorithm to find Strongly Connected Components (SCCs) of a Directed Graph G.</p><br><p>An SCC of a directed graph G a is defined as a subgraph S of G such that for any two vertices u and v in S, vertex u can reach vertex v directly or via a path, and vertex v can also reach vertex u back directly or via a path.</p><br><p>There are two known algorithms for finding SCCs of a Directed Graph: Kosaraju&#39;s and Tarjan&#39;s. Both of them are available in this visualization. Try <span class="slide-actions" onclick="doButtonAction49()">Kosaraju's Algorithm</span> and/or <span class="slide-actions" onclick="doButtonAction50()">Tarjan's Algorithm</span> on the example directed graph above.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="10">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="12">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-12" class="electure-dialog" style="bottom:320px;left:60px;width:500px;">
<p>We also have the 2-SAT Checker algorithm. Given a 2-Satisfiability (2-SAT) instance in the form of conjuction of clauses: (clause<sub>1</sub>) ^ (clause<sub>2</sub>) ^ ... ^ (clause<sub>n</sub>) and each clause is in form of disjunction of up to two variables (var<sub>a</sub> v var<sub>b</sub>), determine if we can assign True/False values to these variables so that the entire 2-SAT instance is evaluated to be true, i.e. satisfiable.</p><br><p>It turns out that each clause (a v b) can be turned into four vertices a, not a, b, and not b with two edges: (not a &rarr; b) and (not b &rarr; a). Thus we have a Directed Graph. If there is at least one variable and its negation inside an SCC of such graph, we know that it is impossible to satisfy the 2-SAT instance.</p><br><p>After such directed graph modeling, we can run an SCC finding algorithm (Kosaraju&#39;s or Tarjan&#39;s algorithm) to determine the satisfiability of the 2-SAT instance.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="11">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="13">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-13" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<input class="mcq-answer" id="mcq-answer-22" value="95" hidden><p>Quiz: <b>Which Graph Traversal Algorithm is Better?</b></p><form><input type="radio" name="mcq-22-choice" value="94"> Always BFS<br><input type="radio" name="mcq-22-choice" value="95"> It Depends on the Situation<br><input type="radio" name="mcq-22-choice" value="93"> Always DFS<br><input type="radio" name="mcq-22-choice" value="96"> Both are Equally Good<br></form><button class="mcq-submit" id="submit-22">Submit</button> <span id="answer-status-22"></span><br><br><p>Discussion: Why?</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="12">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="13-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-13-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>There are lots of things that we can still do with just DFS and/or BFS...<br></p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="13-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-1" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>There are interesting questions about these two graph traversal algorithms: DFS+BFS and variants of graph traversal problems, please practice on <a href="https://visualgo.net/training?diff=Medium&amp;n=7&amp;tl=0&amp;module=dfsbfs"><u>Graph Traversal</u></a> training module (no login is required, but short and of medium difficulty setting only).</p><br><p>However, for registered users, you should login and then go to the <a href="https://visualgo.net/training"><u>Main Training Page</u></a> to officially clear this module and such achievement will be recorded in your user account.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-2" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<p>We also have a few programming problems that somewhat requires the usage of DFS and/or BFS: <a href="https://open.kattis.com/problems/reachableroads" title="" target="_blank"><u>Kattis - reachableroads</u></a> and <a href="https://open.kattis.com/problems/breakingbad" title="" target="_blank"><u>Kattis - breakingbad</u></a>.</p><br><p>Try to solve them and then try the <b>many more</b> interesting twists/variants of this simple graph traversal problem and/or algorithm.</p><br><p>You are allowed to use/modify our implementation code for DFS/BFS Algorithms:<br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/traversal/dfs_cc.cpp" target="_blank"><u>dfs_cc.cpp</u></a>/<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/bfs.cpp" target="_blank"><u>bfs.cpp</u></a><br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/traversal/dfs_cc.java" target="_blank"><u>dfs_cc.java</u></a>/<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/bfs.java" target="_blank"><u>bfs.java</u></a><br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/traversal/dfs_cc.py" target="_blank"><u>dfs_cc.py</u></a>/<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/bfs.py" target="_blank"><u>bfs.py</u></a><br><a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/traversal/dfs_cc.ml" target="_blank"><u>dfs_cc.ml</u></a>/<a href="https://github.com/stevenhalim/cpbook-code/blob/master/ch4/sssp/bfs.ml" target="_blank"><u>bfs.ml</u></a><br></p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="14-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-14-3" class="electure-dialog" style="top:60px;left:60px;width:500px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-2">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99" class="electure-dialog" style="right:150px;bottom:335px;width:500px;">
<p>As the action is being carried out, each step will be described in the status panel.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="14-3">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-1">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-1" class="electure-dialog" style="right:170px;bottom:275px;width:180px;">
<div style="background-color: white; color: black;">
<p>e-Lecture: The content of this slide is hidden and only available for legitimate CS lecturer worldwide. Drop an email to visualgo.info at gmail dot com if you want to activate this CS lecturer-only feature <b>and you are really a CS lecturer (show your University staff profile)</b>.</p>
</div>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-2">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-2" class="electure-dialog" style="bottom:70px;left:50%;margin-left:-120px;width:260px;">
<p>Control the animation with the player controls! Keyboard shortcuts are:<br></p><div style="margin-top: 8px;"><strong>Spacebar:</strong> play/pause/replay</div><strong>Left/right arrows:</strong> step backward/step forward<br><strong>-/+:</strong> decrease/increase speed<br>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99-1">Trước đó <u>PgUp</u></div>
<div class='electure-next' data-nextid="99-3">Tiếp theo <u>PgDn</u></div>
</div>
<div id="electure-99-3" class="electure-dialog" style="top:70px;right:60px;width:300px;">
<p>Return to &#39;Exploration Mode&#39; to start exploring!</p><br><p>Note that if you notice any bug in this visualization or if you want to request for a new visualization feature, do not hesitate to drop an email to the project leader: Dr Steven Halim via his email address: stevenhalim at gmail dot com.</p>
<div class='electure-end'>X <u>Esc</u></div>
<div class='electure-prev' data-nextid="99-2">Trước đó <u>PgUp</u></div>
</div>
<div id="popup" hidden>
<div id="popup-content"></div>
<span id="hide-popup" hidden>X <u>Close</u></span>
</div>
<div id="actions" class="panel">
<p id="draw" onclick=drawGraph()>Vẽ đồ thị</p>
<p id="examples">Đồ thị ví dụ</p>
<p id="dfs">Depth-First Search(s)</p>
<p id="bfs">Tìm kiếm theo chiều ngang(s)</p>
<p id="topo">Sắp xếp Topo</p>
<p id="bipartite">Kiểm tra đồ thị hai phía</p>
<p id="bridge" onclick=bridge()>Cut Vertex & Bridge</p>
<p id="scc">SCC Algorithms</p>
<p id="twosat">2-SAT Checker</p>
</div>
<div id="actions-hide" class="panel-hide"><img src="../img/arrow_white_right.png" alt=">" title='Hiện/Ẩn Trung tâm Hành động'></div>
<div id="actions-extras">
<div class="examples action-menu-pullout">
<div id="example1" class="execAction new-menu-option coloured-menu-option" onclick="example(CP3_4_1)"><p>CP3 4.1</p></div>
<div id="example2" class="execAction new-menu-option coloured-menu-option" onclick="example(CP3_4_3)"><p>CP3 4.3</p></div>
<div id="example3" class="execAction new-menu-option coloured-menu-option" onclick="example(CP3_4_4)"><p>CP3 4.4 DAG</p></div>
<div id="example4" class="execAction new-menu-option coloured-menu-option" onclick="example(CP3_4_9)"><p>CP3 4.9</p></div>
<div id="example5" class="execAction new-menu-option coloured-menu-option" onclick="example(CP3_4_17)"><p>CP3 4.17 DAG</p></div>
<div id="example6" class="execAction new-menu-option coloured-menu-option" onclick="example(CP3_4_18)"><p>CP3 4.18 DAG, Bipartite</p></div>
<div id="example7" class="execAction new-menu-option coloured-menu-option" onclick="example(CP3_4_19)"><p>CP3 4.19 Bipartite</p></div>
</div>
<div class="dfs action-menu-pullout">
<div id="dfs-input" class="new-menu-option">s = <input type="number" id="dfs-v" title='Nhập mã đỉnh nguồn' autocomplete="off" min=0 max=99 value=0></div>
<div id="dfs-go" class="execAction coloured-menu-option" onclick="dfs()"><p>Go</p></div>
<div id="dfs-err" class="err"></div>
</div>
<div class="bfs action-menu-pullout">
<div id="bfs-input" class="new-menu-option">s = <input type="number" id="bfs-v" title='Nhập mã đỉnh nguồn' autocomplete="off" min=0 max=99 value=0></div>
<div id="bfs-go" class="execAction coloured-menu-option" onclick="bfs()"><p>Go</p></div>
<div id="bfs-err" class="err"></div>
</div>
<div class="topo action-menu-pullout">
<div id="toposortDfs" class="execAction new-menu-option coloured-menu-option" onclick="toposortDfs()"><p>DFS version</p></div>
<div id="toposortBfs" class="execAction new-menu-option coloured-menu-option" onclick="toposortBfs()"><p>BFS version (Kahn&#39;s algorithm)</p></div>
<div id="topo-err" class="err"></div>
</div>
<div class="bipartite action-menu-pullout">
<div id="bipartiteDfs" class="execAction new-menu-option coloured-menu-option" onclick="bipartiteDfs()"><p>DFS version</p></div>
<div id="bipartiteBfs" class="execAction new-menu-option coloured-menu-option" onclick="bipartiteBfs()"><p>BFS version</p></div>
<div id="bipartite-err" class="err"></div>
</div>
<div class="bridge action-menu-pullout">
<div id="bridge-err" class="err"></div>
</div>
<div class="scc action-menu-pullout">
<div id="kosaraju" class="execAction new-menu-option coloured-menu-option" onclick="kosaraju()"><p>Kosaraju&#39;s Algorithm</p></div>
<div id="tarjan" class="execAction new-menu-option coloured-menu-option" onclick="tarjan()"><p>Thuật toán Tarjan</p></div>
<div id="scc-err" class="err"></div>
</div>
<div class="twosat action-menu-pullout">
<div class="new-menu-option">Number of clauses = <input type="number" id="twosat-v1" title="Enter the number of clauses" autocomplete="off" min=0 max=10 value=0>, Số lượng biến = <input type="number" id="twosat-v2" title="Enter the number of variables" autocomplete="off" min=0 max=10 value=0></div>
<div id="twosat-go" class="execAction coloured-menu-option" onclick="twosat()"><p>GO</p></div>
<div id="twosat-err" class="err"></div>
</div>
</div>
<div id="drawgraph" class="overlays"></div>
<div id="twosat-board" class="overlays"></div>
<div id="bottom-bar">
<a id="trigger-about">Về</a>
<a id="trigger-team">Nhóm</a>
<a id="trigger-terms">Điều khoản sử dụng</a>
</div>
<div id="about" class="overlays">
<h4>Về</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
VisuAlgo được lên ý tưởng vào năm 2011 bởi tiến sĩ Steven Halim như là một công cụ để giúp những sinh viên của ông ấy có thể hiểu rõ hơn về các cấu trúc dữ liệu và thuật toán, bằng cách cho phép họ tự học những nội dung cơ bản nhất với tiến độ phù hợp với riêng họ.<br>VisuAlgo chứa rất nhiều thuật toán nâng cao đã được thảo luận trong cuốn sách của Tiến sĩ Steven Halim (&#39;Competitive Programming&#39;, đồng tác giả với anh trai của ông ấy, tiến sĩ Felix Halim) và hơn thế nữa. Hiện tại, một số mô phỏng/hiệu ứng hoạt hình của các thuật toán nâng cao này chỉ có thể tìm thấy ở VisuAlgo.<div>Mặc dù được thiết kế đặc biệt cho những sinh viên đại học quốc gia Singapore (phải học rất nhiều môn học về cấu trúc dữ liệu và thuật toán - ví dụ: CS1010, CS1020, CS2010, CS2020, CS3230, and CS3230), như những người ủng hộ việc học trực tuyến, chúng tôi hi vọng rằng những người quan tâm tới cấu trúc dữ liệu và thuật toán trên toàn thế giới cũng có thể thấy những mô tả này là hữu dụng.<br>Ngay từ đầu, VisuAlgo không được thiết kế để làm việc tốt trên những màn hình cảm ứng nhỏ (ví dụ như smartphones) do việc mô phỏng các thuật toán phức tạp cần rất nhiều điểm ảnh và cử chỉ nhấp và kéo để tương tác. Độ phân giải màn ảnh nhỏ nhất cho trải nghiệm người dùng chấp nhận được là 1024x768 và chỉ có duy nhất trang đích là tương đối thân thiện với bản di động.</div><div>VisuAlgo là một dự án liên tục và nhiều mô phỏng phức tạp vẫn đang được phát triển.<br>Cải tiến thú vị nhất là tạo và duyệt câu hỏi tự động (hệ thống câu hỏi trực tuyến) cho phép sinh viên kiểm tra kiến thức cơ bản về các cấu trúc dữ liệu và thuật toán. Các câu hỏi được tạo ngẫu nhiên thông qua những quy luật và câu trả lời của sinh viên sẽ được chấm điểm tự động và ngay lập tức dựa trên việc nộp bài tới server chấm điểm của chúng tôi. Hệ thống câu hỏi trực tuyến này, khi mà nó được chấp nhận bởi nhiều giảng viên CS trên toàn thế giới, sẽ xóa bỏ mặt kĩ thuật các câu hỏi về cấu trúc dữ liệu và thuật toán cơ bản khỏi các kỳ thi khoa học máy tính điển hình tại rất nhiều trường đại học. Bằng cách đặt một tiêu chí chấm điểm nhỏ (nhưng khác 0) vào việc vượt qua các câu hỏi trực tuyến, giảng viên CS có thể làm tăng (một cách đáng kể) sự thành thạo của những sinh viên trên những câu hỏi cơ bản này khi họ một lượng vô số các câu hỏi thực tế cho sự luyện tập cái mà có thể được kiểm chứng ngay lập tức trước khi họ làm câu hỏi trực tuyến. Hiện tại, chế độ hướng dẫn bao gồm các câu hỏi cho 12 module mô phỏng. Chúng tôi sẽ sớm thêm vào 8 module mô phỏng còn lại để cho tất cả các module mô phỏng ở VisuAlgo đều có phần câu hỏi trực tuyến.<br>Một cải tiến hấp dẫn khác là việc quốc tế hóa các dự án nhánh của VisuAlgo. Chúng tôi muốn chuẩn bị cơ sở dữ liệu các thuật ngữ CS cho các văn bản tiếng Anh đã từng xuất hiện trên hệ thống VisuAlgo. Đây là một nhiệm vụ lớn và cần điện toán đám đông. Một khi hệ thống đã sẵn sàng, chúng tôi sẽ mời người dùng VisuAlgo đóng góp, đặc biệt là khi bạn không phải là người nói tiếng Anh bản ngữ. Hiện tại, chúng tôi cũng đang viết những ghi chú về VisuAlgo bằng những ngôn ngữ khác nhau.<br></div>
<a href="https://weibo.com/p/230418436e9ee80102v4rk" target='_blank'><u>zh</u></a>, <a href='https://www.facebook.com/notes/steven-halim/httpidvisualgonet-visualisasi-struktur-data-dan-algoritma-dengan-animasi/10153236934439689' target='_blank'><u>id</u></a>, <a href="https://blog.naver.com/visualgo_nus" target='_blank'><u>kr</u></a>, <a href='https://www.facebook.com/groups/163215593699283/permalink/824003417620494/' target='_blank'><u>vn</u></a>, <a href='http://pantip.com/topic/32736343' target='_blank'><u>th</u></a>.</p>
</div>
</div>
<div id="team" class="overlays">
<h4>Nhóm</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
<p>
<strong><span style='line-height: 150%;'>Trưởng dự án và cố vấn (từ tháng 7/2011 đến nay)</span></strong><br>
<a href='http://www.comp.nus.edu.sg/~stevenha/' target='_blank'>Dr Steven Halim</a>, Senior Lecturer, School of Computing (SoC), National University of Singapore (NUS)<br>
<a href='http://felix-halim.net/' target='_blank'>Dr Felix Halim</a>, Software Engineer, Google (Mountain View)
</p>
<p>
<strong><span style='line-height: 150%;'>Những nhà nghiên cứu sinh viên 1 (Jul 2011-Apr 2012)</span></strong><br>
Koh Zi Chun, <a href='http://roticv.rantx.com/' target='_blank'>Victor Loh Bo Huai</a>
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 1 (Jul 2012-Dec 2013)</span></strong><br>
Phan Thi Quynh Trang, Peter Phandi, Albert Millardo Tjindradinata, Nguyen Hoang Duy
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 2 (Jun 2013-Apr 2014)</span></strong><br>
<a href='http://www.rosemarietan.com/' target='_blank'>Rose Marie Tan Zhao Yun</a>, Ivan Reinaldo
</p>
<p>
<strong><span style='line-height: 150%;'>Những nhà nghiên cứu sinh viên 2 (May 2014-Jul 2014)</span></strong><br>
Jonathan Irvin Gunawan, Nathan Azaria, Ian Leow Tze Wei, Nguyen Viet Dung, Nguyen Khac Tung, Steven Kester Yuwono, Cao Shengze, Mohan Jishnu
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 3 (Jun 2014-Apr 2015)</span></strong><br>
Erin Teo Yi Ling, Wang Zi
</p>
<p>
<strong><span style='line-height: 150%;'>Đồ án năm cuối/ sinh viên UROP 4 (Jun 2016-Dec 2017)</span></strong><br>
Truong Ngoc Khanh, John Kevin Tjahjadi, Gabriella Michelle, Muhammad Rais Fathin Mudzakir
</p>
<p>
List of translators who have contributed &ge;100 translations can be found at <a href="https://visualgo.net/statistics">statistics</a> page.
</p>
<p>
<strong><span style='line-height: 150%;'>Lời cảm ơn</span></strong><br>
This project is made possible by the generous <a href="http://www.cdtl.nus.edu.sg/teg/" target="_blank">Teaching Enhancement Grant</a> from NUS Centre for Development of Teaching and Learning (CDTL).
</p>
</div>
</div>
<div id="termsofuse" class="overlays">
<h4>Điều khoản sử dụng</h4><span class='close-overlay'>&#x2715;</span>
<div class='content'>
VisuAlgo miễn phí đối với cộng đồng Khoa học Máy tính trên toàn thế giới. Nếu bạn yêu thích VisuAlgo, khoản chi phí duy nhất mà chúng tôi muốn bạn chi trả chính là hãy nói cho những <b>sinh viên/ giảng viên ngành khoa học máy tính</b> mà bạn biết<b> về sự tồn tại của VisuAlgo</b> =) thông qua Facebook, Twitter, trang web về khóa học, blog review, email , v.v &amp; v.v. Nếu bạn là một<b> sinh viên/ giảng viên</b> ngành cấu trúc dữ liệu và thuật toán, bạn được phép sử dụng website này một cách trực tiếp trong các lớp học của bạn. Nếu bạn lấy những ảnh chụp màn hình (videos) từ website này, bạn có thể sử dụng chúng ở bất kỳ đâu, miễn là có dẫn nguồn URL của website này (http://visualgo.net) và/hoặc liệt kê các công bố ở dưới như là tài liệu tham khảo. Tuy nhiên, bạn <b>KHÔNG</b> được phép tải xuống các tập tin VisuAlgo (phía máy trạm) và lưu trữ nó ở website riêng của bạn vì nó được coi là <b>đạo ý tưởng</b> .Hiện tại, chúng tôi <b>KHÔNG</b> cho phép những người khác chia nhỏ dự án này và tạo ra những phiên bản khác của VisuAlgo. Việc sử dụng bản sao ngoại tuyến của VisuAlgo (phía máy trạm) cho mục đích cá nhân của bạn thì có thể chấp nhận được.<br>Lưu ý rằng hệ thống câu hỏi trực tuyến của VisuAlgo có phần dữ liệu phía máy chủ rất lớn và không dễ dàng để lưu lại mã kịch bản phía máy chủ và cơ sở dữ liệu một cách cục bộ. Hiện tại, mọi người chỉ có thể sử dụng "chế độ đào tạo" để truy cập hệ thống câu hỏi trực tuyến này. Chế độ kiểm tra hiện là môi trường có kiểm soát hơn cho việc sử dụng những câu hỏi được tạo ngẫu nhiên này và tự động kiểm duyệt cho kỳ thi <b>thật sự</b> tại Đại học Quốc gia Singapore<span style="white-space: normal;">.</span> Những giảng viên quan tâm tới khoa học máy tính có thể liên hệ với Steven nếu muốn trải nghiệm "chế độ kiểm tra"<br><b>Danh sách phát hành</b><br>Dự án này đươc trình bày một cách vắn tắt ở Hội thảo CLI tại ACM ICPC World Finals 2012 (Warsaw, Ba Lan) và tại Hội nghị IOI 2012 (Sirmione-Montichiari, Italy). Bạn có thể nhấn vào link này để đọc bài viết năm 2012 của chúng tôi về hệ thống này (nó không được gọi là VisuAlgo vào năm 2012)<br>Dự án này được hoàn thiện hầu hết bởi những cựu sinh viên của tôi. Báo cáo cuối cùng gần đây nhất là của: <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/erin-report.pdf" target="_blank">Erin</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/wangzi-report.pdf" target="_blank">Wang Zi</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/rose-report.pdf" target="_blank">Rose</a>, <a href="http://188.166.247.199/visualgo/visualgo-laravel/public/translation/fyp/ivan-report.pdf" target="_blank">Ivan</a>.<br><b>Báo cáo lỗi hoặc đề xuất tính năng mới</b><br>VisuAlgo là một dự án chưa hoàn thiện. Tiến sĩ Steven Halim vẫn đang tiếp tục phát triển VisuAlgo một cách tích cực/ Nếu bạn đang sử dụng VisuAlgo và phát hiện ra lỗi ở bất kỳ trang mô phỏng/ công cụ câu hỏi trực tuyến nào của chúng tôi hoặc nếu bạn muốn đề xuất những tính năng mới, hãy liên lạc với Tiến sĩ Steven Halim. Địa chỉ liên lạc của ông ấy là stevenhalim@gmail.com<br>
</div>
</div>

<script src="../js/jquery-3.3.1.min.js"></script>
<script>
      var PHP_DOMAIN = "";

      // surprise colour!
      // Referenced to in  home.js and viz.js also
      var colourArray = ["#52bc69", "#d65775"/*"#ed5a7d"*/, "#2ebbd1", "#d9513c", "#fec515", "#4b65ba", "#ff8a27", "#a7d41e"]; // green, pink, blue, red, yellow, indigo, orange, lime

      function disableScroll() { $('html').css('overflow', 'hidden'); }

      function enableScroll() { $('html').css('overflow', 'visible'); }

      function replaceAll(find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); }

      function getColours() {
        var generatedColours = new Array();
        while (generatedColours.length < 4) {
          var n = (Math.floor(Math.random() * colourArray.length));
          if ($.inArray(n, generatedColours) == -1)
            generatedColours.push(n);
        }
        return generatedColours;
      }

      function isOn(value, position) {
        return (value>>position) & 1 === 1;
      }

      function customAlert(msg) {
        $('#custom-alert p').html(msg);
        var m = -1 * ($('#custom-alert').outerHeight()/2);
        $('#custom-alert').css('margin-top', m+'px');
        $('#dark-overlay').fadeIn(function() {
          $('#custom-alert').fadeIn(function() {
            setTimeout(function() {
              $('#custom-alert').fadeOut(function() {
                $('#dark-overlay').fadeOut();
              });
            }, 1000);
          });
        });
      }

      function showLoadingScreen() {
        $('#loading-overlay').show();
        $('#loading-message').show();
      }

      function hideLoadingScreen() {
        $('#loading-overlay').hide();
      }

      function commonAction(retval, msg) {
        //setTimeout(function() {
          if (retval) { // mode == "exploration" && // now not only for exploration mode, but check if this opens other problems
            $('#current-action').show();
            $('#current-action').html(mode == "exploration" ? msg : ("e-Lecture Example (auto play until done)<br>" + msg));
            $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
            triggerRightPanels();
            isPlaying = true;
          }
        //}, 500);
      }

      function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; i++) {
          var pair = vars[i].split('=');
          if (decodeURIComponent(pair[0]) == variable)
            return decodeURIComponent(pair[1]);
        }
        return "";
      }

      var generatedColours = getColours();
      var surpriseColour = colourArray[generatedColours[0]];
      var colourTheSecond = colourArray[generatedColours[1]];
      var colourTheThird = colourArray[generatedColours[2]];
      var colourTheFourth = colourArray[generatedColours[3]];

      $(function() {
        $('.links').css('background', surpriseColour);
        $('.right-links').css('background', surpriseColour);
        $('#login-go').css('background', surpriseColour);

        $('.colour').css("color", surpriseColour); // name
        $('h4').css("background-color", surpriseColour); // about, contact us etc. button background

        // title
        $('#title a').click(function() {
          $('#title a').removeClass('selected-viz');
          $(this).addClass('selected-viz');
          // temporary quick fix for Google Chrome Aug 2016 issue...
          setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 100); // force resize/redraw...
          setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        });

        // overlays stuffs
        $('#trigger-about').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#about').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('#trigger-team').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#team').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('#trigger-terms').click(function() {
          if ($(window).width() > 600) {
            $('#dark-overlay').fadeIn(function() {
              $('#termsofuse').fadeIn();
            });
          }
          else
            alert('Sorry, this dialog is too big. Please load it on bigger screen');
        });

        $('.close-overlay').click(function() {
          $('.overlays').fadeOut(function() {
            $('#dark-overlay').fadeOut();
          });
        });

        $('#dark-overlay').click(function() {
          $('.overlays').fadeOut();
          $('#dark-overlay').fadeOut();
        });

        $.get('/isloggedin', function(data) {
          var isLoggedIn = data['isloggedin'] == '1';
          var element;
          if (isLoggedIn) {
            // element = '<a onclick="verifyLogout()">Đăng Xuất<div><br></div></a>';
            element = '<a href="https://visualgo.net/profile">Profile</a>'; 
          }
          else {
            element = '<a href="https://visualgo.net/login">Đăng nhập</a>'
          }
          $('#useraccount').html(element);
        });
      });

      function verifyLogout() {
        // Steven's remarks: use a better 'confirm' than the default :(
        var doesLogout = confirm('Are you sure to logout?');
        if (doesLogout == true) {
          window.location = "https://visualgo.net/logout";
        }
      }

      function checkLogin() {
        $.get('/checklogin', function(data) {
          var url = data['url'];
          window.location.href = '/' + url;
        });
      }

      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','../../www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-1566631-4', 'auto');
      ga('send', 'pageview');
    </script>

<script src="../js/jquery-ui.min.js"></script>

<script src="../js/d3.min.js"></script>
<script src="../js/viz-1.0.3.js"></script>
<script src="../js/visualgo_print.js"></script>
<script src="../js/graph_library.js"></script>
<script>
      function runSlide(slide) {
        if (slide == '1') {
          $("#e-lecture").html("slide " + slide + " (" + 2 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '2') {
          $("#e-lecture").html("slide " + slide + " (" + 4 + "%)");
          example(CP3_4_1);
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '3') {
          $("#e-lecture").html("slide " + slide + " (" + 6 + "%)");
          $("#draw").addClass("menu-highlighted");
$("#random").addClass("menu-highlighted");
$("#examples").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4') {
          $("#e-lecture").html("slide " + slide + " (" + 8 + "%)");
          loadGraph({
  'vl': {
    0: { "x": 100, "y": 50  },
    1: { "x":  50, "y": 150 },
    2: { "x": 150, "y": 150 },
    3: { "x": 125, "y": 250 },
    4: { "x": 175, "y": 250 },
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 1 },
    2: { "u": 2, "v": 3, "w": 1 },
    3: { "u": 2, "v": 4, "w": 1 },
  }
});
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-1') {
          $("#e-lecture").html("slide " + slide + " (" + 10 + "%)");
          loadGraph({
  'vl': {
    0: { "x": 100, "y": 150 },
    1: { "x":  50, "y": 50  },
    2: { "x": 150, "y": 50  },
    3: { "x": 175, "y": 150 },
    4: { "x": 225, "y": 150 },
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 1 },
    2: { "u": 2, "v": 3, "w": 1 },
    3: { "u": 2, "v": 4, "w": 1 },
    4: { "u": 1, "v": 0, "w": 1 },
    5: { "u": 2, "v": 0, "w": 1 },
    6: { "u": 3, "v": 2, "w": 1 },
    7: { "u": 4, "v": 2, "w": 1 },
  }
});
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-2') {
          $("#e-lecture").html("slide " + slide + " (" + 12 + "%)");
          loadGraph({
  'vl': {
    0: { "x": 100, "y": 50  },
    1: { "x":  50, "y": 150 },
    2: { "x": 150, "y": 150 },
    3: { "x": 125, "y": 250 },
    4: { "x": 175, "y": 250 },
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 1 },
    2: { "u": 2, "v": 3, "w": 1 },
    3: { "u": 2, "v": 4, "w": 1 },
  }
});
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-3') {
          $("#e-lecture").html("slide " + slide + " (" + 14 + "%)");
          loadGraph({
  'vl': {
    0: { "x": 100, "y": 50  },
    1: { "x":  50, "y": 150 },
    2: { "x": 150, "y": 150 },
    3: { "x": 125, "y": 250 },
    4: { "x": 175, "y": 250 },
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 1 },
    2: { "u": 2, "v": 3, "w": 1 },
    3: { "u": 2, "v": 4, "w": 1 },
  }
});
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-4') {
          $("#e-lecture").html("slide " + slide + " (" + 16 + "%)");
          loadGraph({
  'vl': {
    0: { "x": 100, "y": 50  },
    1: { "x":  50, "y": 150 },
    2: { "x": 150, "y": 150 },
    3: { "x": 125, "y": 250 },
    4: { "x": 175, "y": 250 },
  },
  'el': {
    0: { "u": 0, "v": 1, "w": 1 },
    1: { "u": 0, "v": 2, "w": 1 },
    2: { "u": 2, "v": 3, "w": 1 },
    3: { "u": 2, "v": 4, "w": 1 },
  }
});
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '4-5') {
          $("#e-lecture").html("slide " + slide + " (" + 18 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5') {
          $("#e-lecture").html("slide " + slide + " (" + 20 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
example(CP3_4_1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-1') {
          $("#e-lecture").html("slide " + slide + " (" + 22 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-2') {
          $("#e-lecture").html("slide " + slide + " (" + 24 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-3') {
          $("#e-lecture").html("slide " + slide + " (" + 26 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-4') {
          $("#e-lecture").html("slide " + slide + " (" + 28 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-5') {
          $("#e-lecture").html("slide " + slide + " (" + 30 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
example(CP3_4_1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-6') {
          $("#e-lecture").html("slide " + slide + " (" + 32 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-7') {
          $("#e-lecture").html("slide " + slide + " (" + 34 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '5-8') {
          $("#e-lecture").html("slide " + slide + " (" + 36 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6') {
          $("#e-lecture").html("slide " + slide + " (" + 38 + "%)");
          $("#bfs").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6-1') {
          $("#e-lecture").html("slide " + slide + " (" + 40 + "%)");
          $("#bfs").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6-2') {
          $("#e-lecture").html("slide " + slide + " (" + 42 + "%)");
          $("#bfs").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6-3') {
          $("#e-lecture").html("slide " + slide + " (" + 44 + "%)");
          $("#bfs").click().addClass("menu-highlighted");
example(CP3_4_3);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '6-4') {
          $("#e-lecture").html("slide " + slide + " (" + 46 + "%)");
          $("#bfs").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7') {
          $("#e-lecture").html("slide " + slide + " (" + 48 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
$("#bfs").addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-1') {
          $("#e-lecture").html("slide " + slide + " (" + 50 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
example(CP3_4_9);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-2') {
          $("#e-lecture").html("slide " + slide + " (" + 52 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
example(CP3_4_9);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-3') {
          $("#e-lecture").html("slide " + slide + " (" + 54 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
example(CP3_4_9);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-4') {
          $("#e-lecture").html("slide " + slide + " (" + 56 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
$("#bfs").addClass("menu-highlighted");
example(CP3_4_1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-5') {
          $("#e-lecture").html("slide " + slide + " (" + 58 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
$("#bfs").addClass("menu-highlighted");
example(CP3_4_1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-6') {
          $("#e-lecture").html("slide " + slide + " (" + 60 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
$("#bfs").addClass("menu-highlighted");
example(CP3_4_1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-7') {
          $("#e-lecture").html("slide " + slide + " (" + 62 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
$("#bfs").addClass("menu-highlighted");
example(CP3_4_1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-8') {
          $("#e-lecture").html("slide " + slide + " (" + 64 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
$("#bfs").addClass("menu-highlighted");
example(CP3_4_1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-9') {
          $("#e-lecture").html("slide " + slide + " (" + 66 + "%)");
          $("#dfs").click().addClass("menu-highlighted");
$("#bfs").addClass("menu-highlighted");
example(CP3_4_1);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-10') {
          $("#e-lecture").html("slide " + slide + " (" + 68 + "%)");
          $("#topo").click().addClass("menu-highlighted");
example(CP3_4_4);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '7-11') {
          $("#e-lecture").html("slide " + slide + " (" + 70 + "%)");
          $("#topo").click().addClass("menu-highlighted");
example(CP3_4_4);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '8') {
          $("#e-lecture").html("slide " + slide + " (" + 72 + "%)");
          $("#bipartite").click().addClass("menu-highlighted");
$("#bridge").addClass("menu-highlighted");
$("#scc").addClass("menu-highlighted");
$("#twosat").addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '9') {
          $("#e-lecture").html("slide " + slide + " (" + 74 + "%)");
          $("#bipartite").click().addClass("menu-highlighted");
example(CP3_4_18);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '10') {
          $("#e-lecture").html("slide " + slide + " (" + 76 + "%)");
          $("#bridge").addClass("menu-highlighted");
example(CP3_4_9);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '11') {
          $("#e-lecture").html("slide " + slide + " (" + 78 + "%)");
          $("#scc").click().addClass("menu-highlighted");
example(CP3_4_9);
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '12') {
          $("#e-lecture").html("slide " + slide + " (" + 80 + "%)");
          $("#twosat").click().addClass("menu-highlighted");
          showActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13') {
          $("#e-lecture").html("slide " + slide + " (" + 82 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '13-1') {
          $("#e-lecture").html("slide " + slide + " (" + 84 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14') {
          $("#e-lecture").html("slide " + slide + " (" + 86 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-1') {
          $("#e-lecture").html("slide " + slide + " (" + 88 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-2') {
          $("#e-lecture").html("slide " + slide + " (" + 90 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '14-3') {
          $("#e-lecture").html("slide " + slide + " (" + 92 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99') {
          $("#e-lecture").html("slide " + slide + " (" + 94 + "%)");
          
          hideEntireActionsPanel();
 
          showStatusPanel();
          showCodetracePanel();
      
        }
        if (slide == '99-1') {
          $("#e-lecture").html("slide " + slide + " (" + 96 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99-2') {
          $("#e-lecture").html("slide " + slide + " (" + 98 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
        if (slide == '99-3') {
          $("#e-lecture").html("slide " + slide + " (" + 100 + "%)");
          
          hideEntireActionsPanel();
          hideStatusPanel();
          hideCodetracePanel();
      
        }
      }

      window.onpopstate = function(event) {
        var slide = event.state['slide'];
        openSlide(slide, function() {
          runSlide(slide);
        });
      };

      function getUrlParameter(sParam) {
        var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'), sParameterName, i;

        for (i = 0; i < sURLVariables.length; i++) {
          sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] === sParam) return sParameterName[1] === undefined ? true : sParameterName[1];
        }
      };

      function pushState(slideValue) {
        var url = '/vi/dfsbfs';
        if (typeof slideValue != 'undefined' && slideValue != null) url += '?slide=' + slideValue;
        window.history.pushState({slide: slideValue}, "slide " + slideValue, url);
      }

      function showPopup(callback) {
        $('#popup').fadeIn(100, callback);
      }

      function hidePopup(callback) {
        $('#popup').fadeOut(100, callback);
      }

      function showOverlay() {
        $('#overlay').css('opacity', 0.5); 
        $('#overlay').show();
      }

      function hideOverlay() {
        $('#overlay').hide();
        $("#e-lecture").html("");
      }

      function makeOverlayTransparent() {
        $('#overlay').css('opacity', 0);
      }

      function hideSlide(callback) {
        isPlaying = true;
        closeSlide(cur_slide, function() {
          makeOverlayTransparent();
          setTimeout(callback, 700); // don't immediately run the animation, wait for 500ms+ first
        });
      }

      function showSlide() {
        isPlaying = false;
        openSlide(cur_slide);
        showOverlay();
      }

      $(function() {
        var slide = getUrlParameter('slide');
        
        $.get('/hasvisited' + '/dfsbfs', function(data) {
          var hasVisited = data['hasvisited'] == '1';
          if (!hasVisited) {
            var postData = {
              '_token': 'iVivZ7KRPe6XK7pbuGtOoEjljE1xyBVNhLKNFuF8',
              'page': '/dfsbfs'.substring(1),
            };

            $.post("/visitpage", postData, function(data) {
              // non critical request...
            });

            if (typeof slide != undefined && slide != null) {
              cur_slide = slide;
            }

            $("#mode-menu a").trigger("click");
          }
          else {
            if (typeof slide != undefined && slide != null) {
              cur_slide = slide;
              $('#mode-menu a').click();
            }    
          }
        }).fail(function() {
          if (typeof slide != undefined && slide != null) {
            cur_slide = slide;
            $('#mode-menu a').click();
          }
        });

        $('.mcq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#mcq-answer-' + questionId).val();
          var userAnswer = $('input[type=radio][name=mcq-'+questionId+'-choice]:checked').val();

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green"><b>Correct!</b></font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red"><b>Wrong Answer! Try again...</b></font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('.msq-submit').click(function() {
          var questionId = parseInt($(this).attr('id').split('-')[1]);
          var answer = $('#msq-answer-' + questionId).val();

          var answers = [];
          $('input[type=checkbox][class=msq-choice]:checked').each(function() {
            answers.push($(this).attr('id').split('-')[3]);
          });
          answers.sort();
          var userAnswer = answers.join(',');

          if (answer === userAnswer) {
            $('#answer-status-' + questionId).html('<font color="green">Correct!</font>');
          }
          else {
            $('#answer-status-' + questionId).html('<font color="red">Wrong Answer! Try again...</font>');
          }
          $('#answer-status-' + questionId).show();
          setTimeout(function() {
            $('#answer-status-' + questionId).fadeOut(1000);
          }, 1000);
        });

        $('select.lecture-dropdown').change(function() {
          var nextSlide = $(this).val();
          openSlide(nextSlide, function() {
            runSlide(nextSlide);
            pushState(nextSlide);
          });
        });

        $('#hide-popup').click(function() {
          hidePopup();
        });

        $('#popup').hover(function() {
          $('#hide-popup').show();
        }, function() {
          $('#hide-popup').hide();
        });

        $('#electure-1 .electure-next').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
      
        $('#electure-2 .electure-next').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
        $('#electure-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('1');
          pushState('1');
        });
      
        $('#electure-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
        $('#electure-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('2');
          pushState('2');
        });
      
        $('#electure-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
        $('#electure-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('3');
          pushState('3');
        });
      
        $('#electure-4-1 .electure-next').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
        $('#electure-4-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('4');
          pushState('4');
        });
      
        $('#electure-4-2 .electure-next').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
        $('#electure-4-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-1');
          pushState('4-1');
        });
      
        $('#electure-4-3 .electure-next').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
        $('#electure-4-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-2');
          pushState('4-2');
        });
      
        $('#electure-4-4 .electure-next').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
        $('#electure-4-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-3');
          pushState('4-3');
        });
      
        $('#electure-4-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
        $('#electure-4-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-4');
          pushState('4-4');
        });
      
        $('#electure-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
        $('#electure-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('4-5');
          pushState('4-5');
        });
      
        $('#electure-5-1 .electure-next').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
        $('#electure-5-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('5');
          pushState('5');
        });
      
        $('#electure-5-2 .electure-next').click(function() {
          hidePopup();
          runSlide('5-3');
          pushState('5-3');
        });
        $('#electure-5-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-1');
          pushState('5-1');
        });
      
        $('#electure-5-3 .electure-next').click(function() {
          hidePopup();
          runSlide('5-4');
          pushState('5-4');
        });
        $('#electure-5-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-2');
          pushState('5-2');
        });
      
        $('#electure-5-4 .electure-next').click(function() {
          hidePopup();
          runSlide('5-5');
          pushState('5-5');
        });
        $('#electure-5-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-3');
          pushState('5-3');
        });
      
        $('#electure-5-5 .electure-next').click(function() {
          hidePopup();
          runSlide('5-6');
          pushState('5-6');
        });
        $('#electure-5-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-4');
          pushState('5-4');
        });
      
        $('#electure-5-6 .electure-next').click(function() {
          hidePopup();
          runSlide('5-7');
          pushState('5-7');
        });
        $('#electure-5-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-5');
          pushState('5-5');
        });
      
        $('#electure-5-7 .electure-next').click(function() {
          hidePopup();
          runSlide('5-8');
          pushState('5-8');
        });
        $('#electure-5-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-6');
          pushState('5-6');
        });
      
        $('#electure-5-8 .electure-next').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
        $('#electure-5-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-7');
          pushState('5-7');
        });
      
        $('#electure-6 .electure-next').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
        $('#electure-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('5-8');
          pushState('5-8');
        });
      
        $('#electure-6-1 .electure-next').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
        $('#electure-6-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('6');
          pushState('6');
        });
      
        $('#electure-6-2 .electure-next').click(function() {
          hidePopup();
          runSlide('6-3');
          pushState('6-3');
        });
        $('#electure-6-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-1');
          pushState('6-1');
        });
      
        $('#electure-6-3 .electure-next').click(function() {
          hidePopup();
          runSlide('6-4');
          pushState('6-4');
        });
        $('#electure-6-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-2');
          pushState('6-2');
        });
      
        $('#electure-6-4 .electure-next').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
        $('#electure-6-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-3');
          pushState('6-3');
        });
      
        $('#electure-7 .electure-next').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
        $('#electure-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('6-4');
          pushState('6-4');
        });
      
        $('#electure-7-1 .electure-next').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
        $('#electure-7-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('7');
          pushState('7');
        });
      
        $('#electure-7-2 .electure-next').click(function() {
          hidePopup();
          runSlide('7-3');
          pushState('7-3');
        });
        $('#electure-7-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-1');
          pushState('7-1');
        });
      
        $('#electure-7-3 .electure-next').click(function() {
          hidePopup();
          runSlide('7-4');
          pushState('7-4');
        });
        $('#electure-7-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-2');
          pushState('7-2');
        });
      
        $('#electure-7-4 .electure-next').click(function() {
          hidePopup();
          runSlide('7-5');
          pushState('7-5');
        });
        $('#electure-7-4 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-3');
          pushState('7-3');
        });
      
        $('#electure-7-5 .electure-next').click(function() {
          hidePopup();
          runSlide('7-6');
          pushState('7-6');
        });
        $('#electure-7-5 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-4');
          pushState('7-4');
        });
      
        $('#electure-7-6 .electure-next').click(function() {
          hidePopup();
          runSlide('7-7');
          pushState('7-7');
        });
        $('#electure-7-6 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-5');
          pushState('7-5');
        });
      
        $('#electure-7-7 .electure-next').click(function() {
          hidePopup();
          runSlide('7-8');
          pushState('7-8');
        });
        $('#electure-7-7 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-6');
          pushState('7-6');
        });
      
        $('#electure-7-8 .electure-next').click(function() {
          hidePopup();
          runSlide('7-9');
          pushState('7-9');
        });
        $('#electure-7-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-7');
          pushState('7-7');
        });
      
        $('#electure-7-9 .electure-next').click(function() {
          hidePopup();
          runSlide('7-10');
          pushState('7-10');
        });
        $('#electure-7-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-8');
          pushState('7-8');
        });
      
        $('#electure-7-10 .electure-next').click(function() {
          hidePopup();
          runSlide('7-11');
          pushState('7-11');
        });
        $('#electure-7-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-9');
          pushState('7-9');
        });
      
        $('#electure-7-11 .electure-next').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
        $('#electure-7-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-10');
          pushState('7-10');
        });
      
        $('#electure-8 .electure-next').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
        $('#electure-8 .electure-prev').click(function() {
          hidePopup();
          runSlide('7-11');
          pushState('7-11');
        });
      
        $('#electure-9 .electure-next').click(function() {
          hidePopup();
          runSlide('10');
          pushState('10');
        });
        $('#electure-9 .electure-prev').click(function() {
          hidePopup();
          runSlide('8');
          pushState('8');
        });
      
        $('#electure-10 .electure-next').click(function() {
          hidePopup();
          runSlide('11');
          pushState('11');
        });
        $('#electure-10 .electure-prev').click(function() {
          hidePopup();
          runSlide('9');
          pushState('9');
        });
      
        $('#electure-11 .electure-next').click(function() {
          hidePopup();
          runSlide('12');
          pushState('12');
        });
        $('#electure-11 .electure-prev').click(function() {
          hidePopup();
          runSlide('10');
          pushState('10');
        });
      
        $('#electure-12 .electure-next').click(function() {
          hidePopup();
          runSlide('13');
          pushState('13');
        });
        $('#electure-12 .electure-prev').click(function() {
          hidePopup();
          runSlide('11');
          pushState('11');
        });
      
        $('#electure-13 .electure-next').click(function() {
          hidePopup();
          runSlide('13-1');
          pushState('13-1');
        });
        $('#electure-13 .electure-prev').click(function() {
          hidePopup();
          runSlide('12');
          pushState('12');
        });
      
        $('#electure-13-1 .electure-next').click(function() {
          hidePopup();
          runSlide('14');
          pushState('14');
        });
        $('#electure-13-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('13');
          pushState('13');
        });
      
        $('#electure-14 .electure-next').click(function() {
          hidePopup();
          runSlide('14-1');
          pushState('14-1');
        });
        $('#electure-14 .electure-prev').click(function() {
          hidePopup();
          runSlide('13-1');
          pushState('13-1');
        });
      
        $('#electure-14-1 .electure-next').click(function() {
          hidePopup();
          runSlide('14-2');
          pushState('14-2');
        });
        $('#electure-14-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('14');
          pushState('14');
        });
      
        $('#electure-14-2 .electure-next').click(function() {
          hidePopup();
          runSlide('14-3');
          pushState('14-3');
        });
        $('#electure-14-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-1');
          pushState('14-1');
        });
      
        $('#electure-14-3 .electure-next').click(function() {
          hidePopup();
          runSlide('99');
          pushState('99');
        });
        $('#electure-14-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-2');
          pushState('14-2');
        });
      
        $('#electure-99 .electure-next').click(function() {
          hidePopup();
          runSlide('99-1');
          pushState('99-1');
        });
        $('#electure-99 .electure-prev').click(function() {
          hidePopup();
          runSlide('14-3');
          pushState('14-3');
        });
      
        $('#electure-99-1 .electure-next').click(function() {
          hidePopup();
          runSlide('99-2');
          pushState('99-2');
        });
        $('#electure-99-1 .electure-prev').click(function() {
          hidePopup();
          runSlide('99');
          pushState('99');
        });
      
        $('#electure-99-2 .electure-next').click(function() {
          hidePopup();
          runSlide('99-3');
          pushState('99-3');
        });
        $('#electure-99-2 .electure-prev').click(function() {
          hidePopup();
          runSlide('99-1');
          pushState('99-1');
        });
      
        $('#electure-99-3 .electure-prev').click(function() {
          hidePopup();
          runSlide('99-2');
          pushState('99-2');
        });
      
 

        // temporary quick fix for Google Chrome Aug 2016 issue..., put at last part so that everything else has been loaded
        // setTimeout(function(){ document.body.style.zoom = "100.1%"; }, 500);
        // setTimeout(function(){ document.body.style.zoom = "100%"; }, 600);
        // I turn it off on 14 June 2018, seems 'ok'?
      });

      function doButtonAction39() {
        CUSTOM_ACTION('dfs');
      }
      function doButtonAction40() {
        CUSTOM_ACTION('bfs');
      }
      function doButtonAction41() {
        $("#dfsrecap").html("We start from source vertex <b>s = 0</b> and DFS will explore vertices: 0 &rarr; 1 (cannot go back to 0) &rarr; 2 (cannot go back to 1) &rarr; 3 (cannot go back to 1 or to 2) &rarr; 4 (cannot go back to 3, backtrack to 3 &rarr; 2 &rarr; 1, cannot go to 3, backtrack to 0, done).");
      }
      function doButtonAction42() {
        $("#bfsrecap").html("We start from source vertex <b>s = 5</b> and BFS will explore vertices: {5} (the source vertex), {1, 6, 10} (one edge away from the source vertex), {0, 2, 11, 9} (two edges away), {4, 3, 12, 8} (three edges away), and finally {7} (four edges away).");
      }
      function doButtonAction43() {
        $("#printexample").html(" When we call <samp>backtrack(4)</samp> after executing <samp>DFS(0)</samp> on the sample graph, we go back from 4 &rarr; p[4] = 3 &rarr; p[3] = 2 &rarr; p[2] = 1 &rarr; p[1] = 0 &rarr; p[0] = -1 (so 0 is the source) and print the path in reversed order (due to recursion) i.e.: 0 &rarr; 1 &rarr; 2 &rarr; 3 &rarr; 4.");
      }
      function doButtonAction44() {
        CUSTOM_ACTION('toposort_dfs');
      }
      function doButtonAction45() {
        CUSTOM_ACTION('toposort_bfs');
      }
      function doButtonAction46() {
        CUSTOM_ACTION('bipartite_dfs');
      }
      function doButtonAction47() {
        CUSTOM_ACTION('bipartite_bfs');
      }
      function doButtonAction48() {
        CUSTOM_ACTION('bridge');
      }
      function doButtonAction49() {
        CUSTOM_ACTION('kosaraju');
      }
      function doButtonAction50() {
        CUSTOM_ACTION('tarjan');
      }

      function adjustPopupToImageSize() {
        var width = $('#popup-image').prop('width');
        var height = $('#popup-image').prop('height');
        $('#popup').width(width + 20);
        $('#popup').height(height + 20);
        if (width == 0 && height == 0) {
          setTimeout(adjustPopupToImageSize, 200);
        } else {
          showPopup();  
        }
      }

      function POPUP_IMAGE(url) {
        $('#popup-content').html('<img id="popup-image" src="' + url + '">');
        adjustPopupToImageSize();
      }

      function URL(url.html) {
        window.open(url, '_blank');
      }

      // Implement these functions in each visualisation
      // This function will be called before entering e-Lecture Mode
      function ENTER_LECTURE_MODE() {}

      // This function will be called before returning to Explore Mode
      function ENTER_EXPLORE_MODE() {}

      // Lecture action functions
      function CUSTOM_ACTION(action, data, mode) {}
    </script>
<script type="text/javascript">
// Graph Traversal Widget
// original author: Koh Zi Chun, improved by Nguyen Viet Dung, then maintained by Steven Halim

var GraphTraversal = function() {
  var self = this;
  var gw = new GraphWidget();

  var iVL = {};
  var iEL = {};
  var amountVertex = 0;
  var amountEdge = 0;

  this.getGraphWidget = function() { return gw; }

  fixJSON = function() {
    amountVertex = 0;
    amountEdge = 0;
    for (var key in iVL) amountVertex++;
    for (var key in iEL) amountEdge++;

    // for (var key in iEL) {
    //   delete iEL[key]["type"];
    //   delete iEL[key]["displayWeight"];
    // }
    // for (var key in iVL) {
    //   iVL[key]["x"] = iVL[key]["cx"];
    //   delete iVL[key]["cx"];
    //   iVL[key]["y"] = iVL[key]["cy"];
    //   delete iVL[key]["cy"];
    //   delete iVL[key]["text"];
    //   delete iVL[key]["state"];
    // }
    // for (var key in iEL) {
    //   iEL[key]["u"] = +iEL[key]["vertexA"];
    //   delete iEL[key]["vertexA"];
    //   iEL[key]["v"] = +iEL[key]["vertexB"];
    //   delete iEL[key]["vertexB"];
    //   iEL[key]["w"] = +iEL[key]["weight"];
    //   delete iEL[key]["weight"];
    // }
  }

  takeJSON = function(graph) {
    if (graph == null) return;
    graph = JSON.parse(graph);
    iVL = graph["vl"];
    iEL = graph["el"];
    fixJSON();
  }

  statusChecking = function() {
    $("#draw-status p").html('Draw graph with varying properties then try to run various graph traversal algorithms on it.<br>The default drawing mode is directed graph (each edge has one or at most two arrows).');
  }

  warnChecking = function() {
    var warn = "";
    if (amountVertex >= 10) warn += 'Too much vertex on screen, consider drawing smaller graph. ';
    if (warn == "") $("#draw-warn p").html('No Warning.');
    else            $("#draw-warn p").html(warn);
  }

  errorChecking = function() {
    var error = "";
    if (amountVertex == 0) {
      $("#draw-err p").html('Graph cannot be empty. ');
      return;
    }

    if (error == "") $("#draw-err p").html('No Error');
    else             $("#draw-err p").html(error);
  }

  var intervalID;

  this.startLoop = function() {
    intervalID = setInterval(function() {
      takeJSON(JSONresult);
      warnChecking();
      errorChecking();
      statusChecking();
    }, 100);
  }

  this.stopLoop = function() {
    clearInterval(intervalID);
  }

  this.draw = function() {
    if ($("#draw-err p").html() != 'No Error')
      return false;
    if ($("#submit").is(':checked'))
      this.submit(JSONresult);
    if ($("#copy").is(':checked'))
      window.prompt('Copy to clipboard:', JSONresult);

    DIRECTED_GR = true;
    OLD_POSITION = amountEdge;

    graph = createState(iVL, iEL);
    gw.updateGraph(graph, 500);
    return true;
  }

  // this.submit = function(graph) {
  //   $.ajax({
  //     url: PHP_DOMAIN + "php/Graph.php?mode=" + MODE_SUBMIT_GRAPH,
  //     type: "POST",
  //     data: {canvasWidth: 1000, canvasHeight: 500, graphTopics: 'Graph Traversal', graphState: graph, fbAccessToken: fbAccessToken},
  //     error: function(xhr, errorType, exception) { //Triggered if an error communicating with server
  //         var errorMessage = exception || xhr.statusText; //If exception null, then default to xhr.statusText
  //         alert("There was an error submitting your graph " + errorMessage);
  //     }
  //   }).done(function(data) {
  //     console.log(data);
  //   });
  // }

  this.importjson = function(text) {
    takeJSON(text);
    statusChecking();

    DIRECTED_GR = true;
    OLD_POSITION = amountEdge;

    graph = createState(iVL, iEL);
    gw.updateGraph(graph, 500);
  }

  // this.initRandom = function(graph) {
  //   iVL = graph.iVL;
  //   iEL = graph.iEL;
  //   amountVertex = iVL.length;
  //   amountEdge = iEL.length;
  //   fixJSON();
  //   statusChecking();

  //   DIRECTED_GR = true;
  //   OLD_POSITION = amountEdge;

  //   var newState = createState(iVL, iEL);
  //   gw.updateGraph(newState, 500);
  // }

  var DIRECTED_GR;
  var OLD_POSITION;

  this.directedChange = function() {
    for (var key in iVL) iVL[key]["extratext"] = "";
    if (DIRECTED_GR == true) {
      DIRECTED_GR = false;
      for (var i = 0; i < OLD_POSITION; i++) {
        var ok = false;
        for (var j = 0; j < amountEdge; j ++)
          if (iEL[i]["u"] == iEL[j]["v"] && iEL[i]["v"] == iEL[j]["u"]) {
            ok = true;
            break;
          }
        if (ok == false)
          iEL[amountEdge++] = {
            "u": iEL[i]["v"],
            "v": iEL[i]["u"]
          }
      }
    }
    else {
      DIRECTED_GR = true;
      for (var i = OLD_POSITION; i < amountEdge; i ++)
        delete iEL[i];
      amountEdge = OLD_POSITION;
    }

    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
    // $('#directedChange-err').html("Successful")
    //   .delay(1000)
    //   .queue(function(n) {
    //     $(this).html("");
    //   });
    return true;
  }

  this.getGraph = function() {
    return {
      'vl': iVL,
      'el': iEL
    };
  }

  this.getV = function() {
    return amountVertex;
  }

  this.dfs = function(sourceVertex, callback) {
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {}, treeEdge = {}, backEdge = {}, forwardEdge = {}, crossEdge = {};
    var stateList = [];
    var cs;

    // error checks   
    if (amountVertex == 0) { // no graph
      $('#dfs-err').html('Không có đồ thị để chạy. Hãy chọn một đồ thị ví dụ trước.');
      return false;
    }

    if (sourceVertex >= amountVertex || sourceVertex < 0) { // source vertex not in range
      $('#dfs-err').html('Đỉnh này không có trong đồ thị. Hãy chọn một đỉnh xuất phát khác');
      return false;
    }

    var UNVISITED = 0, EXPLORED = 1, VISITED = 2;
    var p = {}, num = {}, Count = 0; // low = {}, 
    for (var i = 0; i < amountVertex; i++) {
      p[i] = -1;
      num[i] = UNVISITED;
    }
    p[sourceVertex] = -2;
    for (var key in iVL) iVL[key]["extratext"] = "";
    iVL[sourceVertex]["extratext"] = "source";

    function dfsRecur(u) {
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
      cs["status"] = "DFS(" + u + ")";
      cs["lineNo"] = 1;
      stateList.push(cs);

      delete vertexHighlighted[u];
      vertexTraversing[u] = true;
      num[u] = EXPLORED; // low[u] = ++Count;

      var neighbors = [];
      for (var j = 0; j < amountEdge; j++) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var u = iEL[j]["u"], v = iEL[j]["v"];
        edgeHighlighted[j] = true;
        for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) edgeHighlighted[key] = true;
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
        cs["status"] = 'Try edge {u} → {v}'.replace("{u}", u).replace("{v}", v);
        cs["lineNo"] = 2;
        cs["el"][j]["animateHighlighted"] = true;
        stateList.push(cs);

        for (var key in iVL) delete vertexHighlighted[key];
        for (var key in iEL) delete edgeHighlighted[key];

        if (num[v] == UNVISITED) {
          vertexTraversing[v] = true;
          treeEdge[j] = true;
          for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) treeEdge[key] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
          cs["lineNo"] = [3];
          cs["status"] = 'Try edge {u} → {v}<br>Vertex {v} is unvisited, we have a <font color="red">tree edge</font>.'.replace("{u}", u).replace("{v}", v).replace("{v}", v);
          stateList.push(cs);

          p[v] = u;
          dfsRecur(v);

          vertexHighlighted[u] = true;
          delete vertexHighlighted[v];
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
          cs["status"] = 'Finish DFS({v}), backtrack to DFS({u}).'.replace("{u}", u).replace("{v}", v);
          cs["lineNo"] = 1;
          stateList.push(cs);
        }
        else if (num[v] == EXPLORED) {
          if (p[u] != v) {
            backEdge[j] = true;
            for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) backEdge[key] = true;
          }
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
          var thisStatus = 'Try edge {u} → {v}<br>Vertex {v} is explored, we have a '.replace("{u}", u).replace("{v}", v).replace("{v}", v);
          if (p[u] == v)
            thisStatus = thisStatus + '<font color="blue">bidirectional edge</font> (a trivial cycle).';
          else
            thisStatus = thisStatus + '<font color="blue">back edge</font> (a true cycle).';
          cs["status"] = thisStatus;
          cs["lineNo"] = 4;
          stateList.push(cs);
        }
        else if (num[v] == VISITED) {
          forwardEdge[j] = true;
          for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) forwardEdge[key] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
          cs["status"] = 'Try edge {u} → {v}<br>Vertex {v} is visited, we have a <font color="grey">forward/cross edge</font>.'.replace("{u}", u).replace("{v}", v).replace("{v}", v);
          cs["lineNo"] = 5;
          stateList.push(cs);
        }
      }
      num[u] = VISITED;
      vertexTraversed[u] = true;
      delete vertexTraversing[u];
    }
    dfsRecur(sourceVertex);

    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
    cs["status"] = 'DFS({sourceVertex}) is completed. <font color="red">Red</font>/<font color="grey">grey</font>/<font color="blue">blue</font> edge is <font color="red">tree</font>/<font color="grey">cross/forward</font>/<font color="blue">back</font> edge of the DFS spanning tree, respectively.'.replace("{sourceVertex}", sourceVertex);
    cs["lineNo"] = 0;
    stateList.push(cs);

    populatePseudocode(0);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.bfs = function(sourceVertex, callback) {
    var notVisited = {}, vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {}, treeEdge = {}, backEdge = {}, forwardEdge = {}, crossEdge = {};
    var stateList = [];
    var key, i, cs;

    // error checks
    if (amountVertex == 0) { // no graph
      $('#bfs-err').html('Không có đồ thị để chạy. Hãy chọn một đồ thị ví dụ trước.');
      return false;
    }

    if (sourceVertex >= amountVertex || sourceVertex < 0) { // source vertex not in range
      $('#bfs-err').html('Đỉnh này không có trong đồ thị. Hãy chọn một đỉnh xuất phát khác');
      return false;
    }

    var p = {}, d = {};
    for (var i = 0; i < amountVertex; i++) {
      p[i] = -1;
      d[i] = 999;
    }
    d[sourceVertex] = 0;
    for (var key in iVL) iVL[key]["extratext"] = "";
    iVL[sourceVertex]["extratext"] = "source";

    var q = []; //, EdgeProcessed = 0;
    q.push(sourceVertex);
    p[sourceVertex] = -2;
    vertexHighlighted[sourceVertex] = true;
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
    cs["status"] = 'Start from source s = {sourceVertex}.<br>Set Q = {{sourceVertex}}.'.replace("{sourceVertex}", sourceVertex).replace("{sourceVertex}", sourceVertex); // d[" + sourceVertex + "] = 0, 
    cs["lineNo"] = 1;
    stateList.push(cs);
    delete vertexHighlighted[sourceVertex];

    while (q.length > 0) {
      delete vertexTraversing[q[0]];
      vertexHighlighted[q[0]] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
      cs["status"] = 'The queue is now {{queue}}.<br>Exploring neighbors of vertex u = {Lis}.'.replace("{queue}", q).replace("{Lis}", q[0]);
      cs["lineNo"] = [2, 3];
      stateList.push(cs);

      var f = q.shift();
      vertexTraversed[f] = true;

      var neighbors = [];
      for (var j = 0; j < amountEdge; j++) if (iEL[j]["u"] == f) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var u = iEL[j]["u"], v = iEL[j]["v"];
        for (var key in iVL) delete vertexHighlighted[key];
        for (var key in iEL) delete edgeHighlighted[key];
        if (u == f) { // outgoing edge from vertex u
          //EdgeProcessed++;
          //var thisStatus = 'relax(' + u + ', ' + v + ', 1), #edge_processed = ' + EdgeProcessed + '.';
          edgeHighlighted[j] = true;
          for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) edgeHighlighted[key] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
          cs["status"] = 'Try edge {u} → {v}'.replace("{u}", u).replace("{v}", v).replace("{v}", v);
          cs["lineNo"] = 3;
          cs["el"][j]["animateHighlighted"] = true;
          stateList.push(cs);

          if (d[v] == 999) {
            d[v] = d[u]+1;
            p[v] = u;
            treeEdge[j] = true;
            for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) treeEdge[key] = true;
            q.push(v);
            vertexTraversing[v] = true;
            iVL[v]["extratext"] = d[v];
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
            cs["status"] = 'Try edge {u} → {v}<br>Vertex {v} is unvisited, we have a <font color="red">tree edge</font>.'.replace("{u}", u).replace("{v}", v).replace("{v}", v);
            cs["lineNo"] = 4;
          }
          else {
            var grey_it = true;
            for (var key in iEL) if ((iEL[key]["u"] == v && iEL[key]["v"] == u) && treeEdge[key]) grey_it = false;
            if (grey_it) {
              forwardEdge[j] = true; // use grey to signify non-tree edge
              for (var key in iEL) if (iEL[key]["u"] == v && iEL[key]["v"] == u) forwardEdge[key] = true;
            }
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
            cs["status"] = 'Try edge {u} → {v}<br>Vertex {v} is explored, we ignore this <font color="grey">non-tree edge</font>.'.replace("{u}", u).replace("{v}", v).replace("{v}", v);
            cs["lineNo"] = 5;
          }
          stateList.push(cs);
        }
      }
      delete vertexHighlighted[u];
    }

    for (var key in iVL) delete vertexHighlighted[key];
    for (var key in iEL) delete edgeHighlighted[key];
    vertexHighlighted[sourceVertex] = true;
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
    cs["status"] = 'BFS({sourceVertex}) is completed. <font color="red">Red</font>/<font color="grey">grey</font> edge is <font color="red">tree</font>/<font color="grey">non-tree</font> edge of the BFS & SSSP spanning tree (for unweighted graph).'.replace("{sourceVertex}", sourceVertex);
    stateList.push(cs);

    populatePseudocode(1);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.toposortDfs = function(callback) {
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {}, treeEdge = {}, backEdge = {}, forwardEdge = {}, crossEdge = {}, hiddenEdge = {};
    var stateList = [];
    var cs, flag = true;

    // check error
    if (!DIRECTED_GR) {
      // cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      // cs["status"] = "The input graph is not set as 'directed' graph yet.<br>This algorithm only works with directed graphs.";
      // cs["lineNo"] = 0;
      // stateList.push(cs);

      this.directedChange(); // force change

      // cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      // cs["status"] = "We turn on the directed graph mode.<br>This action is irreversible.";
      // cs["lineNo"] = 0;
      // stateList.push(cs);

      // $('#topo-err').html("Undirected graph clearly has no topological sort. Give a directed input graph.");
      // return false;
    }

    if (amountVertex == 0) { // no graph
      $('#topo-err').html('Không có đồ thị để chạy. Hãy chọn một đồ thị ví dụ trước.');
      return false;
    }

    // main code
    var p = {}, stack = [], stackNum = -1;
    for (var i = 0; i < amountVertex; i ++) p[i] = -1
    for (var key in iVL) iVL[key]["extratext"] = "";

    for (var i = 0; i < amountVertex; i ++)
    if (p[i] == -1) {
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
      cs["status"] = 'Vertex {i} has not been visited.'.replace("{i}", i);
      cs["lineNo"] = 1;
      stateList.push(cs);
      p[i]--;
      Tdfs(i);
    }

    function Tdfs(u) {
      if (flag == false) return;
      vertexTraversing[u] = true;
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
      cs["status"] = "DFS(" + u + ").";
      cs["lineNo"] = 2;
      stateList.push(cs);
      delete vertexHighlighted[u];

      var neighbors = [];
      for (var j = 0; j < amountEdge; j++) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
        if (u == vertexA) {
          edgeHighlighted[j] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
          cs["status"] = 'Try edge {vertexA} → {vertexB}.<br>List = [{stack}].'.replace("{vertexA}", vertexA).replace("{vertexB}", vertexB).replace("{stack}", stack);
          cs["lineNo"] = 3;
          cs["el"][j]["animateHighlighted"] = true;
          stateList.push(cs);

          if (p[vertexB] == -1) {
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
            cs["status"] = 'Vertex {vertexB} has not been visited, continue.<br>List = [{stack}].'.replace("{vertexB}", vertexB).replace("{stack}", stack);
            cs["lineNo"] = 4;
            stateList.push(cs);

            p[vertexB] = u;
            Tdfs(vertexB);
          }
          else {
            var k = u;
            while (k != -2) {
              k = p[k];
              if (k == vertexB) flag = false;
            }
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
            cs["status"] = 'Vertex {vertexB} has been visited, ignore this edge.<br>List = [{stack}].'.replace("{vertexB}", vertexB).replace("{stack}", stack);
            cs["lineNo"] = 5;
            stateList.push(cs);
          }
        }
      }
      stack.push(u);
      delete vertexTraversing[u];
      vertexTraversed[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
      cs["status"] = 'DFS({u}) is completed, add {u} to the back of the list.<br>List = [{stack}].'.replace("{u}", u).replace("{stack}", stack);
      cs["lineNo"] = 7;
      stateList.push(cs);
    }
    if (flag == false) { // not DAG
      $('#topo-err').html('This graph is not a DAG, unable to perform Topological Sort.');
      return false;
    }
    vertexHighlighted = {}, edgeHighlighted = {};
    vertexTraversed = {}, vertexTraversing = {}, treeEdge = {}, backEdge = {}, forwardEdge = {}, crossEdge = {}, hiddenEdge = {};
    stack.reverse();
    for (var key in stack) iVL[stack[key]]["extratext"] = key;
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
    cs["status"] = 'Topological Sort is completed after reversing the list.<br>List = [{stack}], also see the <font color="red">red</font> indices above.'.replace("{stack}", stack);
    cs["lineNo"] = 0;
    stateList.push(cs);

    populatePseudocode(2);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.toposortBfs = function(callback) {
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {}, treeEdge = {}, backEdge = {}, forwardEdge = {}, crossEdge = {}, hiddenEdge = {};
    var stateList = [];
    var cs, key;

    // error checks
    if (amountVertex == 0) { // no graph
      $('#topo-err').html('Không có đồ thị để chạy. Hãy chọn một đồ thị ví dụ trước.');
      return false;
    }

    if (!DIRECTED_GR) {
      this.directedChange(); // force change
      // $('#topo-err').html("Undirected graph clearly has no topological sort. Give a directed input graph.");
      // return false;
    }

    var fr = {}, cc = {};
    for (var i = 0; i < amountVertex; i++)
      fr[i] = true, cc[i] = 0;
    for (var j = 0; j < amountEdge; j ++)
      cc[iEL[j]["v"]]++;

    for (key in iVL)
      iVL[key]["state"] = VERTEX_DEFAULT, iVL[key]["extratext"] = "";

    var q = [], EdgeProcessed = 0, Lis = [];
    for (var i = 0; i < amountVertex; i ++)
      if (cc[i] == 0)
        q.push(i), vertexHighlighted[i] = vertexTraversing[i] = true;
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge);
    cs["status"] = 'Queue = [{queue}].'.replace("{queue}", q);
    cs["lineNo"] = 1;
    stateList.push(cs);
    for (var i = 0; i < amountVertex; i ++)
      if (cc[i] == 0)
        delete vertexHighlighted[i];

    while (q.length > 0) {
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
      cs["status"] = 'Queue = [{queue}].'.replace("{queue}", q);
      cs["lineNo"] = 2;
      stateList.push(cs);

      var u = q.shift(); // front most item
      Lis.push(u);
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
      cs["status"] = '<font face="arial">Lấy đỉnh {u} từ hàng đợi và thêm vào cuối danh sách.</font><div><font face="arial">List = [{Lis}].</font></div>'.replace("{u}", u).replace("{Lis}", Lis);
      cs["lineNo"] = 3;
      stateList.push(cs);

      var neighbors = [];
      for (var j = 0; j < amountEdge; j++) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
        cc[vertexB]--;

        hiddenEdge[j] = true;
        var thisStatus = 'Queue = [{queue}].<div>Xóa đỉnh {vertexA} -&gt; {vertexB}.</div>'.replace("{queue}", q).replace("{vertexA}", vertexA).replace("{vertexB}", vertexB);
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
        cs["status"] = thisStatus;
        cs["lineNo"] = [4, 5];
        cs["el"][j]["animateHighlighted"] = true;
        stateList.push(cs);

        if (cc[vertexB] == 0) {
          q.push(vertexB);
          vertexTraversing[vertexB] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
          cs["status"] = 'Queue = [{queue}].<div>Đỉnh {vertexB} không có cạnh kề, thêm vào hàng đợi.</div>'.replace("{queue}", q).replace("vertexB", vertexB);
          cs["lineNo"] = 6;
          stateList.push(cs);
        }
        else {
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
          cs["status"] ='Queue = [{queue}]<div>Đỉnh {vertexB} vẫn còn cạnh nối, bỏ qua nó.</div>'.replace("{queue}", q).replace("vertexB", vertexB);
          cs["lineNo"] = 6;
          stateList.push(cs);
        }
      }
      delete vertexHighlighted[u];
      delete vertexTraversing[u];
      vertexTraversed[u] = true;
    }

    var thisStatus = '<font face="arial">Thuật toán Kahn đã hoàn tất.</font>';
    var flag = true;
    for (var j = 0; j < amountEdge; j ++)
      if (hiddenEdge[j] == null) {
        flag = false;
        $('#topo-err').html('This graph is not a DAG, unable to perform Topological Sort.');
        return false;
        // thisStatus += "Edge " + iEL[j]["u"] + "->" + iEL[j]["v"] + " has not been visited, the graph has cycle."
        // break;
      }
    if (flag)
      thisStatus += 'Thứ tự Tô-pô = [{lis}]'.replace("{Lis}", Lis);
    for (var key in Lis) iVL[Lis[key]]["extratext"] = key;
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge);
    cs["lineNo"] = 7;
    cs["status"] = thisStatus;
    stateList.push(cs);

    populatePseudocode(3);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.bipartiteDfs = function(callback) {
    var p = {}, vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {};
    var stateList = [];
    var key, cs, flag = false;

    // error checks   
    if (amountVertex == 0) { // no graph
      $('#bipartite-err').html('Không có đồ thị để chạy. Hãy chọn một đồ thị ví dụ trước.');
      return false;
    }

    if (DIRECTED_GR) {
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
      cs["status"] = "The input graph is not set as 'undirected' graph yet.<br>Bipartite Graph is usually only defined for undirected graphs.";
      cs["lineNo"] = 0;
      stateList.push(cs);

      this.directedChange(); // force change

      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
      cs["status"] = "We add bidirectional edges as necessary and hide the arrows.<br>This action is irreversible (you may have to redraw your graph again).";
      cs["lineNo"] = 0;
      stateList.push(cs);

      // $('#bipartite-err').html("Bipartite graph is only defined for undirected graph. Please make the graph undirected.");
      // return false;
    }

    for (var key in iVL) {
      p[key] = -1;
      iVL[key]["extratext"] = "";
    }
    for (var i = 0; i < amountVertex; i++)
      if (p[i] == -1) {
        vertexTraversed[i] = true;
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
        cs["status"] = "Vertex " + i + " is unvisited.";
        cs["lineNo"] = 1;
        if (vertexTraversed[i] != null) cs["vl"][i]["state"] = VERTEX_HIGHLIGHTED;
        else                            cs["vl"][i]["state"] = VERTEX_BLUE_FILL;
        stateList.push(cs);
        p[i] = -2;
        dfsRecur(i);
        if (flag) break;
      }

    function dfsRecur(u) {
      if (flag) return;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
      cs["status"] = "DFS(" + u + ").";
      cs["lineNo"] = 2;
      if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
      else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
      stateList.push(cs);

      var neighbors = [];
      for (var j = 0; j < amountEdge; j++) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
        if (edgeHighlighted[j] == null) {
          if (u == vertexA) {
            edgeHighlighted[j] = true;
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
            cs["status"] = "Try edge " + u + " &rarr; " + vertexB + ".";
            cs["lineNo"] = 3;
            if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
            else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
            cs["el"][j]["animateHighlighted"] = true;
            stateList.push(cs);

            if (p[vertexB] == -1) {
              if (vertexTraversed[u] == null) vertexTraversed[vertexB] = true;
              else                            vertexTraversing[vertexB] = true;
              p[vertexB] = u;
              cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
              cs["status"] = "Try edge " + u + " &rarr; " + vertexB + ".<br>Give vertex " + vertexB + " different color from vertex " + u + ".";
              cs["lineNo"] = 4;
              if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
              else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
              stateList.push(cs);
              dfsRecur(vertexB);
            }
            else {
              var cu = 0, cv = 0;
              if (vertexTraversing[u] != null) cu = 1;
              if (vertexTraversing[vertexB] != null) cv = 1;
              if (cu == cv) {
                flag = true;
                cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
                cs["status"] = "Vertex " + u + " and vertex " + vertexB + " have the same color.";
                cs["lineNo"] = 5;
                if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
                else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
                if (vertexTraversed[vertexB] != null) cs["vl"][vertexB]["state"] = VERTEX_HIGHLIGHTED;
                else                                  cs["vl"][vertexB]["state"] = VERTEX_BLUE_FILL;
                stateList.push(cs);
                break;
              }
            }
            if (flag) break;
          }
          if (flag) break;
        }
        else {
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
          cs["status"] = "Try edge " + vertexA + " &rarr; " + vertexB + ".<br>Vertex " + vertexA + " and vertex " + vertexB + " (already visited) have different color, continue.";
          cs["lineNo"] = 5;
          stateList.push(cs);
        }
      }
      if (flag) return;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
      cs["status"] = "Finish DFS(" + u + ")<br>Back to the parent.";
      cs["lineNo"] = 2;
      if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
      else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
      stateList.push(cs);
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
    if (flag == false) cs["status"] = "This is a bipartite graph!";
    else               cs["status"] = "This is NOT a bipartite graph!";
    cs["lineNo"] = 0;
    if (flag == true) cs["lineNo"] = 6;
    stateList.push(cs);

    populatePseudocode(4);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.bipartiteBfs = function(callback) {
    var p = {}, vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {};
    var stateList = [];
    var key, cs, flag = true;

    // error checks
    if (amountVertex == 0) { // no graph
      $('#bipartite-err').html('Không có đồ thị để chạy. Hãy chọn một đồ thị ví dụ trước.');
      return false;
    }

    if (DIRECTED_GR) {
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
      cs["status"] = "The input graph is not set as 'undirected' graph yet.<br>Bipartite Graph is usually only defined for undirected graphs.";
      cs["lineNo"] = 0;
      stateList.push(cs);

      this.directedChange(); // force change

      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
      cs["status"] = "We add bidirectional edges as necessary and hide the arrows.<br>This action is irreversible (you may have to redraw your graph again).";
      cs["lineNo"] = 0;
      stateList.push(cs);

      // $('#bipartite-err').html("Bipartite graph is only defined for undirected graph. Please make the graph undirected.");
      // return false;
    }

    for (key in iVL) {
      p[key] = -1;
      iVL[key]["state"] = VERTEX_DEFAULT;
      iVL[key]["extratext"] = "";
    }

    for (var s = 0; s < amountVertex; s++)
      if (p[s] == -1) {
        p[s] = -2;
        vertexTraversed[s] = true;
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
        cs["status"] = 'Vertex ' + s + ' is unvisited.';
        cs["lineNo"] = 1;
        if (vertexTraversed[s] != null) cs["vl"][s]["state"] = VERTEX_HIGHLIGHTED;
        else                            cs["vl"][s]["state"] = VERTEX_BLUE_FILL;
        stateList.push(cs);

        var q = [];
        q.push(s);
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
        cs["status"] = "Queue = [" + q + "].";
        cs["lineNo"] = 2;
        stateList.push(cs);

        while (q.length > 0) {
          var u = q.shift();

          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
          cs["status"] = "Extract " + u + " from queue.";
          cs["lineNo"] = 3;
          if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
          else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
          stateList.push(cs);

          var neighbors = [];
          for (var j = 0; j < amountEdge; j++) if (iEL[j]["u"] == u) neighbors.push(j);
          neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

          while (neighbors.length > 0) {
            var j = neighbors.shift();
            var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
            if (edgeHighlighted[j] == null) {
              if (u == vertexA) {
                edgeHighlighted[j] = true;
                cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
                cs["status"] = "Queue = [" + q + "].<br>Try edge " + vertexA + " &rarr; " + vertexB + ".";
                cs["lineNo"] = 4;
                if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
                else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
                cs["el"][j]["animateHighlighted"] = true;
                stateList.push(cs);

                if (p[vertexB] == -1) {
                  p[vertexB] = vertexA;
                  q.push(vertexB);
                  if (vertexTraversed[u] != null) vertexTraversing[vertexB] = true;
                  else                            vertexTraversed[vertexB] = true;

                  cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
                  cs["status"] = "Queue = [" + q + "].<br>Vertex " + vertexB + " is free, assign another color and push it to queue.";
                  cs["lineNo"] = 6;
                  if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
                  else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
                  stateList.push(cs);
                }
                else {
                  var cu = 0, cv = 0;
                  if (vertexTraversing[u] != null) cu = 1;
                  if (vertexTraversing[vertexB] != null) cv = 1;
                  if (cu == cv) {
                    flag = false;
                    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
                    cs["status"] = "Vertex " + u + " and vertex " + vertexB + " have the same color.<br>This is NOT a bipartite graph!";
                    cs["lineNo"] = 5;
                    if (vertexTraversed[u] != null) cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
                    else                            cs["vl"][u]["state"] = VERTEX_BLUE_FILL;
                    if (vertexTraversed[vertexB] != null) cs["vl"][vertexB]["state"] = VERTEX_HIGHLIGHTED;
                    else                                  cs["vl"][vertexB]["state"] = VERTEX_BLUE_FILL;
                    stateList.push(cs);
                    break;
                  }
                }
                if (flag == false) break;
              }
              if (flag == false) break;
            }
            else {
              cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
              cs["status"] = "Try edge " + vertexA + " &rarr; " + vertexB + ".<br>Vertex " + vertexA + " and vertex " + vertexB + " (already visited) have different color, continue.";
              cs["lineNo"] = 5;
              stateList.push(cs);
            }
            if (flag == false) break;
          }
          if (flag == false) break;
        }
        if (flag == false) break;
      }

    if (flag) {
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing);
      cs["status"] = "This is a bipartite graph!";
      cs["lineNo"] = 0;
      stateList.push(cs);
    }

    populatePseudocode(5);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.bridge = function(callback) {
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {}, bridge = {}, articulationPoint = {};
    var stateList = [];
    var cs;

    // check error
    if (amountVertex == 0) { // no graph
      $('#bridge-err').html('Không có đồ thị để chạy. Hãy chọn một đồ thị ví dụ trước.');
      return false;
    }

    if (DIRECTED_GR) {
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
      cs["status"] = "The input graph is not set as 'undirected' graph yet.<br>This algorithm only works with undirected graphs.";
      cs["lineNo"] = 0;
      stateList.push(cs);

      this.directedChange(); // force change

      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
      cs["status"] = "We add bidirectional edges as necessary and hide the arrows.<br>This action is irreversible (you may have to redraw your graph again).";
      cs["lineNo"] = 0;
      stateList.push(cs);
      //$('#bridge-err').html("This algorithm can only work for undirected graph.");
      //return false;
    }

    // main code
    var p = {}, stack = {}, stackNum = -1, Count = -1, low = {}, num = {}, lab = {}, labNum = 0;
    var ROOT, chilNum = {};
    for (var i = 0; i < amountVertex; i++) {
      p[i] = lab[i] = -1, chilNum[i] = 0;
      iVL[i]["extratext"] = "N/A";
    }

    function highlightArticulationPointsAndBridges() {
      for (var key in bridge) {
        cs["el"][key]["state"] = EDGE_GREEN;
        for (var z = 0; z < amountEdge; z ++)
          if (iEL[z]["u"] == iEL[key]["v"] && iEL[z]["v"] == iEL[key]["u"])
            cs["el"][z]["state"] = EDGE_GREEN;
      }
      for (var key in articulationPoint) cs["vl"][key]["state"] = VERTEX_GREEN_OUTLINE;
    }

    for (var i = 0; i < amountVertex; i++)
      if (p[i] == -1) {
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
        cs["status"] = "Vertex " + i + " has not been visited.<br>DFSCount = " + Count + ".";
        cs["lineNo"] = 1;
        highlightArticulationPointsAndBridges();
        stateList.push(cs);
        p[i]--;
        ROOT = i;
        Tdfs(i);
      }

    function Tdfs(u) {
      stack[++stackNum] = u;
      num[u] = low[u] = ++Count;
      iVL[u]["extratext"] = "" + num[u] + "," + low[u];
      vertexTraversing[u] = true;
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
      cs["status"] = "DFS(" + u + ").<br>DFSCount = " + Count + ".";
      cs["lineNo"] = 2;
      highlightArticulationPointsAndBridges();
      stateList.push(cs);
      delete vertexHighlighted[u];

      var neighbors = [];
      for (var j = 0; j < amountEdge; j++) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
        if (lab[vertexB] == -1 && u == vertexA) {
          edgeHighlighted[j] = true;
          for (var z = 0; z < amountEdge; z ++)
            if (iEL[z]["u"] == vertexB && iEL[z]["v"] == vertexA)
              edgeHighlighted[z] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
          cs["status"] = "Try edge " + vertexA + " -> " + vertexB + "<br>DFSCount = " + Count + ".";
          cs["lineNo"] = 3;
          cs["el"][j]["animateHighlighted"] = true;
          highlightArticulationPointsAndBridges();
          stateList.push(cs);

          if (p[vertexB] == -1) {
            vertexTraversing[vertexB] = true;
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
            cs["status"] = "" + vertexB + " has not been visited<br>DFSCount = " + Count + ".";
            cs["lineNo"] = 4;
            highlightArticulationPointsAndBridges();
            stateList.push(cs);

            p[vertexB] = u;
            Tdfs(vertexB);
            chilNum[u]++;
            var thisStatus = "low[" + u + "] is unchanged.";
            if (low[u] > low[vertexB]) {
              low[u] = low[vertexB];
              thisStatus = "update low[" + u + "] from low[" + vertexB + "].<br>There is <b>another</b> path to go from vertex " + u + " to vertex with num " + low[u] + ".";
            }
            iVL[u]["extratext"] = "" + num[u] + "," + low[u];

            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
            cs["status"] = thisStatus;
            cs["lineNo"] = 5;
            highlightArticulationPointsAndBridges();
            stateList.push(cs);

            var thisStatus = "";
            if (low[vertexB] >= num[u] && u != ROOT) {
              thisStatus = thisStatus + "low[" + vertexB + "] >= num[" + u + "] and " + u + " is not the root, vertex " + u + " is a cut vertex.<br>";
              articulationPoint[u] = true;
            }
            else if (low[vertexB] >= num[u] && u == ROOT)
              thisStatus = thisStatus + "low[" + vertexB + "] >= num[" + u + "] but " + u + " is the root, so it is not a cut vertex.<br>";
            else
              thisStatus = thisStatus + "low[" + vertexB + "] < num[" + u + "], so " + u + " is not a cut vertex.<br>";

            if (low[vertexB] > num[u]) {
              thisStatus = thisStatus + "low[" + vertexB + "] > num[" + u + "], so edge (" + u + ", " + vertexB + ") is a bridge.";
              bridge[j] = true;
            }
            else
              thisStatus = thisStatus + "low[" + vertexB + "] <= num[" + u + "], so edge (" + u + ", " + vertexB + ") is not a bridge.";

            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
            cs["status"] = thisStatus;
            cs["lineNo"] = 6;
            highlightArticulationPointsAndBridges();
            stateList.push(cs);
          }
          else if (vertexB != p[u]) {
            var thisStatus = "low[" + u + "] is unchanged.";
            if (low[u] > num[vertexB]) {
              low[u] = num[vertexB];
              thisStatus = "update low[" + u + "] from num[" + vertexB + "].<br>There is <b>another</b> path to go from vertex " + u + " to vertex with num " + low[u] + ".";
            }
            iVL[u]["extratext"] = "" + num[u] + "," + low[u];
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
            cs["status"] = "" + vertexB + " is visited, " + thisStatus; // update low[" + u + "] from num[" + vertexB + "]<br>DFSCount = " + Count + ".";
            cs["lineNo"] = 7;
            highlightArticulationPointsAndBridges();
            stateList.push(cs);
          }
          else {
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
            cs["status"] = "" + vertexB + " is the parent of " + u + ", ignore!<br>DFSCount = " + Count + ".";
            cs["lineNo"] = 7;
            highlightArticulationPointsAndBridges();
            stateList.push(cs);
          }
        }
      }

      delete vertexTraversing[u];
      vertexHighlighted[u] = true;
      vertexTraversed[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
      cs["status"] = "Finish DFS(" + u + "), backtrack.<br>DFSCount = " + Count + ".";
      if (u == ROOT && chilNum[u] >= 2) {
        cs["status"] = "Finish DFS(" + u + "), " + u + " is the root and u has more than 1 childs<br>Hence " + u + " is an articulation point.";
        articulationPoint[u] = true;
      }
      cs["lineNo"] = 0;
      highlightArticulationPointsAndBridges();
      cs["vl"][u]["state"] = VERTEX_HIGHLIGHTED;
      stateList.push(cs);
      delete vertexHighlighted[u];
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, {});
    cs["status"] = "Finished.<br>Green vertices/edges are articulation points/bridges, respectively.";
    cs["lineNo"] = 0;
    highlightArticulationPointsAndBridges();
    stateList.push(cs);

    populatePseudocode(6);
    gw.startAnimation(stateList, callback);
    for (var key in iVL) iVL[key]["extratext"] = "";
    return true;
  }

  this.kosaraju = function(callback) {
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {}, hiddenEdge = {};
    var stateList = [];
    var cs;

    // check error
    if (amountVertex == 0) { // no graph
      $('#scc-err').html('Không có đồ thị để chạy. Hãy chọn một đồ thị ví dụ trước.');
      return false;
    }

    if (!DIRECTED_GR) {
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = "The input graph is not set as 'directed' graph yet.<br>This algorithm only works with directed graphs.";
      cs["lineNo"] = 0;
      stateList.push(cs);

      this.directedChange(); // force change

      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = "We turn on the directed graph mode.<br>This action is irreversible.";
      cs["lineNo"] = 0;
      stateList.push(cs);

      // $('#scc-err').html("Please make the graph directed");
      // return false;
    }

    // main code
    var p = {}, stack = {}, stackNum = -1, Count = 0, low = {}, num = {}, lab = {}, labNum = 0;
    for (var i = 0; i < amountVertex; i++) {
      p[i] = lab[i] = -1;
      iVL[i]["extratext"] = "";
    }
    for (var i = 0; i < amountVertex; i++)
      if (p[i] == -1) {
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
        cs["status"] = "Vertex " + i + " has not been visited.";
        cs["lineNo"] = 1;
        stateList.push(cs);
        p[i]--;
        Tdfs(i);
      }

    vertexHighlighted = {}, edgeHighlighted = {};
    vertexTraversed = {}, vertexTraversing = {};
    for (var j = 0; j < amountEdge; j++) { // reverse edge directions
      var vertexA = iEL[j]["u"];
      var vertexB = iEL[j]["v"];
      iEL[j]["u"] = vertexB;
      iEL[j]["v"] = vertexA;
    }
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
    cs["status"] = "Then, we transpose the directed graph.";
    cs["lineNo"] = 4;
    stateList.push(cs);

    while (stackNum >= 0) {
      if (lab[stack[stackNum]] == -1) {
        labNum++;
        DFS2(stack[stackNum]);
        for (var j = 0; j < amountEdge; j++) {
          var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
          if (lab[vertexA] != lab[vertexB]) hiddenEdge[j] = true;
        }

        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
        cs["status"] = getStack() + ".<br>Finish DFS(" + stack[stackNum] + ") and we get 1 Strongly Connected Component.";
        cs["lineNo"] = 7;
        stateList.push(cs);
      }
      else {
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
        cs["status"] = getStack() + ".<br>" + stack[stackNum] + " is visited, ignore.";
        cs["lineNo"] = 5;
        stateList.push(cs);
      }
      stackNum--;
    }

    function getStack() {
      var status = "List = [";
      for (var i = stackNum; i > 0; i--) status = status + stack[i] + ",";
      if (stackNum >= 0) status += stack[0] + "]";
      else               status += "]";
      return status;
    }

    function Tdfs(u) {
      vertexTraversing[u] = true;
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = getStack() + ".<br>DFS(" + u + ").";
      cs["lineNo"] = 1;
      stateList.push(cs);
      delete vertexHighlighted[u];

      var neighbors = [];
      for (var j = 0; j < amountEdge; j++) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
        if (lab[vertexB] == -1 && u == vertexA) {
          edgeHighlighted[j] = true;
          for (var key in iEL) if (iEL[key]["v"] == vertexA && iEL[key]["u"] == vertexB) edgeHighlighted[key] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
          cs["status"] = getStack() + ".<br>Try edge " + vertexA + " &rarr; " + vertexB + ".";
          cs["lineNo"] = 2;
          cs["el"][j]["animateHighlighted"] = true;
          stateList.push(cs);

          if (p[vertexB] == -1) {
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
            cs["status"] = getStack() + ".<br>Vertex " + vertexB + " has not been visited.";
            cs["lineNo"] = 2;
            stateList.push(cs);

            p[vertexB] = u;
            Tdfs(vertexB);
          }
        }
      }

      stack[++stackNum] = u;
      delete vertexTraversing[u];
      vertexTraversed[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = getStack() + ".<br>DFS(" + u + ") is completed, add " + u + " to the front of the list.";
      cs["lineNo"] = 3;
      stateList.push(cs);
    }

    function DFS2(u) {
      lab[u] = labNum;
      vertexTraversing[u] = true;
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = getStack() + "<br>DFS(" + u + ").";
      cs["lineNo"] = 5;
      stateList.push(cs);
      delete vertexHighlighted[u];

      var neighbors = [];
      for (var j = 0; j < amountEdge; j++) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
        if (hiddenEdge[j] == null) {
          edgeHighlighted[j] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
          cs["status"] = getStack() + ".<br>Try edge " + vertexA + " &rarr; " + vertexB + ".";
          cs["lineNo"] = 6;
          cs["el"][j]["animateHighlighted"] = true;
          stateList.push(cs);

          if (lab[vertexB] == -1) {
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
            cs["status"] = getStack() + "<br>Vertex " + vertexB + " has not been visited.";
            cs["lineNo"] = 6;
            stateList.push(cs);

            DFS2(vertexB);
          }
          else {
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
            cs["status"] = getStack() + "<br>" + vertexB + " is visited";
            cs["lineNo"] = 6;
            stateList.push(cs);
          }
        }
      }

      delete vertexTraversing[u];
      vertexTraversed[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = getStack() + "<br>DFS from " + u + " is completed, back to the parent";
      cs["lineNo"] = 5;
      stateList.push(cs);
    }

    for (var i = 0; i < amountEdge; i++) {
      var vertexA = iEL[i]["u"];
      var vertexB = iEL[i]["v"];
      iEL[i]["u"] = vertexB;
      iEL[i]["v"] = vertexA;
    }
    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
    cs["status"] = "We transpose the directed graph again.<br>In total, we have " + labNum + " Strongly Connected Component(s) as seen above.";
    cs["lineNo"] = 0;
    stateList.push(cs);

    populatePseudocode(7);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.tarjan = function(callback) {
    var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {}, hiddenEdge = {};
    var stateList = [];
    var cs;

    //check error
    if (amountVertex == 0) { // no graph
      $('#scc-err').html('Không có đồ thị để chạy. Hãy chọn một đồ thị ví dụ trước.');
      return false;
    }

    if (!DIRECTED_GR) {
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = "The input graph is not set as 'directed' graph yet.<br>This algorithm only works with directed graphs.";
      cs["lineNo"] = 0;
      stateList.push(cs);

      this.directedChange(); // force change

      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = "We turn on the directed graph mode.<br>This action is irreversible.";
      cs["lineNo"] = 0;
      stateList.push(cs);

      // $('#scc-err').html("Please make the graph directed");
      // return false;
    }

    // main code
    var p = {}, stack = {}, stackNum = -1, Count = -1, low = {}, num = {}, lab = {}, labNum = 0;
    for (var i = 0; i < amountVertex; i++) {
      p[i] = lab[i] = -1
      iVL[i]["extratext"] = "N/A";
    }
    for (var i = 0; i < amountVertex; i ++)
      if (p[i] == -1) {
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
        cs["status"] = "Vertex " + i + " has not been visited.";
        cs["lineNo"] = 1;
        stateList.push(cs);
        p[i]--;
        Tdfs(i);
      }

    function getStack() {
      var status = "Stack = [";
      for (var i = 0; i < stackNum; i ++) status = status + stack[i] + ",";
      if (stackNum >= 0) status += stack[stackNum] + "]";
      else               status += "]";
      return status;
    }

    function Tdfs(u) {
      stack[++stackNum] = u;
      num[u] = low[u] = ++Count;
      iVL[u]["extratext"] = "" + num[u] + "," + low[u];
      vertexTraversing[u] = true;
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = getStack() + ".<br>DFS(" + u + ").";
      cs["lineNo"] = 2;
      stateList.push(cs);
      delete vertexHighlighted[u];

      var neighbors = [];
      for (var j = 0; j < amountEdge; j++) if (iEL[j]["u"] == u) neighbors.push(j);
      neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

      while (neighbors.length > 0) {
        var j = neighbors.shift();
        var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
        if (lab[vertexB] == -1 && u == vertexA) {
          edgeHighlighted[j] = true;
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
          cs["status"] = getStack() + "<br>Try edge " + vertexA + " &rarr; " + vertexB + ".";
          cs["lineNo"] = 3;
          cs["el"][j]["animateHighlighted"] = true;
          stateList.push(cs);

          if (p[vertexB] == -1) {
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
            cs["status"] = getStack() + "<br>Vertex " + vertexB + " has not been visited.";
            cs["lineNo"] = 4;
            stateList.push(cs);

            p[vertexB] = u;
            Tdfs(vertexB);
            if (low[u] > low[vertexB]) low[u] = low[vertexB];
          }
          else {
            if (low[u] > num[vertexB]) low[u] = num[vertexB];
          }
          iVL[u]["extratext"] = "" + num[u] + "," + low[u];
          cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
          cs["status"] = getStack() + "<br>Update low[" + u + "]."; // ambiguous for now " = min(num[" + vertexB + "], low[" + vertexB + "]).";
          cs["lineNo"] = 5;
          stateList.push(cs);
        }
      }

      delete vertexTraversing[u];
      vertexTraversed[u] = true;
      vertexHighlighted[u] = true;
      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = getStack() + "<br>DFS(" + u + ") is completed, check if vertex " + u + " is the root of this SCC.";
      cs["lineNo"] = 6;
      stateList.push(cs);
      if (low[u] == num[u]) {
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
        cs["status"] = getStack() + "<br>low[" + u + "] == num[" + u + "], that means this vertex " + u + " is the root of this SCC.";
        cs["lineNo"] = 6;
        stateList.push(cs);
        var oldPos = stackNum;
        labNum++;
        while (stack[stackNum] != u)
          lab[stack[stackNum--]] = labNum;
        lab[stack[stackNum--]] = labNum;

        for (var i = stackNum+1; i <= oldPos; i++)
          vertexHighlighted[stack[i]] = true;
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
        cs["status"] = getStack() + "<br>We pop the stack until we get vertex " + u + ".";
        cs["lineNo"] = 7;
        stateList.push(cs);
        for (var i = stackNum+1; i <= oldPos; i++)
          delete vertexHighlighted[stack[i]];

        for (var j = 0; j < amountEdge; j++) {
          var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
          if (lab[vertexA] != lab[vertexB]) hiddenEdge[j] = true;
        }
        cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
        cs["status"] = getStack() + "<br>We get 1 Strongly Connected Component.";
        cs["lineNo"] = 7;
        stateList.push(cs);
      }
      delete vertexHighlighted[u];
    }

    cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
    cs["status"] = "In total, we have " + labNum + " Strongly Connected Component(s) as seen above.";
    cs["lineNo"] = 1;
    stateList.push(cs);
    for (var key in iVL) iVL[key]["extratext"] = "";

    populatePseudocode(8);
    gw.startAnimation(stateList, callback);
    return true;
  }

  this.twosat = function(numOfRows, numOfColumns) {
    var vertexHighlighted = {}, edgeHighlighted = {};
    var stateList = [];
    var cs;
    var currentX = 0, currentY = -170, centerX = 200, centerY = 200;

    DIRECTED_GR = true;
    numOfColumns *= 2;
    var blocked = new Array(numOfRows+1);
    for (var i = 0; i <= numOfRows; i++) {
      blocked[i] = new Array(numOfColumns+1);
      for (var j = 0; j <= numOfColumns; j++)
        blocked[i][j] = false;
    }

    if (numOfRows < 1 || numOfRows > 5) {
      $('#twosat-err').html("The number of clauses must be [1..5].");
      return false;
    }

    if (numOfColumns < 1 || numOfColumns > 10) {
      $('#twosat-err').html("The number of variables must be [1..5].");
      return false;
    }

    $('#twosat-err').html("");

    this.checkInputt = function(XX) {
      var cc = 0;
      for (var j = 1; j <= numOfColumns; j ++)
        if (blocked[XX][j])
          cc++;
      return cc;
    }

    this.checkInput = function() { // each clause can only have two variables
      for (var i = 1; i <= numOfRows; i++) {
        var cc = 0;
        for (var j = 1; j <= numOfColumns; j ++) if (blocked[i][j]) cc++;
        if (cc != 2) return false;
      }
      return true;
    }

    this.changeState = function(rowIndex, columnIndex) {
      var temp = '#cell' + rowIndex + columnIndex;
      if (blocked[rowIndex][columnIndex]) {
        $(temp).attr("bgcolor", "white");
        blocked[rowIndex][columnIndex] = false;
      }
      else {
        $(temp).attr("bgcolor", "black");
        blocked[rowIndex][columnIndex] = true;
      }
      if (this.checkInputt(rowIndex) > 2) {
        $('#twosat-board-err').html("Row " + rowIndex + " has more than 2 black cells.")
          .delay(1000)
          .queue(function(n) {
            $(this).html("");
          });
      }
    }

    this.createGraph = function() {
      iVL = {};
      iEL = {};
      amountEdge = 0;
      amountVertex = numOfColumns;

      getvar = function(i) { return i%2 == 0 ? "-x" + (i/2+1) : "x" + (i+1)/2; }
      getOpp = function(i) { return i%2 == 0 ? i+1 : i-1; }

      for (var i = 1; i <= numOfColumns; ++i) {
        var angle = Math.acos(-1)*2/amountVertex;
        var x1 = currentX * Math.cos(angle) - currentY*Math.sin(angle);
        var y1 = currentX * Math.sin(angle) + currentY*Math.cos(angle);
        currentX = x1, currentY = y1;
        iVL[i-1] = {
          "x": currentX+centerX,
          "y": currentY+centerY,
          "extratext": i%2 == 0 ? "x" + i/2 : "-x" + (i+1)/2
        }
      }

      cs = createState(iVL, iEL);
      cs["status"] = "Create 2 vertices for each variable.<br>One for xi, the other for -xi.";
      cs["lineNo"] = 1;
      stateList.push(cs);

      for (var i = 1; i <= numOfRows; ++i) { // clauses
        var a, b;
        for (var j = 0; j < numOfColumns; j++) if (blocked[i][j+1]) a = j; // a
        for (var j = numOfColumns-1; j >= 0; j--) if (blocked[i][j+1]) b = j; // b
        // clause = (a v b)
        var pos1 = -1, pos2 = -1;
        var flag = true;
        for (var j = 0; j < amountEdge; j++)
          if (iEL[j]["u"] == getOpp(a) && iEL[j]["v"] == b)
            flag = false, pos1 = j;
        if (flag && getOpp(a) !== b) {
          iEL[amountEdge++] = {
            "u": getOpp(a),
            "v": b,
            "w": 1
          }
          pos1 = amountEdge-1;
        }

        flag = true;
        for (var j = 0; j < amountEdge; j++)
          if (iEL[j]["u"] == getOpp(b) && iEL[j]["v"] == a)
            flag = false, pos2 = j;
        if (flag && getOpp(b) !== a) {
          iEL[amountEdge++] = {
            "u": getOpp(b),
            "v": a,
            "w": 1
          }
          pos2 = amountEdge-1;
        }

        cs = createState(iVL, iEL);
        cs["status"] = "Clause = (" + getvar(a) + " or " + getvar(b) + ").<br>" +
                       "Create edge " + getvar(getOpp(a)) + " &rarr; " + getvar(b) + " (" + getOpp(a) + " &rarr; " + b + ") and " + getvar(getOpp(b)) + " &rarr; " + getvar(a) + " (" + getOpp(b) + " &rarr; " + a + ").";
        cs["lineNo"] = [2, 3];
        if (pos1 != -1) cs["el"][pos1]["animateHighlighted"] = true;
        if (pos2 != -1) cs["el"][pos2]["animateHighlighted"] = true;
        stateList.push(cs);
      }
      return true;
    }

    this.runAlgo = function() {
      var vertexHighlighted = {}, edgeHighlighted = {}, vertexTraversed = {}, vertexTraversing = {}, hiddenEdge = {};
      var cs;

      cs = createState(iVL, iEL);
      cs["status"] = "We run an SCC finding algorithm (either Kosaraju's or Tarjan's) to see if there is a conflict (a variable and its negation in the same SCC).";
      cs["lineNo"] = 4;
      stateList.push(cs);

      // main code
      var p = {}, stack = {}, stackNum = -1, Count = 0, low = {}, num = {}, lab = {}, labNum = 0;
      for (var i = 0; i < amountVertex; i ++)
        p[i] = lab[i] = -1;
      for (var i = 0; i < amountVertex; i ++)
        if (p[i] == -1) {
          p[i]--;
          Tdfs(i);
        }

      for (var j = 0; j < amountEdge; j++) {
        var vertexA = iEL[j]["u"];
        var vertexB = iEL[j]["v"];
        iEL[j]["u"] = vertexB;
        iEL[j]["v"] = vertexA;
      }

      while (stackNum >= 0) {
        if (lab[stack[stackNum]] == -1) {
          labNum++;
          DFS2(stack[stackNum]);
          var flag = -1;
          for (var z = 0; z < amountVertex; z += 2)
            if ((lab[z] == lab[z+1]) && (lab[z] == labNum))
              flag = z;

          if (flag != -1) {
            for (var key in iVL)
              if (lab[key] == lab[flag])
                vertexTraversed[key] = true;
            vertexHighlighted[flag] = vertexHighlighted[flag+1] = true;
            cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
            cs["status"] = "" + getvar(flag) + " (vertex " + flag + ") and " + getvar(flag+1) + " (vertex " + (flag+1) + ") are in the same SCC.<br>The 2-SAT instance is not satisfiable!";
            cs["lineNo"] = 7;
            stateList.push(cs);
            return true;
          }
        }
        stackNum--;
      }

      function Tdfs(u) {
        var neighbors = [];
        for (var j = 0; j < amountEdge; j++) if (iEL[j]["u"] == u) neighbors.push(j);
        neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

        while (neighbors.length > 0) {
          var j = neighbors.shift();
          var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
          if (lab[vertexB] == -1 && u == vertexA)
            if (p[vertexB] == -1) {
              p[vertexB] = u;
              Tdfs(vertexB);
            }
        }

        stack[++stackNum] = u;
      }

      function DFS2(u) {
        lab[u] = labNum;

        var neighbors = [];
        for (var j = 0; j < amountEdge; j++) if (iEL[j]["u"] == u) neighbors.push(j);
        neighbors.sort(function(a, b) { return iEL[a]["v"]-iEL[b]["v"] });

        while (neighbors.length > 0) {
          var j = neighbors.shift();
          var vertexA = iEL[j]["u"], vertexB = iEL[j]["v"];
          if (hiddenEdge[j] == null)
            if (lab[vertexB] == -1)
              DFS2(vertexB);
        }
      }

      for (var i = 0; i < amountEdge; i++) {
        var vertexA = iEL[i]["u"];
        var vertexB = iEL[i]["v"];
        iEL[i]["u"] = vertexB;
        iEL[i]["v"] = vertexA;
      }

      cs = createState(iVL, iEL, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, {}, {}, {}, {}, hiddenEdge);
      cs["status"] = "SCC algorithm is completed without any conflict.<br>So the 2-SAT instance is satisfiable!";
      cs["lineNo"] = 5;
      stateList.push(cs);
    }

    this.CloseBox = function() {
      $('.overlays').hide("slow");
      $('#dark-overlay').hide("slow");
      $('#rookattack-board').hide("slow");
    }

    this.inputExample1 = function() {
      numOfRows = 2;
      numOfColumns = 4;
      blocked = new Array(numOfRows+1);
      for (var i = 0; i <= numOfRows; i++) {
        blocked[i] = new Array(numOfColumns+1);
        for (var j = 0; j <= numOfColumns; j++)
          blocked[i][j] = false;
      }
      var toWrite = '<html>\n';
      toWrite += '<br>Click on any cell to toggle between black/white cell</br>\n';
      toWrite += '<br>Each black cell presents a clause. Each row should have exactly 2 black cells.</br>\n';
      toWrite += '<table border="1" id="board">'
      for (var j = 0; j <= numOfColumns; ++j)
        toWrite += '<col width="50">';

      toWrite += '<tr><td height="50" bgcolor="white" id="cell00"></td>';
      for (var j = 1; j <= numOfColumns; j++)
        if (j % 2 == 1)
          toWrite += '<td height="50" bgcolor="white" id="cell' + 0 + j + '">-x' + (j + 1) / 2 + '</td>';
        else
          toWrite += '<td height="50" bgcolor="white" id="cell' + 0 + j + '">x' + j / 2 + '</td>';
      toWrite += "</tr>"

      for (var i = 1; i <= numOfRows; ++i) {
        toWrite += '<tr>';
        toWrite += '<td height="50" bgcolor="white" id="cell00">' + i + '</td>';
        for (var j = 1; j <= numOfColumns; ++j)
          toWrite += '<td height="50" bgcolor="white" id="cell' + i + j + '" onclick=gtw.changeState(' + i + ',' + j + ')></td>';
        toWrite += '</tr>';
      }

      toWrite += '</table>\n';
      toWrite += '<button onclick=gtw.inputRandomized()>Randomized</button>';
      toWrite += '<button onclick=gtw.inputFinished()>Done</button>';
      toWrite += '<button onclick=gtw.inputExample1()>Example 1</button>';
      toWrite += '<button onclick=gtw.inputExample2()>Example 2</button>';
      toWrite += '<button onclick=gtw.CloseBox()>Close</button>';
      toWrite += '<div id="twosat-board-err" class="err"></div>';
      toWrite += '</html>\n';
      $('#twosat-board').html(toWrite);

      this.changeState(1, 1);
      this.changeState(1, 3);
      this.changeState(2, 2);
      this.changeState(2, 4);
    }

    this.inputExample2 = function() {
      numOfRows = 4;
      numOfColumns = 6;
      blocked = new Array(numOfRows+1);
      for (var i = 0; i <= numOfRows; i++) {
        blocked[i] = new Array(numOfColumns+1);
        for (var j = 0; j <= numOfColumns; j++)
          blocked[i][j] = false;
      }
      var toWrite = '<html>\n';
      toWrite += '<br>Click on any cell to toggle between black/white cell</br>\n';
      toWrite += '<br>Each black cell presents a clause. Each row should have exactly 2 black cells.</br>\n';
      toWrite += '<table border="1" id="board">'
      for (var j = 0; j <= numOfColumns; ++j)
        toWrite += '<col width="50">';

      toWrite += '<tr><td height="50" bgcolor="white" id="cell00"></td>';
      for (var j = 1; j <= numOfColumns; j++)
        if (j % 2 == 1)
          toWrite += '<td height="50" bgcolor="white" id="cell' + 0 + j + '">-x' + (j + 1) / 2 + '</td>';
        else
          toWrite += '<td height="50" bgcolor="white" id="cell' + 0 + j + '">x' + j / 2 + '</td>';
      toWrite += "</tr>"

      for (var i = 1; i <= numOfRows; ++i) {
        toWrite += '<tr>';
        toWrite += '<td height="50" bgcolor="white" id="cell00">' + i + '</td>';
        for (var j = 1; j <= numOfColumns; ++j)
          toWrite += '<td height="50" bgcolor="white" id="cell' + i + j + '" onclick=gtw.changeState(' + i + ',' + j + ')></td>';
        toWrite += '</tr>';
      }

      toWrite += '</table>\n';
      toWrite += '<button onclick=gtw.inputRandomized()>Randomized</button>';
      toWrite += '<button onclick=gtw.inputFinished()>Done</button>';
      toWrite += '<button onclick=gtw.inputExample1()>Example 1</button>';
      toWrite += '<button onclick=gtw.inputExample2()>Example 2</button>';
      toWrite += '<button onclick=gtw.CloseBox()>Close</button>';
      toWrite += '<div id="twosat-board-err" class="err"></div>';
      toWrite += '</html>\n';
      $('#twosat-board').html(toWrite);

      this.changeState(1, 2);
      this.changeState(1, 4);
      this.changeState(2, 1);
      this.changeState(2, 4);
      this.changeState(3, 3);
      this.changeState(3, 6);
      this.changeState(4, 3);
      this.changeState(4, 5);
    }

    this.inputFinished = function() {
      if (!this.checkInput()) {
        $('#twosat-board-err').html("Each row should have exactly 2 black cells.")
          .delay(1000)
          .queue(function(n) {
            $(this).html("");
          });
        return false;
      }

      $('.overlays').hide("slow");
      $('#dark-overlay').hide("slow");
      $('#rookattack-board').hide("slow");
      this.createGraph();
      this.runAlgo();
      gw.startAnimation(stateList);
      $('#current-action').show();
      $('#current-action p').html("2-SAT Modeling");
      $('#progress-bar').slider("option", "max", gw.getTotalIteration()-1);
      triggerRightPanels();
      populatePseudocode(9);
      isPlaying = true;
      return true;
    }

    this.inputRandomized = function() {
      var randNumMin = 1;
      var randNumMax = numOfColumns;
      for (var i = 1; i <= numOfRows; i++) {
        for (var j = 1; j <= numOfColumns; j++)
          if (blocked[i][j])
            this.changeState(i, j);
        var a = (Math.floor(Math.random() * (randNumMax-randNumMin+1)) + randNumMin);
        var b = (Math.floor(Math.random() * (randNumMax-randNumMin+1)) + randNumMin);
        while (a == b)
          b = (Math.floor(Math.random() * (randNumMax-randNumMin+1)) + randNumMin);
        this.changeState(i, a);
        this.changeState(i, b);
      }
    }

    $('#dark-overlay').show("slow");
    var toWrite = '<html>\n';
    toWrite += '<br>Click on any cell to toggle between black/white cell</br>\n';
    toWrite += '<br>Each black cell presents a clause. Each row should have exactly 2 black cells.</br>\n';
    toWrite += '<table border="1" id="board">'
    for (var j = 0; j <= numOfColumns; ++j)
      toWrite += '<col width="50">';

    toWrite += '<tr><td height="50" bgcolor="white" id="cell00"></td>';
    for (var j = 1; j <= numOfColumns; j++)
      if (j % 2 == 1)
        toWrite += '<td height="50" bgcolor="white" id="cell' + 0 + j + '">-x' + (j+1)/2 + '</td>';
      else
        toWrite += '<td height="50" bgcolor="white" id="cell' + 0 + j + '">x' + j/2 + '</td>';
    toWrite += "</tr>"

    for (var i = 1; i <= numOfRows; ++i) {
      toWrite += '<tr>';
      toWrite += '<td height="50" bgcolor="white" id="cell00">' + i + '</td>';
      for (var j = 1; j <= numOfColumns; ++j)
        toWrite += '<td height="50" bgcolor="white" id="cell' + i + j + '" onclick=gtw.changeState(' + i + ',' + j + ')></td>';
      toWrite += '</tr>';
    }

    toWrite += '</table>\n';
    toWrite += '<button onclick=gtw.inputRandomized()>Randomized</button>';
    toWrite += '<button onclick=gtw.inputFinished()>Done</button>';
    toWrite += '<button onclick=gtw.inputExample1()>Example 1</button>';
    toWrite += '<button onclick=gtw.inputExample2()>Example 2</button>';
    toWrite += '<button onclick=gtw.CloseBox()>Close</button>';
    toWrite += '<div id="twosat-board-err" class="err"></div>';
    toWrite += '</html>\n';
    $('#twosat-board').html(toWrite);
    $('#twosat-board').show("slow");
  }

  this.examples = function(id) {
    iVL = getExampleGraph(id, VL);
    iEL = getExampleGraph(id, EL);
    amountVertex = 0;
    amountEdge = 0;
    for (var key in iVL) amountVertex++;
    for (var key in iEL) amountEdge++;

    DIRECTED_GR = true;
    OLD_POSITION = amountEdge;

    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
    return true;
  }

  this.loadGraph = function(vertexList, edgeList) {
    iVL = vertexList;
    iEL = edgeList;
    fixJSON();
    var newState = createState(iVL, iEL);
    gw.updateGraph(newState, 500);
  }

  function createState(iVLObject, iELObject, vertexHighlighted, edgeHighlighted, vertexTraversed, vertexTraversing, treeEdge, backEdge, crossEdge, forwardEdge, hiddenEdge) {
    if (vertexHighlighted == null) vertexHighlighted = {};
    if (edgeHighlighted == null) edgeHighlighted = {};
    if (vertexTraversed == null) vertexTraversed = {};
    if (vertexTraversing == null) vertexTraversing = {};
    if (treeEdge == null) treeEdge = {};
    if (backEdge == null) backEdge = {};
    if (crossEdge == null) crossEdge = {};
    if (forwardEdge == null) forwardEdge = {};
    if (hiddenEdge == null) hiddenEdge = {};

    var key, state = {
      "vl": {},
      "el": {}
    };

    for (key in iVLObject) {
      state["vl"][key] = {};
      state["vl"][key]["cx"] = iVLObject[key]["x"];
      state["vl"][key]["cy"] = iVLObject[key]["y"];
      state["vl"][key]["text"] = key;
      state["vl"][key]["extratext"] = iVLObject[key]["extratext"];
      if (iVLObject[key]["state"] == OBJ_HIDDEN)
        state["vl"][key]["state"] = OBJ_HIDDEN;
      else
        state["vl"][key]["state"] = VERTEX_DEFAULT;
    }

    for (key in iELObject) {
      state["el"][key] = {};
      state["el"][key]["vertexA"] = iELObject[key]["u"];
      state["el"][key]["vertexB"] = iELObject[key]["v"];
      if (DIRECTED_GR == false)
        state["el"][key]["type"] = EDGE_TYPE_UDE;
      else
        state["el"][key]["type"] = EDGE_TYPE_DE;
      state["el"][key]["weight"] = iELObject[key]["w"];
      if (iELObject[key]["state"] == OBJ_HIDDEN)
        state["el"][key]["state"] = OBJ_HIDDEN;
      else
        state["el"][key]["state"] = EDGE_DEFAULT;
      state["el"][key]["displayWeight"] = false;
      state["el"][key]["animateHighlighted"] = false;
    }

    for (key in vertexTraversed) state["vl"][key]["state"] = VERTEX_TRAVERSED;
    for (key in vertexTraversing) state["vl"][key]["state"] = VERTEX_BLUE_OUTLINE;
    for (key in treeEdge) state["el"][key]["state"] = EDGE_RED;
    for (key in backEdge) state["el"][key]["state"] = EDGE_BLUE;
    for (key in crossEdge) state["el"][key]["state"] = EDGE_GREEN;
    for (key in forwardEdge) state["el"][key]["state"] = EDGE_GREY;

    for (key in vertexHighlighted) state["vl"][key]["state"] = VERTEX_HIGHLIGHTED;
    for (key in edgeHighlighted) {
      state["el"][key]["state"] = EDGE_HIGHLIGHTED;
      for (var keyR in iEL) if ((iEL[key]["u"] == iEL[keyR]["v"]) && (iEL[key]["v"] == iEL[keyR]["u"])) edgeHighlighted[keyR] = true;
    }

    for (key in hiddenEdge) state["el"][key]["state"] = EDGE_GREY;

    return state;
  }

  function populatePseudocode(act) {
    switch (act) {
      case 0: // DFS
        $('#code1').html('DFS(u)');
        $('#code2').html('for each neighbor v of u');
        $('#code3').html('&nbsp;&nbsp;if v is unvisited, tree edge, DFS(v)');
        $('#code4').html('&nbsp;&nbsp;else if v is explored, bidirectional/back edge');
        $('#code5').html('&nbsp;&nbsp;else if v is visited, forward/cross edge');
        $('#code6').html('// <b><a href="http://cpbook.net/#downloads" target="_blank">ch4_01_dfs.cpp/java, ch4, CP3</a></b>');
        $('#code7').html('');
        break
      case 1: // BFS
        $('#code1').html('BFS(u), Q = {u}');
        $('#code2').html('while !Q.empty // Q is a normal queue');
        $('#code3').html('&nbsp;&nbsp;for each neighbor v of u = Q.front, Q.pop');
        $('#code4').html('&nbsp;&nbsp;&nbsp;&nbsp;if v is unvisited, tree edge, Q.push(v)');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;else if v is visited, we ignore this edge'); // bidirectional/back edge
        $('#code6').html('// <b><a href="http://cpbook.net/#downloads" target="_blank">ch4_04_bfs.cpp/java, ch4, CP3</a></b>');
        $('#code7').html('');
        break;
      case 2: // Topological Sort using DFS
        $('#code1').html('for each unvisited vertex u');
        $('#code2').html('&nbsp;&nbsp;DFS(u)');
        $('#code3').html('&nbsp;&nbsp;&nbsp;&nbsp;for each neighbor v of u');
        $('#code4').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if v is unvisited, DFS(v)');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;else skip v;');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;finish DFS(u), add u to the back of list');
        $('#code7').html('reverse list // <b><a href="http://cpbook.net/#downloads" target="_blank">ch4_01_dfs.cpp/java, ch4, CP3</a></b>');
        break
      case 3: // Topological Sort using BFS
        $('#code1').html('add vertices with no incoming edge to queue Q');
        $('#code2').html('while !Q.empty // Q is a normal queue');
        $('#code3').html('&nbsp;&nbsp;u = Q.front, Q.pop, add u to the back of list');
        $('#code4').html('&nbsp;&nbsp;for each neighbor v of u');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;delete edge u &rarr; v');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;if v has no incoming edge, add v to queue');
        $('#code7').html('// done'); // not in CP3, only as exercise at the moment?
        break;
      case 4: // bipartite DFS
        $('#code1').html('for each unvisited vertex u');
        $('#code2').html('&nbsp;&nbsp;DFS(u)');
        $('#code3').html('&nbsp;&nbsp;&nbsp;&nbsp;for each neighbor v of u');
        $('#code4').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if v is unvisited, different color, DFS(v)');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if u and v have the same color');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not bipartite graph, exit.');
        $('#code7').html(''); // not in CP3, only as exercise at the moment? // <b><a href="http://cpbook.net/#downloads" target="_blank">ch4_01_dfs.cpp/java, ch4, CP3</a></b>');
        break
      case 5: // bipartite BFS
        $('#code1').html('for each unvisited vertex u');
        $('#code2').html('&nbsp;&nbsp;push u to the queue');
        $('#code3').html('&nbsp;&nbsp;while !Q.empty // Q is a normal queue');
        $('#code4').html('&nbsp;&nbsp;&nbsp;&nbsp;for each neighbor v of u = Q.front, Q.pop');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if u and v have the same color &rarr; exit');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assign another color to v, push v to queue');
        $('#code7').html('// <b><a href="http://cpbook.net/#downloads" target="_blank">ch4_01_dfs.cpp/java, ch4, CP3</a></b>');
        break
      case 6: // articulation points and bridges
        $('#code1').html('try all vertex u, if u hasnt been visited, DFS(u)');
        $('#code2').html('DFS(u), initiate num[u] = low[u] = DFSCount');
        $('#code3').html('&nbsp;&nbsp;try all neighbor v of u');
        $('#code4').html('&nbsp;&nbsp;&nbsp;&nbsp;if v is free, DFS(v)');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low[u] = min(low[u], low[v])');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;check the condition');
        $('#code7').html('&nbsp;&nbsp;&nbsp;&nbsp;else low[u] = min(low[u], num[v])');
        break;
      case 7: // Kosaraju's algorithm
        $('#code1').html('for each unvisited vertex u, DFS(u)');
        $('#code2').html('&nbsp;&nbsp;try all free neighbor v of u, DFS(v)');
        $('#code3').html('&nbsp;&nbsp;finish DFS(u), add u to the front of list');
        $('#code4').html('transpose the graph');
        $('#code5').html('DFS in order of the list, DFS(u)');
        $('#code6').html('&nbsp;&nbsp;try all free neighbor v of u, DFS(v)');
        $('#code7').html('each time we complete a DFS, we get an SCC');
        break;
      case 8: // Tarjan's algorithm
        $('#code1').html('for each unvisited vertex u');
        $('#code2').html('&nbsp;&nbsp;DFS(u), s.push(u), num[u] = low[u] = DFSCount');
        $('#code3').html('&nbsp;&nbsp;&nbsp;&nbsp;for each neighbor v of u');
        $('#code4').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if v is unvisited, DFS(v)');
        $('#code5').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low[u] = min(low[u], low[v])');
        $('#code6').html('&nbsp;&nbsp;&nbsp;&nbsp;if low[u] == num[u] // root of an SCC');
        $('#code7').html('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop from stack s until we get u');
        break;
      case 9: // two-sat
        $('#code1').html('create graph, each variable creates 2 vertices');
        $('#code2').html('for clause (a or b)');
        $('#code3').html('&nbsp;&nbsp;create edge -a &rarr; b and -b &rarr; a');
        $('#code4').html('run scc algorithm');
        $('#code5').html('if no conflict, the 2-SAT instance is satisfiable');
        $('#code6').html('if a variable and its negation are in the same SCC');
        $('#code7').html('&nbsp;&nbsp;the 2-SAT instance is not satisfiable');
        break;
    }
  }
}



// Graph Traversal action
var actionsWidth = 150;
var statusCodetraceWidth = 410;
var isExamplesOpen = false, isBFSOpen = false, isDFSOpen = false, isTopoOpen = false, isBipartiteOpen = false, isBridgeOpen = false, isSCCOpen = false, is2SATOpen = false;

function openExamples() {
  if (!isExamplesOpen) {
    $('.examples').fadeIn('fast');
    isExamplesOpen = true;
  }
}

function closeExamples() {
  if (isExamplesOpen) {
    $('.examples').fadeOut('fast');
    isExamplesOpen = false;
  }
}

function openDFS() {
  if (!isDFSOpen) {
    $('.dfs').fadeIn('fast');
    isDFSOpen = true;
  }
}

function closeDFS() {
  if (isDFSOpen) {
    $('.dfs').fadeOut('fast');
    $('#dfs-err').html("");
    isDFSOpen = false;
  }
}

function openBFS() {
  if (!isBFSOpen) {
    $('.bfs').fadeIn('fast');
    isBFSOpen = true;
  }
}

function closeBFS() {
  if (isBFSOpen) {
    $('.bfs').fadeOut('fast');
    $('#bfs-err').html("");
    isBFSOpen = false;
  }
}

function openTopo() {
  if (!isTopoOpen) {
    $('.topo').fadeIn('fast');
    isTopoOpen = true;
  }
}

function closeTopo() {
  if (isTopoOpen) {
    $('.topo').fadeOut('fast');
    $('#topo-err').html("");
    isTopoOpen = false;
  }
}

function openBipartite() {
  if (!isBipartiteOpen) {
    $('.bipartite').fadeIn('fast');
    isBipartiteOpen = true;
  }
}

function closeBipartite() {
  if (isBipartiteOpen) {
    $('.bipartite').fadeOut('fast');
    $('#bipartite-err').html("");
    isBipartiteOpen = false;
  }
}

function openBridge() {
  if (!isBridgeOpen) {
    $('.bridge').fadeIn('fast');
    isBridgeOpen = true;
  }
}

function closeBridge() {
  if (isBridgeOpen) {
    $('.bridge').fadeOut('fast');
    $('#bridge-err').html("");
    isBridgeOpen = false;
  }
}

function openScc() {
  if (!isSCCOpen) {
    $('.scc').fadeIn('fast');
    isSCCOpen = true;
  }
}

function closeScc() {
  if (isSCCOpen) {
    $('.scc').fadeOut('fast');
    $('#scc-err').html("");
    isSCCOpen = false;
  }
}

function open2sat() {
  $('#twosat-v1').val(3);
  $('#twosat-v2').val(3);
  if (!is2SATOpen) {
    $('.twosat').fadeIn('fast');
    is2SATOpen = true;
  }
}

function close2sat() {
  if (is2SATOpen) {
    $('.twosat').fadeOut('fast');
    $('#twosat-err').html("");
    is2SATOpen = false;
  }
}

function hideEntireActionsPanel() {
  closeExamples();
  closeDFS();
  closeBFS();
  closeTopo();
  closeBipartite();
  closeBridge();
  closeScc();
  close2sat();
  hideActionsPanel();
}



// local
write(false, true);
var gtw, gw, randomGraphID;

$(function() {
  $('#play').hide();
  gtw = new GraphTraversal();
  gw = gtw.getGraphWidget();
  var options = [CP3_4_1, CP3_4_3, CP3_4_4, CP3_4_9, CP3_4_17, CP3_4_18, CP3_4_19];
  gtw.examples(options[Math.floor(Math.random()*7)]);
  randomGraphID = -1;
  var graphJSON = getQueryVariable("create");
  if (graphJSON.length > 0) {
    importjson(graphJSON);
    window.history.pushState("object or string", "Title", window.location.href.split('?')[0]);
  }
  // var directed = getQueryVariable("directed");
  // if (directed.length > 0) {
  //   directed = parseInt(directed);
  //   if (directed === 0)
  //     directedChange();
  // }

  $('#examples').click(function() {
    openExamples();
    closeDFS();
    closeBFS();
    closeTopo();
    closeBipartite();
    closeBridge();
    closeScc();
    close2sat();
  });

  $('#directedChange').click(function() {
    closeExamples();
    closeDFS();
    closeBFS();
    closeTopo();
    closeBipartite();
    closeBridge();
    closeScc();
    close2sat();
  });

  $('#dfs').click(function() {
    closeExamples();
    openDFS();
    closeBFS();
    closeTopo();
    closeBipartite();
    closeBridge();
    closeScc();
    close2sat();
  });

  $('#bfs').click(function() {
    closeExamples();
    closeDFS();
    openBFS();
    closeTopo();
    closeBipartite();
    closeBridge();
    closeScc();
    close2sat();
  });

  $('#topo').click(function() {
    closeExamples();
    closeDFS();
    closeBFS();
    openTopo();
    closeBipartite();
    closeBridge();
    closeScc();
    close2sat();
  });

  $('#bipartite').click(function() {
    closeExamples();
    closeDFS();
    closeBFS();
    closeTopo();
    openBipartite();
    closeBridge();
    closeScc();
    close2sat();
  });

  $('#bridge').click(function() {
    closeExamples();
    closeDFS();
    closeBFS();
    closeTopo();
    closeBipartite();
    openBridge();
    closeScc();
    close2sat();
  });

  $('#scc').click(function() {
    closeExamples();
    closeDFS();
    closeBFS();
    closeTopo();
    closeBipartite();
    closeBridge();
    openScc();
    close2sat();
  });

  $('#twosat').click(function() {
    closeExamples();
    closeDFS();
    closeBFS();
    closeTopo();
    closeBipartite();
    closeBridge();
    closeScc();
    open2sat();
  });
});

function importjson(text) {
  if (isPlaying) stop();
  if (mode == "exploration") {
    gtw.importjson(text);
    closeExamples();
    isPlaying = false;
  }
}

function drawGraph() {
  if (isPlaying) stop();
  if (mode == "exploration") {
    $('#dark-overlay').fadeIn(function() {
      $('#drawgraph').fadeIn();
    });
    gtw.startLoop();
    isPlaying = false;
  }
}

function drawDone() {
  if (!gtw.draw()) return false;
  gtw.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

function drawCancel() {
  gtw.stopLoop();
  $('#drawgraph').fadeOut();
  $('#dark-overlay').fadeOut();
}

// function createRandom() {
//   if (isPlaying) stop();
//   if (mode == "exploration") {
//     var n = Math.floor(Math.random()*6 + 5);
//     $.ajax({
//       url: PHP_DOMAIN + "/php/Graph.php?mode=" + MODE_GET_RANDOM_SUBMITTED_GRAPH + "&directed=" + 1 + "&connected=" + 1
//     }).done(function(data) {
//       data = JSON.parse(data);
//       var graph = extractQnGraph(data.graph);
//       if (data.graphID == randomGraphID) // to ensure we get different graph per click (make sure #graph > 1 in the database)
//         createRandom();
//       randomGraphID = data.graphID;
//       gtw.initRandom(graph);
//       $('#rate-sample-graph').show();
//     })
//     $('#progress-bar').slider("option", "max", 0);
//     closeExamples();
//     isPlaying = false;
//   }
// }

function example(id) {
  if (isPlaying) stop();
  setTimeout(function() {
    if (gtw.examples(id)) { // (mode == "exploration") && 
      $('#progress-bar').slider("option", "max", 0);
      closeExamples();
      isPlaying = false;
    }
  }, 500);
}

function directedChange() {
  if (isPlaying) stop();
  setTimeout(function() {
    if ((mode == "exploration") && gtw.directedChange()) {
      $('#progress-bar').slider("option", "max", 0);
      isPlaying = false;
    }
  }, 500);
}

function dfs(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#dfs-v').val());
  commonAction(gtw.dfs(input, callback), "DFS(" + input + ")");
  setTimeout(function() { $("#dfs-v").val(1 + Math.floor(Math.random()*gtw.getV())); }, 500); // randomized for next click between [0..V-1]
}

function bfs(callback) {
  if (isPlaying) stop();
  var input = parseInt($('#bfs-v').val());
  commonAction(gtw.bfs(input, callback), "BFS(" + input + ")");
  setTimeout(function() { $("#bfs-v").val(1 + Math.floor(Math.random()*gtw.getV())); }, 500);
}

function toposortDfs(callback) {
  if (isPlaying) stop();
  commonAction(gtw.toposortDfs(callback), "Topological Sort (DFS)");
}

function toposortBfs(callback) {
  if (isPlaying) stop();
  commonAction(gtw.toposortBfs(callback), "Topological Sort (BFS)");
}

function bipartiteDfs(callback) {
  if (isPlaying) stop();
  commonAction(gtw.bipartiteDfs(callback), "Bipartite Graph Checker (DFS)");
}

function bipartiteBfs(callback) {
  if (isPlaying) stop();
  commonAction(gtw.bipartiteBfs(callback), "Bipartite Graph Checker (BFS)");
}

function bridge(callback) {
  if (isPlaying) stop();
  commonAction(gtw.bridge(callback), "Articulation Points and Bridges Checker");
}

function kosaraju(callback) {
  if (isPlaying) stop();
  commonAction(gtw.kosaraju(callback), "Kosaraju's Algorithm");
}

function tarjan(callback) {
  if (isPlaying) stop();
  commonAction(gtw.tarjan(callback), "Tarjan's Algorithm");
}

function twosat() {
  if (isPlaying) stop();
  var input1 = parseInt($('#twosat-v1').val()), input2 = parseInt($('#twosat-v2').val());
  commonAction(gtw.twosat(input1, input2), "2-SAT Checker");
}

function loadGraph(graph) {
  if (gtw) {
    gtw.loadGraph(graph['vl'], graph['el']);
  }
}

// Implement these functions in each visualisation
var userGraph = {
  'vl': {},
  'el': {},
};

// This function will be called before entering E-Lecture Mode
function ENTER_LECTURE_MODE() {
  if (gtw) userGraph = gtw.getGraph();
}

// This function will be called before returning to Explore Mode
function ENTER_EXPLORE_MODE() {
  loadGraph(userGraph);
}

// Lecture action functions
function CUSTOM_ACTION(action, data, mode) {
  if (action == 'dfs') {
    hideSlide(function() {
      $('#dfs-v').val(0); // force
      dfs(showSlide);
    });
  }
  else if (action == 'bfs') {
    hideSlide(function() {
      $('#bfs-v').val(5); // force
      bfs(showSlide);
    });
  }
  else if (action == 'toposort_dfs') {
    hideSlide(function() {
      toposortDfs(showSlide);
    });
  }
  else if (action == 'toposort_bfs') {
    hideSlide(function() {
      toposortBfs(showSlide);
    });
  }
  else if (action == 'bipartite_dfs') {
    hideSlide(function() {
      bipartiteDfs(showSlide);
    });
  }
  else if (action == 'bipartite_bfs') {
    hideSlide(function() {
      bipartiteBfs(showSlide);
    });
  }
  else if (action == 'bridge') {
    hideSlide(function() {
      bridge(showSlide);
    });
  }
  else if (action == 'kosaraju') {
    hideSlide(function() {
      kosaraju(showSlide);
    });
  }
  else if (action == 'tarjan') {
    hideSlide(function() {
      tarjan(showSlide);
    });
  }
}
</script>
</body>

<!-- Mirrored from visualgo.net/vi/dfsbfs by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 26 Nov 2020 06:40:12 GMT -->
</html>
